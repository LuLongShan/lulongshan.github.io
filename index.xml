<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>joe</title><link>https://holicc.github.io/</link><description>Recent content on joe</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Thu, 06 May 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://holicc.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>Raft Algorithm</title><link>https://holicc.github.io/post/algorithm/raft/</link><pubDate>Thu, 06 May 2021 00:00:00 +0000</pubDate><guid>https://holicc.github.io/post/algorithm/raft/</guid><description>Raft</description></item><item><title>Sidecar Pattern</title><link>https://holicc.github.io/post/design-pattern/sidecar-pattern/</link><pubDate>Fri, 19 Feb 2021 00:00:00 +0000</pubDate><guid>https://holicc.github.io/post/design-pattern/sidecar-pattern/</guid><description>[译]Sidecar Pattern 为了将应用的各个组件独立封装部署在不同的进程或者容器中。这个设计模式也可以是允许应用整合多种各类型的组件和技术。 这个设</description></item><item><title>Fork And Exec</title><link>https://holicc.github.io/post/shell/process/</link><pubDate>Fri, 25 Dec 2020 00:00:00 +0000</pubDate><guid>https://holicc.github.io/post/shell/process/</guid><description>Intro When i view code of micro.I found a interesting function run,so i deep into it. Concededly Golang is static programing language,which don't have dymanic load class function like Java.So this function probably implement by executing a command.Fortunately,micro has pretty clean project structure,i can find it easily.
Create Service instance:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 func (r *localRuntime) Create(resource runtime.</description></item><item><title>Guitar Roadmap</title><link>https://holicc.github.io/post/guitar/roadmap/</link><pubDate>Tue, 15 Dec 2020 00:00:00 +0000</pubDate><guid>https://holicc.github.io/post/guitar/roadmap/</guid><description>Note This article copy from.For recording. The Learning Guitar Roadmap The Roadmap If your starting out at guitar, I’d recommend to tackle two parallel streams of practice at the same time. One is your single note playing and the other is learning chords. Both of these streams should be supplemented by their own theory and techniques. Single Note Playing (爬格子练习) In terms</description></item><item><title>Go Timer</title><link>https://holicc.github.io/post/golang/go-timer/</link><pubDate>Thu, 10 Dec 2020 00:00:00 +0000</pubDate><guid>https://holicc.github.io/post/golang/go-timer/</guid><description>Golang Timer 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 // The Timer type represents a single event. // When the Timer expires, the current time will be sent on C, // unless the Timer was created by AfterFunc. // A Timer must be created with NewTimer or AfterFunc. type Timer struct { C &amp;lt;-chan Time r</description></item><item><title>Common Principles</title><link>https://holicc.github.io/post/system-design/principles/</link><pubDate>Sat, 10 Oct 2020 00:00:00 +0000</pubDate><guid>https://holicc.github.io/post/system-design/principles/</guid><description>Contents Vertical scaling Horizontal scaling Caching Load balancing Database replication Database partitioning CAP theorem Domain name system Content delivery network Vertical scaling Vertical scaling means add more new resources in the existing system to meet the expectation. In other words that you scale by adding more power (CPU, RAM) to an existing machine. Good example of vertical scaling is The cloud version of MySQL Horizontal scaling Horizontal scaling means that</description></item><item><title>Logout GET or POST</title><link>https://holicc.github.io/post/network/about-logout-method/</link><pubDate>Thu, 10 Sep 2020 00:00:00 +0000</pubDate><guid>https://holicc.github.io/post/network/about-logout-method/</guid><description>[Copy]Logout: GET or POST This question is not about when to use GET or POST in general; it is about which is the recommended one for handling logging out of a web application. I have found plenty of information on the differences between GET and POST in the general sense, but I did not find a definite answer for this particular scenario. As a pragmatist, I'm inclined to use GET,</description></item><item><title>Go Code Style</title><link>https://holicc.github.io/post/golang/go-code-snippet/</link><pubDate>Tue, 01 Sep 2020 00:00:00 +0000</pubDate><guid>https://holicc.github.io/post/golang/go-code-snippet/</guid><description>goroutine limiter 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 var count int32 resp := make([]*CommandResponse, len(req.Images)) // waitForAllJob := make(chan struct{}, cfg.Server.MaxParallelNum) defer close(waitForAllJob) // for i := 0; i &amp;lt; len(req.Images); i++ { waitForAllJob &amp;lt;- struct{}{} go func(index int, img *model.Image) { response := process(img) resp[index] = response &amp;lt;-waitForAllJob atomic.AddInt32(&amp;amp;count, 1) }(i, &amp;amp;req.Images[i]) } // for int32(len(req.Images)) !</description></item><item><title>Postgres VS MySQL</title><link>https://holicc.github.io/post/database/postgres/</link><pubDate>Wed, 26 Aug 2020 00:00:00 +0000</pubDate><guid>https://holicc.github.io/post/database/postgres/</guid><description>History POSTGRES的实现始于 1986 年，现在被称为PostgreSQL的对象-关系型数据库管理系统是从加州大学伯克利分校写的POSTGRES软件包</description></item><item><title>Go Code Style</title><link>https://holicc.github.io/post/golang/go-code-style/</link><pubDate>Mon, 17 Aug 2020 00:00:00 +0000</pubDate><guid>https://holicc.github.io/post/golang/go-code-style/</guid><description>Receiver Type Choosing whether to use a value or pointer receiver on methods can be difficult, especially to new Go programmers. If in doubt, use a pointer, but there are times when a value receiver makes sense, usually for reasons of efficiency, such as for small unchanging structs or values of basic type. Some useful guidelines:
If the receiver is a map, func or chan, don't use a pointer to them.</description></item><item><title>Rust Concurrency</title><link>https://holicc.github.io/post/rust/rust-concurrency/</link><pubDate>Wed, 05 Aug 2020 00:00:00 +0000</pubDate><guid>https://holicc.github.io/post/rust/rust-concurrency/</guid><description>Rust Concurrency Rust中的线程（Thread）使用的是1:1 model而不是像Golang中的goroutine使用的是M:N model； 因为Rust</description></item><item><title>Rust Features</title><link>https://holicc.github.io/post/rust/rust-features/</link><pubDate>Wed, 05 Aug 2020 00:00:00 +0000</pubDate><guid>https://holicc.github.io/post/rust/rust-features/</guid><description>Rust Unsafe 使用unsafe的五种特性： Dereference a raw pointer Call an unsafe function or method Access or modify a mutable static variable Implement an unsafe trait Access fields of unions Dereferencing a Raw Pointer 定义 raw pointer 1 2 3 4 5 6 fn main(){letmutnum=5;letr1=&amp;amp;numas*consti32;letr2=&amp;amp;mutnumas*muti32;} 释放 1 2 3 4 5 6 7 8 9 10 11</description></item><item><title>Powershell Notes</title><link>https://holicc.github.io/post/shell/powershell-notes/</link><pubDate>Tue, 04 Aug 2020 00:00:00 +0000</pubDate><guid>https://holicc.github.io/post/shell/powershell-notes/</guid><description>Unix时间戳： 1 Get-Date -UFormat %s 查看文件（类似cat的功能） 1 type $file 创建文件： 1 New-Item [path] 使用记事本打开文件 1 Start-Process notepad $file 打开文件夹 1 ii . 或者 1 Invoke-Item . 函数别名 1 Set-Alias 如</description></item><item><title>Rust Smart Pointer</title><link>https://holicc.github.io/post/rust/rust-smart-pointer/</link><pubDate>Tue, 04 Aug 2020 00:00:00 +0000</pubDate><guid>https://holicc.github.io/post/rust/rust-smart-pointer/</guid><description>Rust Smart Pointer (智能指针) 普通指针（Reference）: &amp;amp; 使用这个定义的，只是指向了对应的内存地址，并没有其他的功能； 智能指针（Smart Poin</description></item><item><title>Rust Testing</title><link>https://holicc.github.io/post/rust/rust-testing/</link><pubDate>Tue, 21 Jul 2020 00:00:00 +0000</pubDate><guid>https://holicc.github.io/post/rust/rust-testing/</guid><description>Rust单元测试 在Rust中使用测试，相当于在Java中使用@Test注解一样 1 2 3 4 5 6 7 #[cfg(test)]mod tests{#[test]fn it_works(){assert_eq!(2+2,4);}} 其中#[test]就相当于一个注解表示这个</description></item><item><title>Rust Error</title><link>https://holicc.github.io/post/rust/rust-error/</link><pubDate>Fri, 17 Jul 2020 00:00:00 +0000</pubDate><guid>https://holicc.github.io/post/rust/rust-error/</guid><description>Rust中的错误处理 Rust中没有Exception这个概念，而是把错误分为了两种，一种是可恢复的错误，一种是不可恢复的错误 对于可恢复的错误</description></item><item><title>Rust Collections</title><link>https://holicc.github.io/post/rust/rust-collections/</link><pubDate>Wed, 15 Jul 2020 00:00:00 +0000</pubDate><guid>https://holicc.github.io/post/rust/rust-collections/</guid><description>Rust中的集合类型 Rust的标准库中提供了常用的集合类型：Vect(相当于Java中的List)，Map(相当于Java中的Map)，在使</description></item><item><title>RocketMQ</title><link>https://holicc.github.io/post/java/rocketmq-overstock/</link><pubDate>Sun, 12 Jul 2020 00:00:00 +0000</pubDate><guid>https://holicc.github.io/post/java/rocketmq-overstock/</guid><description>RocketMQ服务部署情况介绍 由于项目对消息的可靠性要求比较高所以采用的是SYNC_MASTER+SLAVE的部署方式, 并且使用了ASYN</description></item><item><title>Rust Packages Management</title><link>https://holicc.github.io/post/rust/rust-packages-management/</link><pubDate>Fri, 10 Jul 2020 00:00:00 +0000</pubDate><guid>https://holicc.github.io/post/rust/rust-packages-management/</guid><description>Rust Packages Crates and Modules 每个新出的编程语言都有一套对应的包管理工具，Rust也不列外，Rust使用的是cargo作为其包管理工具； crate是一个单一的库</description></item><item><title>Rust Enums And Patter Match</title><link>https://holicc.github.io/post/rust/rust-enums-and-patter-match/</link><pubDate>Thu, 09 Jul 2020 00:00:00 +0000</pubDate><guid>https://holicc.github.io/post/rust/rust-enums-and-patter-match/</guid><description>Rust中的枚举 enum枚举类型，一种熟悉的数据结构，在Java中也有对应的类型，就不赘述了. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 fn main(){enum</description></item><item><title>Rust Struct</title><link>https://holicc.github.io/post/rust/rust-struct/</link><pubDate>Wed, 08 Jul 2020 00:00:00 +0000</pubDate><guid>https://holicc.github.io/post/rust/rust-struct/</guid><description>通过使用关键struct可以定义一个类，呸，是定义一个结构体。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 struct User{username: String,email: String,sign_in_count: u64,active: bool,}fn main(){letuser1=User{email: String::from(&amp;#34;someone@example.com&amp;#34;),username: String::from(&amp;#34;someusername123&amp;#34;),active: true,sign_in_count: 1,};} struct与Java中的类</description></item><item><title>Rust Reference And Borrowing</title><link>https://holicc.github.io/post/rust/rust-references-and-borrowing/</link><pubDate>Tue, 07 Jul 2020 00:00:00 +0000</pubDate><guid>https://holicc.github.io/post/rust/rust-references-and-borrowing/</guid><description>Rust中的引用(Reference)与借用(Borrowing) 在上一节的所有权系统的最后，官方抛出了一个问题，就是在函数使用的时候，如果</description></item><item><title>Rust Function</title><link>https://holicc.github.io/post/rust/rust-ownership/</link><pubDate>Mon, 06 Jul 2020 00:00:00 +0000</pubDate><guid>https://holicc.github.io/post/rust/rust-ownership/</guid><description>Rust中的所有权系统(Ownership) 目前大部分的编程语言管理内存都是使用的：1.自动管理(垃圾回收机制，像Java) 2.手动编码控制</description></item><item><title>Rust Data Types</title><link>https://holicc.github.io/post/rust/rust-data-types/</link><pubDate>Sun, 05 Jul 2020 00:00:00 +0000</pubDate><guid>https://holicc.github.io/post/rust/rust-data-types/</guid><description>Rust中的数据类型 Rust是一门静态类型的语言(跟Java一样)，每一个值都有其对应的数据类型(Every value in Rust is of a certain data type) Number Types Rust作</description></item><item><title>Rust Function</title><link>https://holicc.github.io/post/rust/rust-function/</link><pubDate>Sun, 05 Jul 2020 00:00:00 +0000</pubDate><guid>https://holicc.github.io/post/rust/rust-function/</guid><description>Rust中的函数 Rust是支持函数编程的，不像Java完全是使用面向对象的编程语言，虽然可以使用Function等，但是还是有些差距的。 Ru</description></item><item><title>Rust Variables</title><link>https://holicc.github.io/post/rust/rust-variable/</link><pubDate>Fri, 03 Jul 2020 00:00:00 +0000</pubDate><guid>https://holicc.github.io/post/rust/rust-variable/</guid><description>Rust中的变量与常量的定义 Rust中定义变量使用的关键字是 let 关键字，该关键字定义的变量是不可变的;想要定义一个可变的变量需要再使用一个关键</description></item><item><title>Install Rust On Win10</title><link>https://holicc.github.io/post/rust/install-rust-win10/</link><pubDate>Thu, 02 Jul 2020 00:00:00 +0000</pubDate><guid>https://holicc.github.io/post/rust/install-rust-win10/</guid><description>安装Rust 直接到Rust官方网站 找到适合自己系统的安装包exe文件下载进行安装就行了 官方提供win32位和64位的安装版本，不过一般都是6</description></item><item><title>MySQL 索引</title><link>https://holicc.github.io/post/network/about-mysql-index/</link><pubDate>Sun, 29 Mar 2020 00:00:00 +0000</pubDate><guid>https://holicc.github.io/post/network/about-mysql-index/</guid><description>索引是什么 索引（在MySQL中也称为“键（key）”），用于存储引擎快速找到记录的一种数据结构。这是索引的基础功能。 索引可以包含一个列或多个</description></item><item><title>About TCP Protocol</title><link>https://holicc.github.io/post/network/about-tcp-protocol/</link><pubDate>Sun, 22 Mar 2020 00:00:00 +0000</pubDate><guid>https://holicc.github.io/post/network/about-tcp-protocol/</guid><description>TCP是什么 ? 传输控制协议（TCP）是互联网协议组中重要的组成部分之一。TCP的实现之初是为了补充互联网协议（IP）。因此，这一对组合经常被</description></item><item><title>About</title><link>https://holicc.github.io/about/</link><pubDate>Wed, 01 Jan 2020 00:00:00 +0000</pubDate><guid>https://holicc.github.io/about/</guid><description>Java、Rust、Golang</description></item></channel></rss>