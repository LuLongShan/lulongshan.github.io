<!doctype html><html lang=en><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><title>Rust Smart Pointer - joe</title><meta name=renderer content="webkit"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta http-equiv=cache-control content="no-transform"><meta http-equiv=cache-control content="no-siteapp"><meta name=theme-color content="#f8f5ec"><meta name=msapplication-navbutton-color content="#f8f5ec"><meta name=apple-mobile-web-app-capable content="yes"><meta name=apple-mobile-web-app-status-bar-style content="#f8f5ec"><meta name=author content="Joe"><meta name=description content="Rust Smart Pointer (智能指针) 普通指针（Reference）: &amp;amp; 使用这个定义的，只是指向了对应的内存地址，并没有其他的功能； 智能指针（Smart Poin"><meta name=keywords content="Joe,blog,go,rust,java"><meta name=generator content="Hugo 0.84.1 with theme even"><link rel=canonical href=https://holicc.github.io/post/rust/rust-smart-pointer/><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/manifest.json><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><script data-ad-client=ca-pub-7877604046340220 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script><link href=/sass/main.min.d5f8d5189df9f67f1828dcc61b07c33fcd84dbb87a9d0036891d742acf5ef7ac.css rel=stylesheet><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin=anonymous><meta property="og:title" content="Rust Smart Pointer"><meta property="og:description" content="Rust Smart Pointer (智能指针) 普通指针（Reference）: & 使用这个定义的，只是指向了对应的内存地址，并没有其他的功能； 智能指针（Smart Poin"><meta property="og:type" content="article"><meta property="og:url" content="https://holicc.github.io/post/rust/rust-smart-pointer/"><meta property="article:section" content="post"><meta property="article:published_time" content="2020-08-04T00:00:00+00:00"><meta property="article:modified_time" content="2020-08-04T00:00:00+00:00"><meta itemprop=name content="Rust Smart Pointer"><meta itemprop=description content="Rust Smart Pointer (智能指针) 普通指针（Reference）: & 使用这个定义的，只是指向了对应的内存地址，并没有其他的功能； 智能指针（Smart Poin"><meta itemprop=datePublished content="2020-08-04T00:00:00+00:00"><meta itemprop=dateModified content="2020-08-04T00:00:00+00:00"><meta itemprop=wordCount content="2429"><meta itemprop=keywords content="programing,rust,"><meta name=twitter:card content="summary"><meta name=twitter:title content="Rust Smart Pointer"><meta name=twitter:description content="Rust Smart Pointer (智能指针) 普通指针（Reference）: & 使用这个定义的，只是指向了对应的内存地址，并没有其他的功能； 智能指针（Smart Poin"><!--[if lte IE 9]><script src=https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js></script><![endif]--><!--[if lt IE 9]><script src=https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js></script><script src=https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js></script><![endif]--></head><body><div id=mobile-navbar class=mobile-navbar><div class=mobile-header-logo><a href=/ class=logo>Joe</a></div><div class=mobile-navbar-icon><span></span><span></span><span></span></div></div><nav id=mobile-menu class="mobile-menu slideout-menu"><ul class=mobile-menu-list><a href=/><li class=mobile-menu-item>Home</li></a><a href=/post/><li class=mobile-menu-item>Archives</li></a><a href=/tags/><li class=mobile-menu-item>Tags</li></a><a href=/categories/><li class=mobile-menu-item>Categories</li></a></ul></nav><div class=container id=mobile-panel><header id=header class=header><div class=logo-wrapper><a href=/ class=logo>Joe</a></div><nav class=site-navbar><ul id=menu class=menu><li class=menu-item><a class=menu-item-link href=/>Home</a></li><li class=menu-item><a class=menu-item-link href=/post/>Archives</a></li><li class=menu-item><a class=menu-item-link href=/tags/>Tags</a></li><li class=menu-item><a class=menu-item-link href=/categories/>Categories</a></li></ul></nav></header><main id=main class=main><div class=content-wrapper><div id=content class=content><article class=post><header class=post-header><h1 class=post-title>Rust Smart Pointer</h1><div class=post-meta><span class=post-time>2020-08-04</span><div class=post-category><a href=/categories/programing/>programing</a></div><span class=more-meta>2429 words</span>
<span class=more-meta>5 mins read</span></div></header><div class=post-toc id=post-toc><h2 class=post-toc-title>Contents</h2><div class="post-toc-content always-active"></div></div><div class=post-content><h2 id=rust-smart-pointer-智能指针>Rust Smart Pointer (智能指针)</h2><p>普通指针（Reference）: <code>&</code> 使用这个定义的，只是指向了对应的内存地址，并没有其他的功能；</p><p>智能指针（Smart Pointer）就是能够拥有多个<em>owner</em>并且在没有<em>owner</em>时自动清理回收。（GC？！），并且提供了一些其他功能；</p><blockquote><p>This pointer enables you to have multiple owners of data by keeping track of the number of owners and, when no owners remain, cleaning up the data.</p></blockquote><p>Rust中普通的指针只是一个借用，然而智能指针是拥有</p><blockquote><p>In Rust, which uses the concept of ownership and borrowing, an additional difference between references and smart pointers is that references are pointers that only borrow data; in contrast, in many cases, smart pointers own the data they point to.</p></blockquote><p>指针指针是一种实现了<code>Deref</code>和<code>Drop</code>接口的结构体</p><p><code>box</code>是Rust中常用的智能指针，它会将存储的数据放在堆中而不是栈上。该指针也不会影响性能，只是没有额外的功能罢了。</p><ul><li>When you have a type whose size can’t be known at compile time and you want to use a value of that type in a context that requires an exact size</li><li>When you have a large amount of data and you want to transfer ownership but ensure the data won’t be copied when you do so</li><li>When you want to own a value and you care only that it’s a type that implements a particular trait rather than being of a specific type</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-rust data-lang=rust><span class=k>fn</span> <span class=nf>main</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>b</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>Box</span>::<span class=n>new</span><span class=p>(</span><span class=mi>5</span><span class=p>);</span><span class=w>
</span><span class=w>    </span><span class=n>println</span><span class=o>!</span><span class=p>(</span><span class=s>&#34;b = {}&#34;</span><span class=p>,</span><span class=w> </span><span class=n>b</span><span class=p>);</span><span class=w>
</span><span class=w></span><span class=p>}</span></code></pre></td></tr></table></div></div><p>使用<code>Deref</code>来控制解引用的过程</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-rust data-lang=rust><span class=k>use</span><span class=w> </span><span class=n>std</span>::<span class=n>ops</span>::<span class=n>Deref</span><span class=p>;</span><span class=w>
</span><span class=w>
</span><span class=w></span><span class=k>impl</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=w> </span><span class=n>Deref</span><span class=w> </span><span class=k>for</span><span class=w> </span><span class=n>MyBox</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=k>type</span> <span class=nc>Target</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>T</span><span class=p>;</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=k>fn</span> <span class=nf>deref</span><span class=p>(</span><span class=o>&amp;</span><span class=bp>self</span><span class=p>)</span><span class=w> </span>-&gt; <span class=kp>&amp;</span><span class=nc>T</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=o>&amp;</span><span class=bp>self</span><span class=p>.</span><span class=mi>0</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w></span><span class=k>struct</span> <span class=nc>MyBox</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=p>(</span><span class=n>T</span><span class=p>);</span><span class=w>
</span><span class=w>
</span><span class=w></span><span class=k>impl</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=w> </span><span class=n>MyBox</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=k>fn</span> <span class=nf>new</span><span class=p>(</span><span class=n>x</span>: <span class=nc>T</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>MyBox</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=n>MyBox</span><span class=p>(</span><span class=n>x</span><span class=p>)</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w></span><span class=k>fn</span> <span class=nf>main</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>5</span><span class=p>;</span><span class=w>
</span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>y</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>MyBox</span>::<span class=n>new</span><span class=p>(</span><span class=n>x</span><span class=p>);</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=n>assert_eq</span><span class=o>!</span><span class=p>(</span><span class=mi>5</span><span class=p>,</span><span class=w> </span><span class=n>x</span><span class=p>);</span><span class=w>
</span><span class=w>    </span><span class=n>assert_eq</span><span class=o>!</span><span class=p>(</span><span class=mi>5</span><span class=p>,</span><span class=w> </span><span class=o>*</span><span class=n>y</span><span class=p>);</span><span class=w>
</span><span class=w></span><span class=p>}</span></code></pre></td></tr></table></div></div><p>当一个变量的值将要离开作用域的时候，可以使用<code>Drop</code>特质来提前感知这一操作并做出相应的处理。例如：<em>Box<t></em>就是使用来<code>Drop</code>来释放它所持有的指针的。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-rust data-lang=rust><span class=k>struct</span> <span class=nc>CustomSmartPointer</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=n>data</span>: <span class=nb>String</span><span class=p>,</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w></span><span class=k>impl</span><span class=w> </span><span class=nb>Drop</span><span class=w> </span><span class=k>for</span><span class=w> </span><span class=n>CustomSmartPointer</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=k>fn</span> <span class=nf>drop</span><span class=p>(</span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=bp>self</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=n>println</span><span class=o>!</span><span class=p>(</span><span class=s>&#34;Dropping CustomSmartPointer with data `{}`!&#34;</span><span class=p>,</span><span class=w> </span><span class=bp>self</span><span class=p>.</span><span class=n>data</span><span class=p>);</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w></span><span class=k>fn</span> <span class=nf>main</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>c</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>CustomSmartPointer</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=n>data</span>: <span class=nb>String</span>::<span class=n>from</span><span class=p>(</span><span class=s>&#34;my stuff&#34;</span><span class=p>),</span><span class=w>
</span><span class=w>    </span><span class=p>};</span><span class=w>
</span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>d</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>CustomSmartPointer</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=n>data</span>: <span class=nb>String</span>::<span class=n>from</span><span class=p>(</span><span class=s>&#34;other stuff&#34;</span><span class=p>),</span><span class=w>
</span><span class=w>    </span><span class=p>};</span><span class=w>
</span><span class=w>    </span><span class=n>println</span><span class=o>!</span><span class=p>(</span><span class=s>&#34;CustomSmartPointers created.&#34;</span><span class=p>);</span><span class=w>
</span><span class=w></span><span class=p>}</span></code></pre></td></tr></table></div></div><p><code>Drop</code>特质相当与告诉编译器，在特定的地方自动插入代码使其调用<em>drop</em>方法，好让变量自动释放。</p><p>该特质的<em>drop</em>方法不支持手动调用，该方法必须由编译器来自动调用，如果手动调用该方法会编译不通过的 （<strong>explicit destructor calls not allowed</strong>）。</p><p>原因很简单，Rust并不会智能到见到到了手动调用<em>drop</em>就会不执行已经插入的自动<em>drop</em>方法，所以会造成<em>两次释放同一个变量</em></p><blockquote><p>Rust doesn’t let us call drop explicitly because Rust would still automatically call drop on the value at the end of main. This would be a double free error because Rust would be trying to clean up the same value twice.</p></blockquote><p>当然有些情况我们是想要提前释放资源，这种情况就需要使用标准库中<strong>std::mem::drop</strong>的<em>drop</em>函数</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-rust data-lang=rust><span class=k>struct</span> <span class=nc>CustomSmartPointer</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=n>data</span>: <span class=nb>String</span><span class=p>,</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w></span><span class=k>impl</span><span class=w> </span><span class=nb>Drop</span><span class=w> </span><span class=k>for</span><span class=w> </span><span class=n>CustomSmartPointer</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=k>fn</span> <span class=nf>drop</span><span class=p>(</span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=bp>self</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=n>println</span><span class=o>!</span><span class=p>(</span><span class=s>&#34;Dropping CustomSmartPointer with data `{}`!&#34;</span><span class=p>,</span><span class=w> </span><span class=bp>self</span><span class=p>.</span><span class=n>data</span><span class=p>);</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w></span><span class=k>fn</span> <span class=nf>main</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>c</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>CustomSmartPointer</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=n>data</span>: <span class=nb>String</span>::<span class=n>from</span><span class=p>(</span><span class=s>&#34;some data&#34;</span><span class=p>),</span><span class=w>
</span><span class=w>    </span><span class=p>};</span><span class=w>
</span><span class=w>    </span><span class=n>println</span><span class=o>!</span><span class=p>(</span><span class=s>&#34;CustomSmartPointer created.&#34;</span><span class=p>);</span><span class=w>
</span><span class=w>    </span><span class=n>drop</span><span class=p>(</span><span class=n>c</span><span class=p>);</span><span class=w>
</span><span class=w>    </span><span class=n>println</span><span class=o>!</span><span class=p>(</span><span class=s>&#34;CustomSmartPointer dropped before the end of main.&#34;</span><span class=p>);</span><span class=w>
</span><span class=w></span><span class=p>}</span></code></pre></td></tr></table></div></div><p><code>Rc&lt;T></code>（全称：<em>reference counting</em>）是一个可以让变量拥有多个<em>owner</em>的指针。</p><p>官方举了个例子，生动形象的理解<code>Rc&lt;T></code></p><blockquote><p>Imagine Rc<t> as a TV in a family room. When one person enters to watch TV, they turn it on. Others can come into the room and watch the TV. When the last person leaves the room, they turn off the TV because it’s no longer being used. If someone turns off the TV while others are still watching it, there would be uproar from the remaining TV watchers!</p></blockquote><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-rust data-lang=rust><span class=k>enum</span> <span class=nc>List</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=n>Cons</span><span class=p>(</span><span class=kt>i32</span><span class=p>,</span><span class=w> </span><span class=n>Rc</span><span class=o>&lt;</span><span class=n>List</span><span class=o>&gt;</span><span class=p>),</span><span class=w>
</span><span class=w>    </span><span class=n>Nil</span><span class=p>,</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w></span><span class=k>use</span><span class=w> </span><span class=k>crate</span>::<span class=n>List</span>::<span class=p>{</span><span class=n>Cons</span><span class=p>,</span><span class=w> </span><span class=n>Nil</span><span class=p>};</span><span class=w>
</span><span class=w></span><span class=k>use</span><span class=w> </span><span class=n>std</span>::<span class=n>rc</span>::<span class=n>Rc</span><span class=p>;</span><span class=w>
</span><span class=w>
</span><span class=w></span><span class=k>fn</span> <span class=nf>main</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Rc</span>::<span class=n>new</span><span class=p>(</span><span class=n>Cons</span><span class=p>(</span><span class=mi>5</span><span class=p>,</span><span class=w> </span><span class=n>Rc</span>::<span class=n>new</span><span class=p>(</span><span class=n>Cons</span><span class=p>(</span><span class=mi>10</span><span class=p>,</span><span class=w> </span><span class=n>Rc</span>::<span class=n>new</span><span class=p>(</span><span class=n>Nil</span><span class=p>)))));</span><span class=w>
</span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>b</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Cons</span><span class=p>(</span><span class=mi>3</span><span class=p>,</span><span class=w> </span><span class=n>Rc</span>::<span class=n>clone</span><span class=p>(</span><span class=o>&amp;</span><span class=n>a</span><span class=p>));</span><span class=w>
</span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>c</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Cons</span><span class=p>(</span><span class=mi>4</span><span class=p>,</span><span class=w> </span><span class=n>Rc</span>::<span class=n>clone</span><span class=p>(</span><span class=o>&amp;</span><span class=n>a</span><span class=p>));</span><span class=w>
</span><span class=w></span><span class=p>}</span></code></pre></td></tr></table></div></div><p><code>Rc::clone</code>使用的是浅拷贝，这里每次拷贝了之后会使<em>a</em>引用计数加一。也可以使用<code>a.clone()</code>，如何使用<code>clone</code>取决于使用场景。</p><blockquote><p>We could have called a.clone() rather than Rc::clone(&a), but Rust’s convention is to use Rc::clone in this case. The implementation of Rc::clone doesn’t make a deep copy of all the data like most types’ implementations of clone do. The call to Rc::clone only increments the reference count, which doesn’t take much time. Deep copies of data can take a lot of time. By using Rc::clone for reference counting, we can visually distinguish between the deep-copy kinds of clones and the kinds of clones that increase the reference count. When looking for performance problems in the code, we only need to consider the deep-copy clones and can disregard calls to Rc::clone.</p></blockquote><p>可以使用<code>Rc::strong_count(&a)</code>查看当前变量有多少个引用。</p><p><code>RefCell&lt;T></code> (不知名指针)用于打破Rust规则的指针。因为有时Rust编译器不能正确的分析出代码的<em>Ownership</em>就会拒绝编译，但是编写代码者能够保证这段代码是符合Rust规则的，所以这个时候就可以使用这个指针来使编译通过，并且在<strong>运行时</strong>来进行<em>Ownership</em>的检查工作，如果发现规则被打破，就会<em>panic</em>。</p><blockquote><p>The advantage of checking the borrowing rules at runtime instead is that certain memory-safe scenarios are then allowed, whereas they are disallowed by the compile-time checks. Static analysis, like the Rust compiler, is inherently conservative. Some properties of code are impossible to detect by analyzing the code: the most famous example is the Halting Problem, which is beyond the scope of this book but is an interesting topic to research.</p><p>Because some analysis is impossible, if the Rust compiler can’t be sure the code complies with the ownership rules, it might reject a correct program; in this way, it’s conservative. If Rust accepted an incorrect program, users wouldn’t be able to trust in the guarantees Rust makes. However, if Rust rejects a correct program, the programmer will be inconvenienced, but nothing catastrophic can occur. The RefCell<t> type is useful when you’re sure your code follows the borrowing rules but the compiler is unable to understand and guarantee that.</p></blockquote><p><code>Rc&lt;T>, RefCell&lt;T></code>这两个指针都只能在<strong>单线程</strong>的环境下使用。</p><p><code>Box&lt;T>, Rc&lt;T>, RefCell&lt;T></code>三者的区别</p><ul><li><code>Rc&lt;T></code>允许一个变量有多个拥有者，其他两个只能有一个。</li><li><code>Box&lt;T></code>支持<em>编译期的</em>可变的和不可变的借用检查；<code>Rc&lt;T></code>支持<em>编译期</em>的不可变的借用检查；<code>RefCell&lt;T></code>支持<em>运行时</em>的可变的和不可变的借用检查；</li><li><code>Refcell&lt;T></code>可以改变一个不可变的变量（Because RefCell<t> allows mutable borrows checked at runtime, you can mutate the value inside the RefCell<t> even when the RefCell<t> is immutable.）</li></ul><p>突变模式？！</p><blockquote><p>Mutating the value inside an immutable value is the interior mutability pattern.</p></blockquote><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-rust data-lang=rust><span class=cp>#[derive(Debug)]</span><span class=w>
</span><span class=w></span><span class=k>enum</span> <span class=nc>List</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=n>Cons</span><span class=p>(</span><span class=n>Rc</span><span class=o>&lt;</span><span class=n>RefCell</span><span class=o>&lt;</span><span class=kt>i32</span><span class=o>&gt;&gt;</span><span class=p>,</span><span class=w> </span><span class=n>Rc</span><span class=o>&lt;</span><span class=n>List</span><span class=o>&gt;</span><span class=p>),</span><span class=w>
</span><span class=w>    </span><span class=n>Nil</span><span class=p>,</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w></span><span class=k>use</span><span class=w> </span><span class=k>crate</span>::<span class=n>List</span>::<span class=p>{</span><span class=n>Cons</span><span class=p>,</span><span class=w> </span><span class=n>Nil</span><span class=p>};</span><span class=w>
</span><span class=w></span><span class=k>use</span><span class=w> </span><span class=n>std</span>::<span class=n>cell</span>::<span class=n>RefCell</span><span class=p>;</span><span class=w>
</span><span class=w></span><span class=k>use</span><span class=w> </span><span class=n>std</span>::<span class=n>rc</span>::<span class=n>Rc</span><span class=p>;</span><span class=w>
</span><span class=w>
</span><span class=w></span><span class=k>fn</span> <span class=nf>main</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>value</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Rc</span>::<span class=n>new</span><span class=p>(</span><span class=n>RefCell</span>::<span class=n>new</span><span class=p>(</span><span class=mi>5</span><span class=p>));</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Rc</span>::<span class=n>new</span><span class=p>(</span><span class=n>Cons</span><span class=p>(</span><span class=n>Rc</span>::<span class=n>clone</span><span class=p>(</span><span class=o>&amp;</span><span class=n>value</span><span class=p>),</span><span class=w> </span><span class=n>Rc</span>::<span class=n>new</span><span class=p>(</span><span class=n>Nil</span><span class=p>)));</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>b</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Cons</span><span class=p>(</span><span class=n>Rc</span>::<span class=n>new</span><span class=p>(</span><span class=n>RefCell</span>::<span class=n>new</span><span class=p>(</span><span class=mi>6</span><span class=p>)),</span><span class=w> </span><span class=n>Rc</span>::<span class=n>clone</span><span class=p>(</span><span class=o>&amp;</span><span class=n>a</span><span class=p>));</span><span class=w>
</span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>c</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Cons</span><span class=p>(</span><span class=n>Rc</span>::<span class=n>new</span><span class=p>(</span><span class=n>RefCell</span>::<span class=n>new</span><span class=p>(</span><span class=mi>10</span><span class=p>)),</span><span class=w> </span><span class=n>Rc</span>::<span class=n>clone</span><span class=p>(</span><span class=o>&amp;</span><span class=n>a</span><span class=p>));</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=o>*</span><span class=n>value</span><span class=p>.</span><span class=n>borrow_mut</span><span class=p>()</span><span class=w> </span><span class=o>+=</span><span class=w> </span><span class=mi>10</span><span class=p>;</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=n>println</span><span class=o>!</span><span class=p>(</span><span class=s>&#34;a after = {:?}&#34;</span><span class=p>,</span><span class=w> </span><span class=n>a</span><span class=p>);</span><span class=w>
</span><span class=w>    </span><span class=n>println</span><span class=o>!</span><span class=p>(</span><span class=s>&#34;b after = {:?}&#34;</span><span class=p>,</span><span class=w> </span><span class=n>b</span><span class=p>);</span><span class=w>
</span><span class=w>    </span><span class=n>println</span><span class=o>!</span><span class=p>(</span><span class=s>&#34;c after = {:?}&#34;</span><span class=p>,</span><span class=w> </span><span class=n>c</span><span class=p>);</span><span class=w>
</span><span class=w></span><span class=p>}</span></code></pre></td></tr></table></div></div><p>循环依赖可能会造成内存泄漏的问题，因为使用了<code>Rc&lt;T></code>如果相互依赖那么引用数就永远不会为0。（Java中的GC也有这个问题，用可达性分析解决的）</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-rust data-lang=rust><span class=k>use</span><span class=w> </span><span class=k>crate</span>::<span class=n>List</span>::<span class=p>{</span><span class=n>Cons</span><span class=p>,</span><span class=w> </span><span class=n>Nil</span><span class=p>};</span><span class=w>
</span><span class=w></span><span class=k>use</span><span class=w> </span><span class=n>std</span>::<span class=n>cell</span>::<span class=n>RefCell</span><span class=p>;</span><span class=w>
</span><span class=w></span><span class=k>use</span><span class=w> </span><span class=n>std</span>::<span class=n>rc</span>::<span class=n>Rc</span><span class=p>;</span><span class=w>
</span><span class=w>
</span><span class=w></span><span class=cp>#[derive(Debug)]</span><span class=w>
</span><span class=w></span><span class=k>enum</span> <span class=nc>List</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=n>Cons</span><span class=p>(</span><span class=kt>i32</span><span class=p>,</span><span class=w> </span><span class=n>RefCell</span><span class=o>&lt;</span><span class=n>Rc</span><span class=o>&lt;</span><span class=n>List</span><span class=o>&gt;&gt;</span><span class=p>),</span><span class=w>
</span><span class=w>    </span><span class=n>Nil</span><span class=p>,</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w></span><span class=k>impl</span><span class=w> </span><span class=n>List</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=k>fn</span> <span class=nf>tail</span><span class=p>(</span><span class=o>&amp;</span><span class=bp>self</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nb>Option</span><span class=o>&lt;&amp;</span><span class=n>RefCell</span><span class=o>&lt;</span><span class=n>Rc</span><span class=o>&lt;</span><span class=n>List</span><span class=o>&gt;&gt;&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=k>match</span><span class=w> </span><span class=bp>self</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>            </span><span class=n>Cons</span><span class=p>(</span><span class=n>_</span><span class=p>,</span><span class=w> </span><span class=n>item</span><span class=p>)</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=nb>Some</span><span class=p>(</span><span class=n>item</span><span class=p>),</span><span class=w>
</span><span class=w>            </span><span class=n>Nil</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=nb>None</span><span class=p>,</span><span class=w>
</span><span class=w>        </span><span class=p>}</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w></span><span class=k>fn</span> <span class=nf>main</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Rc</span>::<span class=n>new</span><span class=p>(</span><span class=n>Cons</span><span class=p>(</span><span class=mi>5</span><span class=p>,</span><span class=w> </span><span class=n>RefCell</span>::<span class=n>new</span><span class=p>(</span><span class=n>Rc</span>::<span class=n>new</span><span class=p>(</span><span class=n>Nil</span><span class=p>))));</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=n>println</span><span class=o>!</span><span class=p>(</span><span class=s>&#34;a initial rc count = {}&#34;</span><span class=p>,</span><span class=w> </span><span class=n>Rc</span>::<span class=n>strong_count</span><span class=p>(</span><span class=o>&amp;</span><span class=n>a</span><span class=p>));</span><span class=w>
</span><span class=w>    </span><span class=n>println</span><span class=o>!</span><span class=p>(</span><span class=s>&#34;a next item = {:?}&#34;</span><span class=p>,</span><span class=w> </span><span class=n>a</span><span class=p>.</span><span class=n>tail</span><span class=p>());</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>b</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Rc</span>::<span class=n>new</span><span class=p>(</span><span class=n>Cons</span><span class=p>(</span><span class=mi>10</span><span class=p>,</span><span class=w> </span><span class=n>RefCell</span>::<span class=n>new</span><span class=p>(</span><span class=n>Rc</span>::<span class=n>clone</span><span class=p>(</span><span class=o>&amp;</span><span class=n>a</span><span class=p>))));</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=n>println</span><span class=o>!</span><span class=p>(</span><span class=s>&#34;a rc count after b creation = {}&#34;</span><span class=p>,</span><span class=w> </span><span class=n>Rc</span>::<span class=n>strong_count</span><span class=p>(</span><span class=o>&amp;</span><span class=n>a</span><span class=p>));</span><span class=w>
</span><span class=w>    </span><span class=n>println</span><span class=o>!</span><span class=p>(</span><span class=s>&#34;b initial rc count = {}&#34;</span><span class=p>,</span><span class=w> </span><span class=n>Rc</span>::<span class=n>strong_count</span><span class=p>(</span><span class=o>&amp;</span><span class=n>b</span><span class=p>));</span><span class=w>
</span><span class=w>    </span><span class=n>println</span><span class=o>!</span><span class=p>(</span><span class=s>&#34;b next item = {:?}&#34;</span><span class=p>,</span><span class=w> </span><span class=n>b</span><span class=p>.</span><span class=n>tail</span><span class=p>());</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=k>if</span><span class=w> </span><span class=kd>let</span><span class=w> </span><span class=nb>Some</span><span class=p>(</span><span class=n>link</span><span class=p>)</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>a</span><span class=p>.</span><span class=n>tail</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=o>*</span><span class=n>link</span><span class=p>.</span><span class=n>borrow_mut</span><span class=p>()</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Rc</span>::<span class=n>clone</span><span class=p>(</span><span class=o>&amp;</span><span class=n>b</span><span class=p>);</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=n>println</span><span class=o>!</span><span class=p>(</span><span class=s>&#34;b rc count after changing a = {}&#34;</span><span class=p>,</span><span class=w> </span><span class=n>Rc</span>::<span class=n>strong_count</span><span class=p>(</span><span class=o>&amp;</span><span class=n>b</span><span class=p>));</span><span class=w>
</span><span class=w>    </span><span class=n>println</span><span class=o>!</span><span class=p>(</span><span class=s>&#34;a rc count after changing a = {}&#34;</span><span class=p>,</span><span class=w> </span><span class=n>Rc</span>::<span class=n>strong_count</span><span class=p>(</span><span class=o>&amp;</span><span class=n>a</span><span class=p>));</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=c1>// Uncomment the next line to see that we have a cycle;
</span><span class=c1></span><span class=w>    </span><span class=c1>// it will overflow the stack
</span><span class=c1></span><span class=w>    </span><span class=c1>// println!(&#34;a next item = {:?}&#34;, a.tail());
</span><span class=c1></span><span class=p>}</span></code></pre></td></tr></table></div></div><p>Rust无法处理循环依赖导致的内存泄露问题，因为这都是写代码自己的写的问题，换成其他语言也会出现这样的问题。</p><p>但Rust也不是任人自生自灭，如何防止循环引用的形成，Rust中引入了<em>弱引用</em>的概念（Java中的<em>虚引用</em>），使用<code>Rc&lt;T></code>中的<code>Rc::downgrade</code>会增加<code>weak_count</code>的数量，然而回收的时候不管<em>week_count</em>是否是0都会回收释放资源，只要<code>strong_count</code>为0时。</p><p>为了能够从新获取<em>弱引用</em>，可以使用<code>upgrade</code>方法对其进行升级，返回的是一个<code>Option&lt;Rc&lt;T>></code></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-rust data-lang=rust><span class=k>use</span><span class=w> </span><span class=n>std</span>::<span class=n>cell</span>::<span class=n>RefCell</span><span class=p>;</span><span class=w>
</span><span class=w></span><span class=k>use</span><span class=w> </span><span class=n>std</span>::<span class=n>rc</span>::<span class=p>{</span><span class=n>Rc</span><span class=p>,</span><span class=w> </span><span class=n>Weak</span><span class=p>};</span><span class=w>
</span><span class=w>
</span><span class=w></span><span class=cp>#[derive(Debug)]</span><span class=w>
</span><span class=w></span><span class=k>struct</span> <span class=nc>Node</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=n>value</span>: <span class=kt>i32</span><span class=p>,</span><span class=w>
</span><span class=w>    </span><span class=n>parent</span>: <span class=nc>RefCell</span><span class=o>&lt;</span><span class=n>Weak</span><span class=o>&lt;</span><span class=n>Node</span><span class=o>&gt;&gt;</span><span class=p>,</span><span class=w>
</span><span class=w>    </span><span class=n>children</span>: <span class=nc>RefCell</span><span class=o>&lt;</span><span class=nb>Vec</span><span class=o>&lt;</span><span class=n>Rc</span><span class=o>&lt;</span><span class=n>Node</span><span class=o>&gt;&gt;&gt;</span><span class=p>,</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w></span><span class=k>fn</span> <span class=nf>main</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>leaf</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Rc</span>::<span class=n>new</span><span class=p>(</span><span class=n>Node</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=n>value</span>: <span class=mi>3</span><span class=p>,</span><span class=w>
</span><span class=w>        </span><span class=n>parent</span>: <span class=nc>RefCell</span>::<span class=n>new</span><span class=p>(</span><span class=n>Weak</span>::<span class=n>new</span><span class=p>()),</span><span class=w>
</span><span class=w>        </span><span class=n>children</span>: <span class=nc>RefCell</span>::<span class=n>new</span><span class=p>(</span><span class=n>vec</span><span class=o>!</span><span class=p>[]),</span><span class=w>
</span><span class=w>    </span><span class=p>});</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=n>println</span><span class=o>!</span><span class=p>(</span><span class=s>&#34;leaf parent = {:?}&#34;</span><span class=p>,</span><span class=w> </span><span class=n>leaf</span><span class=p>.</span><span class=n>parent</span><span class=p>.</span><span class=n>borrow</span><span class=p>().</span><span class=n>upgrade</span><span class=p>());</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>branch</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Rc</span>::<span class=n>new</span><span class=p>(</span><span class=n>Node</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=n>value</span>: <span class=mi>5</span><span class=p>,</span><span class=w>
</span><span class=w>        </span><span class=n>parent</span>: <span class=nc>RefCell</span>::<span class=n>new</span><span class=p>(</span><span class=n>Weak</span>::<span class=n>new</span><span class=p>()),</span><span class=w>
</span><span class=w>        </span><span class=n>children</span>: <span class=nc>RefCell</span>::<span class=n>new</span><span class=p>(</span><span class=n>vec</span><span class=o>!</span><span class=p>[</span><span class=n>Rc</span>::<span class=n>clone</span><span class=p>(</span><span class=o>&amp;</span><span class=n>leaf</span><span class=p>)]),</span><span class=w>
</span><span class=w>    </span><span class=p>});</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=o>*</span><span class=n>leaf</span><span class=p>.</span><span class=n>parent</span><span class=p>.</span><span class=n>borrow_mut</span><span class=p>()</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Rc</span>::<span class=n>downgrade</span><span class=p>(</span><span class=o>&amp;</span><span class=n>branch</span><span class=p>);</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=n>println</span><span class=o>!</span><span class=p>(</span><span class=s>&#34;leaf parent = {:?}&#34;</span><span class=p>,</span><span class=w> </span><span class=n>leaf</span><span class=p>.</span><span class=n>parent</span><span class=p>.</span><span class=n>borrow</span><span class=p>().</span><span class=n>upgrade</span><span class=p>());</span><span class=w>
</span><span class=w></span><span class=p>}</span></code></pre></td></tr></table></div></div><p>智能指针，有点复杂...</p><p>完！</p></div><div class=post-copyright><p class=copyright-item><span class=item-title>Author</span>
<span class=item-content>Joe</span></p><p class=copyright-item><span class=item-title>LastMod</span>
<span class=item-content>2020-08-04</span></p></div><footer class=post-footer><div class=post-tags><a href=/tags/programing/>programing</a>
<a href=/tags/rust/>rust</a></div><nav class=post-nav><a class=prev href=/post/shell/powershell-notes/><i class="iconfont icon-left"></i>
<span class="prev-text nav-default">Powershell Notes</span>
<span class="prev-text nav-mobile">Prev</span></a>
<a class=next href=/post/rust/rust-testing/><span class="next-text nav-default">Rust Testing</span>
<span class="next-text nav-mobile">Next</span>
<i class="iconfont icon-right"></i></a></nav></footer></article></div></div></main><footer id=footer class=footer><div class=social-links><a href=mailto:longshanluu@gmail.com class="iconfont icon-email" title=email></a><a href=https://github.com/holicc/holicc class="iconfont icon-github" title=github></a><a href=https://holicc.github.io/index.xml type=application/rss+xml class="iconfont icon-rss" title=rss></a></div><div class=copyright><span class=power-by>Powered by <a class=hexo-link href=https://gohugo.io>Hugo</a></span>
<span class=division>|</span>
<span class=theme-info>Theme -
<a class=theme-link href=https://github.com/olOwOlo/hugo-theme-even>Even</a></span>
<span class=copyright-year>&copy;
2017 -
2021<span class=heart><i class="iconfont icon-heart"></i></span><span>Joe</span></span></div></footer><div class=back-to-top id=back-to-top><i class="iconfont icon-up"></i></div></div><script src=https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin=anonymous></script><script src=https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin=anonymous></script><script src=https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin=anonymous></script><script type=text/javascript src=/js/main.min.c99b103c33d1539acf3025e1913697534542c4a5aa5af0ccc20475ed2863603b.js></script><script type=application/javascript>var doNotTrack=!1;doNotTrack||(window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga('create','UA-157580785-1','auto'),ga('set','anonymizeIp',!0),ga('send','pageview'))</script><script async src=https://www.google-analytics.com/analytics.js></script></body></html>