<!doctype html><html lang=en><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><title>Rust Function - Even - A super concise theme for Hugo</title><meta name=renderer content="webkit"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta http-equiv=cache-control content="no-transform"><meta http-equiv=cache-control content="no-siteapp"><meta name=theme-color content="#f8f5ec"><meta name=msapplication-navbutton-color content="#f8f5ec"><meta name=apple-mobile-web-app-capable content="yes"><meta name=apple-mobile-web-app-status-bar-style content="#f8f5ec"><meta name=author content="Joe"><meta name=description content="Rust中的所有权系统(Ownership) 目前大部分的编程语言管理内存都是使用的：1.自动管理(垃圾回收机制，像Java) 2.手动编码控制"><meta name=keywords content="Joe,blog,go,rust,java"><meta name=generator content="Hugo 0.79.1 with theme even"><link rel=canonical href=https://holicc.github.io/post/rust/rust-ownership/><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/manifest.json><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link href=/sass/main.min.b5a744db6de49a86cadafb3b70f555ab443f83c307a483402259e94726b045ff.css rel=stylesheet><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin=anonymous><meta property="og:title" content="Rust Function"><meta property="og:description" content="Rust中的所有权系统(Ownership) 目前大部分的编程语言管理内存都是使用的：1.自动管理(垃圾回收机制，像Java) 2.手动编码控制"><meta property="og:type" content="article"><meta property="og:url" content="https://holicc.github.io/post/rust/rust-ownership/"><meta property="article:published_time" content="2020-07-06T00:00:00+00:00"><meta property="article:modified_time" content="2020-07-06T00:00:00+00:00"><meta itemprop=name content="Rust Function"><meta itemprop=description content="Rust中的所有权系统(Ownership) 目前大部分的编程语言管理内存都是使用的：1.自动管理(垃圾回收机制，像Java) 2.手动编码控制"><meta itemprop=datePublished content="2020-07-06T00:00:00+00:00"><meta itemprop=dateModified content="2020-07-06T00:00:00+00:00"><meta itemprop=wordCount content="2335"><meta itemprop=keywords content="programing,rust,"><meta name=twitter:card content="summary"><meta name=twitter:title content="Rust Function"><meta name=twitter:description content="Rust中的所有权系统(Ownership) 目前大部分的编程语言管理内存都是使用的：1.自动管理(垃圾回收机制，像Java) 2.手动编码控制"><!--[if lte IE 9]><script src=https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js></script><![endif]--><!--[if lt IE 9]><script src=https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js></script><script src=https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js></script><![endif]--></head><body><div id=mobile-navbar class=mobile-navbar><div class=mobile-header-logo><a href=/ class=logo>Joe</a></div><div class=mobile-navbar-icon><span></span><span></span><span></span></div></div><nav id=mobile-menu class="mobile-menu slideout-menu"><ul class=mobile-menu-list><a href=/><li class=mobile-menu-item>Home</li></a><a href=/post/><li class=mobile-menu-item>Archives</li></a><a href=/tags/><li class=mobile-menu-item>Tags</li></a><a href=/categories/><li class=mobile-menu-item>Categories</li></a></ul></nav><div class=container id=mobile-panel><header id=header class=header><div class=logo-wrapper><a href=/ class=logo>Joe</a></div><nav class=site-navbar><ul id=menu class=menu><li class=menu-item><a class=menu-item-link href=/>Home</a></li><li class=menu-item><a class=menu-item-link href=/post/>Archives</a></li><li class=menu-item><a class=menu-item-link href=/tags/>Tags</a></li><li class=menu-item><a class=menu-item-link href=/categories/>Categories</a></li></ul></nav></header><main id=main class=main><div class=content-wrapper><div id=content class=content><article class=post><header class=post-header><h1 class=post-title>Rust Function</h1><div class=post-meta><span class=post-time>2020-07-06</span><div class=post-category><a href=/categories/programing/>programing</a></div><span class=more-meta>2335 words</span>
<span class=more-meta>5 mins read</span></div></header><div class=post-toc id=post-toc><h2 class=post-toc-title>Contents</h2><div class="post-toc-content always-active"></div></div><div class=post-content><h3 id=rust中的所有权系统ownership>Rust中的所有权系统(Ownership)</h3><p>目前大部分的编程语言管理内存都是使用的：1.自动管理(垃圾回收机制，像Java) 2.手动编码控制内存的分配(像C或C++)
然而Rust不一样，另辟蹊径，靠的是编译器来保证内存的分配和回收。也叫做<code>Ownership</code>,这一概念是在Rust中独有的，是Rust独有的特性之一。如何看待这一特性，就是仁者见仁智者见智了，对于一个Java程序员来说，这一特性彷佛没有那么好，反而有点让人接受不了(可能是因为Rust是一门系统级别的编程语言，比较注重性能和安全性)</p><blockquote><p>memory is managed through a system of ownership with a set of rules that the compiler checks at compile time. None of the ownership features slow down your program while it’s running.</p></blockquote><p>要明白所有权系统，要先对<strong>堆栈</strong>有基本的认识。</p><blockquote><p>All data stored on the stack must have a known, fixed size. Data with an unknown size at compile time or a size that might change must be stored on the heap instead</p></blockquote><p>编译期间能够知道大小的变量是分配到栈上，无法确定大小的就是分配到堆上。（也不是绝对的）</p><p>这个点不知道，记录一下</p><blockquote><p>When your code calls a function, the values passed into the function (including, potentially, pointers to data on the heap) and the function’s local variables get pushed onto the stack. When the function is over, those values get popped off the stack.</p></blockquote><p>函数中的局部变量是分配在栈上的，每当函数调用完成，变量也已经被弹出栈顶了。</p><p>官方文档也总结的很到位</p><blockquote><p>Keeping track of what parts of code are using what data on the heap, minimizing the amount of duplicate data on the heap, and cleaning up unused data on the heap so you don’t run out of space are all problems that ownership addresses. Once you understand ownership, you won’t need to think about the stack and the heap very often, but knowing that managing heap data is why ownership exists can help explain why it works the way it does.</p></blockquote><p>所有权系统主要是为了帮助你更好的管理变量在堆栈上的分配。系统级别的编程语言比较在变量是分配到堆还是栈上，对于使用Java的我来说，对与这个概念是相当模糊的，只是大概知道Java中的对象大部分都是分配到堆上的，而且GC也是针对堆上的对象进行的回收。
为此顺便学习一下Java方面的知识吧。</p><p>JVM规范让每个Java线程拥有自己的独立的JVM栈，也就是Java方法的调用栈。</p><p>JVM里的“堆”（heap）特指用于存放Java对象的内存区域。所以根据这个定义，Java对象全部都在堆上</p><p>要注意，这个“堆”并不是数据结构意义上的堆（Heap (data structure)，一种有序的树），而是动态内存分配意义上的堆——用于管理动态生命周期的内存区域。</p><p>JVM的堆被同一个JVM实例中的所有Java线程共享。它通常由某种自动内存管理机制所管理，这种机制通常叫做“垃圾回收”（garbage collection，GC）。JVM规范并不强制要求JVM实现采用哪种GC算法。</p><p>好了，回到Rust中的所有权系统。</p><p>所有权系统需要熟知一下三条规则：</p><ul><li>Each value in Rust has a variable that’s called its owner(每一变量都有其拥有者//不知道这样翻译对不对 - -).</li><li>There can only be one owner at a time.(同一时刻一个变量只能有一个拥有者)</li><li>When the owner goes out of scope, the value will be dropped.(当拥有者不在作用域中了，那么这个值就会被释放掉)</li></ul><p>规则比我想象的要简单明了许多，看上去很简洁，实际上却饱含了很多信息量。。。</p><p>其中提到了<em>scope</em>(作用域)这个概念，有点类似于Spring中的scope的样子或者http中的session作用域和request作用域。</p><p>官方给的例子还是很容易理解的</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-rust data-lang=rust><span class=k>fn</span> <span class=nf>main</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=p>{</span><span class=w>                      </span><span class=c1>// s is not valid here, it’s not yet declared
</span><span class=c1></span><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=n>s</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s>&#34;hello&#34;</span><span class=p>;</span><span class=w>   </span><span class=c1>// s is valid from this point forward
</span><span class=c1></span><span class=w>
</span><span class=w>        </span><span class=c1>// do stuff with s
</span><span class=c1></span><span class=w>    </span><span class=p>}</span><span class=w>                      </span><span class=c1>// this scope is now over, and s is no longer valid
</span><span class=c1></span><span class=p>}</span><span class=w>
</span></code></pre></td></tr></table></div></div><p>有一点特殊的是<code>String</code>和<code>literal</code></p><p>在IDEA的提示下发现这是两种不同的类型，然儿在Java中都是统一的<strong>String</strong></p><p><figure><img src=str.png alt=str-in-rust></figure></p><p>原因是因为<code>literal</code>是固定长度的不可变的，分配在栈上的数据结构。而<code>String</code>是跟Java中的String类型一样是可变的。</p><p>同为String类型但是有点不同的是。</p><p>Java中的String可以这样写</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-java data-lang=java><span class=kd>class</span> <span class=nc>Scratch</span> <span class=o>{</span>
    <span class=kd>public</span> <span class=kd>static</span> <span class=kt>void</span> <span class=nf>main</span><span class=o>(</span><span class=n>String</span><span class=o>[]</span> <span class=n>args</span><span class=o>)</span> <span class=o>{</span>
        <span class=n>String</span> <span class=n>a</span> <span class=o>=</span> <span class=s>&#34;a&#34;</span><span class=o>;</span>
        <span class=n>String</span> <span class=n>b</span> <span class=o>=</span> <span class=n>a</span><span class=o>;</span>
        <span class=n>a</span> <span class=o>+=</span> <span class=s>&#34;zxc&#34;</span><span class=o>;</span>
        <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=n>a</span> <span class=o>+</span> <span class=s>&#34; &#34;</span> <span class=o>+</span> <span class=n>b</span><span class=o>);</span>
    <span class=o>}</span>
<span class=o>}</span></code></pre></td></tr></table></div></div><p>然而在Rust中这却不能这样</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-rust data-lang=rust><span class=k>fn</span> <span class=nf>main</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>s1</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>String</span>::<span class=n>from</span><span class=p>(</span><span class=s>&#34;hello&#34;</span><span class=p>);</span><span class=w>
</span><span class=w>    </span><span class=c1>// let s2 = s1; 编译不通过
</span><span class=c1></span><span class=w>
</span><span class=w>    </span><span class=n>println</span><span class=o>!</span><span class=p>(</span><span class=s>&#34;{}, world!&#34;</span><span class=p>,</span><span class=w> </span><span class=n>s1</span><span class=p>);</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></td></tr></table></div></div><p>原因是因为Rust中是<code>s2</code>并没有对<code>s1</code>进行值拷贝，传递的是<code>s1</code>的指针。根据官方的解释，这里涉及到了 <strong>浅拷贝</strong>和<strong>深拷贝</strong></p><blockquote><p>If you’ve heard the terms shallow copy and deep copy while working with other languages, the concept of copying the pointer, length, and capacity without copying the data probably sounds like making a shallow copy. But because Rust also invalidates the first variable, instead of being called a shallow copy, it’s known as a move. In this example, we would say that s1 was moved into s2.</p></blockquote><p>Rust并没有隐式的进行<strong>浅拷贝</strong>操作。而是让<code>s1</code>失效，这样的操作叫做 <code>moved</code>,相当于把<code>s1</code>上的值的指针移动到了<code>s2</code>上这样 <code>s1</code>就失效了。
为什么要这样做可能是为了能够更好的追踪内存并回收吧。</p><p>如果要使用<code>深拷贝</code>,就要使用<code>clone</code>方法。该方法会对堆和栈上的所有内容进行拷贝。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-rust data-lang=rust><span class=k>fn</span> <span class=nf>main</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>s1</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>String</span>::<span class=n>from</span><span class=p>(</span><span class=s>&#34;hello&#34;</span><span class=p>);</span><span class=w>
</span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>s2</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>s1</span><span class=p>.</span><span class=n>clone</span><span class=p>();</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=n>println</span><span class=o>!</span><span class=p>(</span><span class=s>&#34;s1 = {}, s2 = {}&#34;</span><span class=p>,</span><span class=w> </span><span class=n>s1</span><span class=p>,</span><span class=w> </span><span class=n>s2</span><span class=p>);</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></td></tr></table></div></div><p>在有些地方，跟Java类似，对于基本的数据类型，都不需要使用显示的使用<code>clone</code>方法</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-rust data-lang=rust><span class=k>fn</span> <span class=nf>main</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>5</span><span class=p>;</span><span class=w>
</span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>y</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>x</span><span class=p>;</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=n>println</span><span class=o>!</span><span class=p>(</span><span class=s>&#34;x = {}, y = {}&#34;</span><span class=p>,</span><span class=w> </span><span class=n>x</span><span class=p>,</span><span class=w> </span><span class=n>y</span><span class=p>);</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></td></tr></table></div></div><p>在Rust中所有都遵循所有权系统的规则</p><p>在函数中，传递进去的参数也是所有权移交的一种方式</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-rust data-lang=rust><span class=k>fn</span> <span class=nf>main</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>s</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>String</span>::<span class=n>from</span><span class=p>(</span><span class=s>&#34;hello&#34;</span><span class=p>);</span><span class=w>  </span><span class=c1>// s comes into scope
</span><span class=c1></span><span class=w>
</span><span class=w>    </span><span class=n>takes_ownership</span><span class=p>(</span><span class=n>s</span><span class=p>);</span><span class=w>             </span><span class=c1>// s&#39;s value moves into the function...
</span><span class=c1></span><span class=w>                                    </span><span class=c1>// ... and so is no longer valid here
</span><span class=c1></span><span class=w>
</span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>5</span><span class=p>;</span><span class=w>                      </span><span class=c1>// x comes into scope
</span><span class=c1></span><span class=w>
</span><span class=w>    </span><span class=n>makes_copy</span><span class=p>(</span><span class=n>x</span><span class=p>);</span><span class=w>                  </span><span class=c1>// x would move into the function,
</span><span class=c1></span><span class=w>                                    </span><span class=c1>// but i32 is Copy, so it’s okay to still
</span><span class=c1></span><span class=w>                                    </span><span class=c1>// use x afterward
</span><span class=c1></span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w> </span><span class=c1>// Here, x goes out of scope, then s. But because s&#39;s value was moved, nothing
</span><span class=c1></span><span class=w>  </span><span class=c1>// special happens.
</span><span class=c1></span><span class=w>
</span><span class=w></span><span class=k>fn</span> <span class=nf>takes_ownership</span><span class=p>(</span><span class=n>some_string</span>: <span class=nb>String</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=c1>// some_string comes into scope
</span><span class=c1></span><span class=w>    </span><span class=n>println</span><span class=o>!</span><span class=p>(</span><span class=s>&#34;{}&#34;</span><span class=p>,</span><span class=w> </span><span class=n>some_string</span><span class=p>);</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w> </span><span class=c1>// Here, some_string goes out of scope and `drop` is called. The backing
</span><span class=c1></span><span class=w>  </span><span class=c1>// memory is freed.
</span><span class=c1></span><span class=w>
</span><span class=w></span><span class=k>fn</span> <span class=nf>makes_copy</span><span class=p>(</span><span class=n>some_integer</span>: <span class=kt>i32</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=c1>// some_integer comes into scope
</span><span class=c1></span><span class=w>    </span><span class=n>println</span><span class=o>!</span><span class=p>(</span><span class=s>&#34;{}&#34;</span><span class=p>,</span><span class=w> </span><span class=n>some_integer</span><span class=p>);</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w> </span><span class=c1>// Here, some_integer goes out of scope. Nothing special happens.
</span></code></pre></td></tr></table></div></div><p>返回值中就更好理解了</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-rust data-lang=rust><span class=k>fn</span> <span class=nf>main</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>s1</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>gives_ownership</span><span class=p>();</span><span class=w>         </span><span class=c1>// gives_ownership moves its return
</span><span class=c1></span><span class=w>                                        </span><span class=c1>// value into s1
</span><span class=c1></span><span class=w>
</span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>s2</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>String</span>::<span class=n>from</span><span class=p>(</span><span class=s>&#34;hello&#34;</span><span class=p>);</span><span class=w>     </span><span class=c1>// s2 comes into scope
</span><span class=c1></span><span class=w>
</span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>s3</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>takes_and_gives_back</span><span class=p>(</span><span class=n>s2</span><span class=p>);</span><span class=w>  </span><span class=c1>// s2 is moved into
</span><span class=c1></span><span class=w>                                        </span><span class=c1>// takes_and_gives_back, which also
</span><span class=c1></span><span class=w>                                        </span><span class=c1>// moves its return value into s3
</span><span class=c1></span><span class=p>}</span><span class=w> </span><span class=c1>// Here, s3 goes out of scope and is dropped. s2 goes out of scope but was
</span><span class=c1></span><span class=w>  </span><span class=c1>// moved, so nothing happens. s1 goes out of scope and is dropped.
</span><span class=c1></span><span class=w>
</span><span class=w></span><span class=k>fn</span> <span class=nf>gives_ownership</span><span class=p>()</span><span class=w> </span>-&gt; <span class=nb>String</span> <span class=p>{</span><span class=w>             </span><span class=c1>// gives_ownership will move its
</span><span class=c1></span><span class=w>                                             </span><span class=c1>// return value into the function
</span><span class=c1></span><span class=w>                                             </span><span class=c1>// that calls it
</span><span class=c1></span><span class=w>
</span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>some_string</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>String</span>::<span class=n>from</span><span class=p>(</span><span class=s>&#34;hello&#34;</span><span class=p>);</span><span class=w> </span><span class=c1>// some_string comes into scope
</span><span class=c1></span><span class=w>
</span><span class=w>    </span><span class=n>some_string</span><span class=w>                              </span><span class=c1>// some_string is returned and
</span><span class=c1></span><span class=w>                                             </span><span class=c1>// moves out to the calling
</span><span class=c1></span><span class=w>                                             </span><span class=c1>// function
</span><span class=c1></span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w></span><span class=c1>// takes_and_gives_back will take a String and return one
</span><span class=c1></span><span class=k>fn</span> <span class=nf>takes_and_gives_back</span><span class=p>(</span><span class=n>a_string</span>: <span class=nb>String</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nb>String</span> <span class=p>{</span><span class=w> </span><span class=c1>// a_string comes into
</span><span class=c1></span><span class=w>                                                      </span><span class=c1>// scope
</span><span class=c1></span><span class=w>
</span><span class=w>    </span><span class=n>a_string</span><span class=w>  </span><span class=c1>// a_string is returned and moves out to the calling function
</span><span class=c1></span><span class=p>}</span><span class=w>
</span></code></pre></td></tr></table></div></div><p>所有权系统就像是给每一个变量进行了一个轨迹追踪一样。这样的话写代码感觉会更加清晰明了，但是阅读起来可能有点难受吧？</p><p>总体来说还是不错的设计。</p><p>完！</p><h3 id=参考>参考</h3><p><a href=https://www.zhihu.com/question/29833675>Java虚拟机的堆、栈、堆栈如何去理解？ RednaxelaFX大佬解答</a></p></div><div class=post-copyright><p class=copyright-item><span class=item-title>Author</span>
<span class=item-content>Joe</span></p><p class=copyright-item><span class=item-title>LastMod</span>
<span class=item-content>2020-07-06</span></p></div><footer class=post-footer><div class=post-tags><a href=/tags/programing/>programing</a>
<a href=/tags/rust/>rust</a></div><nav class=post-nav><a class=prev href=/post/rust/rust-references-and-borrowing/><i class="iconfont icon-left"></i><span class="prev-text nav-default">Rust Reference And Borrowing</span>
<span class="prev-text nav-mobile">Prev</span></a>
<a class=next href=/post/rust/rust-data-types/><span class="next-text nav-default">Rust Data Types</span>
<span class="next-text nav-mobile">Next</span>
<i class="iconfont icon-right"></i></a></nav></footer></article></div></div></main><footer id=footer class=footer><div class=social-links><a href=mailto:longshanluu@gmail.com class="iconfont icon-email" title=email></a><a href=https://github.com/holicc/holicc class="iconfont icon-github" title=github></a><a href=https://holicc.github.io/index.xml type=application/rss+xml class="iconfont icon-rss" title=rss></a></div><div class=copyright><span class=power-by>Powered by <a class=hexo-link href=https://gohugo.io>Hugo</a></span>
<span class=division>|</span>
<span class=theme-info>Theme -
<a class=theme-link href=https://github.com/olOwOlo/hugo-theme-even>Even</a></span>
<span class=copyright-year>&copy;
2017 -
2020<span class=heart><i class="iconfont icon-heart"></i></span><span>Joe</span></span></div></footer><div class=back-to-top id=back-to-top><i class="iconfont icon-up"></i></div></div><script src=https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin=anonymous></script><script src=https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin=anonymous></script><script src=https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin=anonymous></script><script type=text/javascript src=/js/main.min.c12618f9a600c40bd024996677e951e64d3487006775aeb22e200c990006c5c7.js></script></body></html>