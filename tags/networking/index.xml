<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>networking on Joe</title><link>https://holicc.github.io/tags/networking/</link><description>Recent content in networking on Joe</description><generator>Hugo -- gohugo.io</generator><lastBuildDate>Sun, 22 Mar 2020 00:00:00 +0000</lastBuildDate><atom:link href="https://holicc.github.io/tags/networking/index.xml" rel="self" type="application/rss+xml"/><item><title>Go Timer</title><link>https://holicc.github.io/2020/12/go-timer/</link><pubDate>Thu, 10 Dec 2020 00:00:00 +0000</pubDate><guid>https://holicc.github.io/2020/12/go-timer/</guid><description>Golang Timer // The Timer type represents a single event. // When the Timer expires, the current time will be sent on C, // unless the Timer was created by AfterFunc. // A Timer must be created with NewTimer or AfterFunc. type Timer struct { C &amp;lt;-chan Time r runtimeTimer } // Interface to timers implemented in package runtime. // Must be in sync with ../runtime/time.go:/^type timer type runtimeTimer struct</description></item><item><title>Common Principles</title><link>https://holicc.github.io/2020/10/principles/</link><pubDate>Sat, 10 Oct 2020 00:00:00 +0000</pubDate><guid>https://holicc.github.io/2020/10/principles/</guid><description>Contents Vertical scaling Horizontal scaling Caching Load balancing Database replication Database partitioning CAP theorem Domain name system Content delivery network Vertical scaling Vertical scaling means add more new resources in the existing system to meet the expectation. In other words that you scale by adding more power (CPU, RAM) to an existing machine. Good example of vertical scaling is The cloud version of MySQL Horizontal scaling Horizontal scaling means that</description></item><item><title>HTTP Range Download</title><link>https://holicc.github.io/2020/09/http-range/</link><pubDate>Wed, 23 Sep 2020 00:00:00 +0000</pubDate><guid>https://holicc.github.io/2020/09/http-range/</guid><description>Intro Recently,I'm interested in HTTP-Range-Download. So i decided build a toy with Rust Reference Go实现 HTTP 请求方法</description></item><item><title>Logout GET or POST</title><link>https://holicc.github.io/2020/09/about-logout-method/</link><pubDate>Thu, 10 Sep 2020 00:00:00 +0000</pubDate><guid>https://holicc.github.io/2020/09/about-logout-method/</guid><description>[Copy]Logout: GET or POST This question is not about when to use GET or POST in general; it is about which is the recommended one for handling logging out of a web application. I have found plenty of information on the differences between GET and POST in the general sense, but I did not find a definite answer for this particular scenario. As a pragmatist, I'm inclined to use GET,</description></item><item><title>Go Code Style</title><link>https://holicc.github.io/2020/09/go-code-snippet/</link><pubDate>Tue, 01 Sep 2020 00:00:00 +0000</pubDate><guid>https://holicc.github.io/2020/09/go-code-snippet/</guid><description>goroutine limiter var count int32 resp := make([]*CommandResponse, len(req.Images)) // waitForAllJob := make(chan struct{}, cfg.Server.MaxParallelNum) defer close(waitForAllJob) // for i := 0; i &amp;lt; len(req.Images); i++ { waitForAllJob &amp;lt;- struct{}{} go func(index int, img *model.Image) { response := process(img) resp[index] = response &amp;lt;-waitForAllJob atomic.AddInt32(&amp;amp;count, 1) }(i, &amp;amp;req.Images[i]) } // for int32(len(req.Images)) != count { }</description></item><item><title>Postgres VS MySQL</title><link>https://holicc.github.io/2020/08/postgres/</link><pubDate>Wed, 26 Aug 2020 00:00:00 +0000</pubDate><guid>https://holicc.github.io/2020/08/postgres/</guid><description>History POSTGRES的实现始于 1986 年，现在被称为PostgreSQL的对象-关系型数据库管理系统是从加州大学伯克利分校写的POSTGRES软件包</description></item><item><title>Go Code Style</title><link>https://holicc.github.io/2020/08/go-code-style/</link><pubDate>Mon, 17 Aug 2020 00:00:00 +0000</pubDate><guid>https://holicc.github.io/2020/08/go-code-style/</guid><description>Receiver Type Choosing whether to use a value or pointer receiver on methods can be difficult, especially to new Go programmers. If in doubt, use a pointer, but there are times when a value receiver makes sense, usually for reasons of efficiency, such as for small unchanging structs or values of basic type. Some useful guidelines:
If the receiver is a map, func or chan, don't use a pointer to them.</description></item><item><title>Rust Concurrency</title><link>https://holicc.github.io/2020/08/rust-concurrency/</link><pubDate>Wed, 05 Aug 2020 00:00:00 +0000</pubDate><guid>https://holicc.github.io/2020/08/rust-concurrency/</guid><description>Rust Concurrency Rust中的线程（Thread）使用的是1:1 model而不是像Golang中的goroutine使用的是M:N model； 因为Rust</description></item><item><title>Rust Features</title><link>https://holicc.github.io/2020/08/rust-features/</link><pubDate>Wed, 05 Aug 2020 00:00:00 +0000</pubDate><guid>https://holicc.github.io/2020/08/rust-features/</guid><description>Rust Unsafe 使用unsafe的五种特性： Dereference a raw pointer Call an unsafe function or method Access or modify a mutable static variable Implement an unsafe trait Access fields of unions Dereferencing a Raw Pointer 定义 raw pointer fn main() { let mut num = 5; let r1 = &amp;amp;num as *const i32; let r2 = &amp;amp;mut num as</description></item><item><title>Powershell Notes</title><link>https://holicc.github.io/2020/08/powershell-notes/</link><pubDate>Tue, 04 Aug 2020 00:00:00 +0000</pubDate><guid>https://holicc.github.io/2020/08/powershell-notes/</guid><description>Unix时间戳： Get-Date -UFormat %s 查看文件（类似cat的功能） type $file 创建文件： New-Item [path] 使用记事本打开文件 Start-Process notepad $file 打开文件夹 ii . 或者 Invoke-Item . 函数别名 Set-Alias 如何配置Powe</description></item><item><title>Rust Smart Pointer</title><link>https://holicc.github.io/2020/08/rust-smart-pointer/</link><pubDate>Tue, 04 Aug 2020 00:00:00 +0000</pubDate><guid>https://holicc.github.io/2020/08/rust-smart-pointer/</guid><description>Rust Smart Pointer (智能指针) 普通指针（Reference）: &amp;amp; 使用这个定义的，只是指向了对应的内存地址，并没有其他的功能； 智能指针（Smart Poin</description></item><item><title>Rust Testing</title><link>https://holicc.github.io/2020/07/rust-testing/</link><pubDate>Tue, 21 Jul 2020 00:00:00 +0000</pubDate><guid>https://holicc.github.io/2020/07/rust-testing/</guid><description>Rust单元测试 在Rust中使用测试，相当于在Java中使用@Test注解一样 #[cfg(test)] mod tests { #[test] fn it_works() { assert_eq!(2 + 2, 4); } } 其中#[test]就相当于一个注解</description></item><item><title>Rust Error</title><link>https://holicc.github.io/2020/07/rust-error/</link><pubDate>Fri, 17 Jul 2020 00:00:00 +0000</pubDate><guid>https://holicc.github.io/2020/07/rust-error/</guid><description>Rust中的错误处理 Rust中没有Exception这个概念，而是把错误分为了两种，一种是可恢复的错误，一种是不可恢复的错误 对于可恢复的错误</description></item><item><title>Rust Collections</title><link>https://holicc.github.io/2020/07/rust-collections/</link><pubDate>Wed, 15 Jul 2020 00:00:00 +0000</pubDate><guid>https://holicc.github.io/2020/07/rust-collections/</guid><description>Rust中的集合类型 Rust的标准库中提供了常用的集合类型：Vect(相当于Java中的List)，Map(相当于Java中的Map)，在使</description></item><item><title>RocketMQ</title><link>https://holicc.github.io/2020/07/rocketmq-overstock/</link><pubDate>Sun, 12 Jul 2020 00:00:00 +0000</pubDate><guid>https://holicc.github.io/2020/07/rocketmq-overstock/</guid><description>RocketMQ服务部署情况介绍 由于项目对消息的可靠性要求比较高所以采用的是SYNC_MASTER+SLAVE的部署方式, 并且使用了ASYN</description></item><item><title>Rust Packages Management</title><link>https://holicc.github.io/2020/07/rust-packages-management/</link><pubDate>Fri, 10 Jul 2020 00:00:00 +0000</pubDate><guid>https://holicc.github.io/2020/07/rust-packages-management/</guid><description>Rust Packages Crates and Modules 每个新出的编程语言都有一套对应的包管理工具，Rust也不列外，Rust使用的是cargo作为其包管理工具； crate是一个单一的库</description></item><item><title>Rust Enums And Patter Match</title><link>https://holicc.github.io/2020/07/rust-enums-and-patter-match/</link><pubDate>Thu, 09 Jul 2020 00:00:00 +0000</pubDate><guid>https://holicc.github.io/2020/07/rust-enums-and-patter-match/</guid><description>Rust中的枚举 enum枚举类型，一种熟悉的数据结构，在Java中也有对应的类型，就不赘述了. fn main() { enum IpAddrKind { V4, V6, } struct IpAddr { kind: IpAddrKind, address: String, } let home = IpAddr { kind:</description></item><item><title>Rust Struct</title><link>https://holicc.github.io/2020/07/rust-struct/</link><pubDate>Wed, 08 Jul 2020 00:00:00 +0000</pubDate><guid>https://holicc.github.io/2020/07/rust-struct/</guid><description>通过使用关键struct可以定义一个类，呸，是定义一个结构体。 struct User { username: String, email: String, sign_in_count: u64, active: bool, } fn main() { let user1 = User { email: String::from(&amp;quot;someone@example.com&amp;quot;), username: String::from(&amp;quot;someusername123&amp;quot;), active: true, sign_in_count: 1, }; } struct与Ja</description></item><item><title>Rust Reference And Borrowing</title><link>https://holicc.github.io/2020/07/rust-references-and-borrowing/</link><pubDate>Tue, 07 Jul 2020 00:00:00 +0000</pubDate><guid>https://holicc.github.io/2020/07/rust-references-and-borrowing/</guid><description>Rust中的引用(Reference)与借用(Borrowing) 在上一节的所有权系统的最后，官方抛出了一个问题，就是在函数使用的时候，如果</description></item><item><title>Rust Function</title><link>https://holicc.github.io/2020/07/rust-ownership/</link><pubDate>Mon, 06 Jul 2020 00:00:00 +0000</pubDate><guid>https://holicc.github.io/2020/07/rust-ownership/</guid><description>Rust中的所有权系统(Ownership) 目前大部分的编程语言管理内存都是使用的：1.自动管理(垃圾回收机制，像Java) 2.手动编码控制</description></item></channel></rss>