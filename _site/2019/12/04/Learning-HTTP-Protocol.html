<!DOCTYPE html>
<html>

    <head>
        <meta charset="utf-8">
        <meta content="width=device-width, initial-scale=1" name="viewport">
        <link rel="stylesheet" href="/assets/css/main.css">

        <!-- Begin Jekyll SEO tag v2.6.1 -->
<title>HTTP Note - 01 | Joe</title>
<meta name="generator" content="Jekyll v4.0.0" />
<meta property="og:title" content="HTTP Note - 01" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="TCP连接相关 并行连接：会消耗更多的资源（比如内存），也会受到带宽的限制，打开连接数量有限，会受到TCP慢启动和拥塞适应的影响。所以也不一定快。用户体验上会感觉快了。 持久连接：在一个HTTP事务完成之后不关闭连接，直到服务器或客户端通知关闭连接，可以避免TCP慢启动，进入已调协状态，提高传输效率。HTTP/1.0 使用的是 Connection：keep-alive关键字进行标记是否保持连接，默认是关闭的。HTTP/1.1 默认开启了持久连接，如果在首部没法标记：Connection：close就默认为开启持久连接。 代理对于HTTP报文的某些字段并不会转发（比如Connection字段等） 管道化连接：在HTTP/1.1的持久连接的基础上开通管道，将多条请求窜行发送。必须保证有序的应答，失败重试机制可能无法适用于POST这样的非幂等请求。 TCP是双向连接（输入和输出），当输入端被关闭然而数据并没有传输完，就会受到操作系统的异常提示“连接已经被充值”（难怪之前做DHT的时候老是遇到这个reset exception) 关闭输入通道比较危险，关闭输出相对安全 代理 连接两个或多个使用相同协议的应用程序 通过代理起到流量监控、访问控制、缓存、服务器加速（反向代理） 通过将代理服务器部署在网络结构中的不同位置来实现不同的功能 （可以自己实现流量监控或者匿名功能？） 如何让流量流向代理服务器？（基于如何获取HTTP的流量信息） 修改客户端 修改网络 （很黑客） 修改DNS的命名空间 （很黑客） 修改Web服务器 HTTP/1.1存在的问题 复杂性，实现难度较大 可拓展性，协议拓展没有兼容性 性能 传输协议的依赖，依赖于TCP/IP网络协议栈 为了解决以上的问题，成了1997年HTTP-NG组，然而在一年之后就解散了（由于当时HTTP/1.1还没有普及，所以暂时停止了重构HTTP协议，再后来HTTP/2.0就来了） 如何保存用户状态 周所周知HTTP是无状态的，那么早期的大佬们是如何保存用户的状态的呢？ 胖URL：通过将用户登录后生产的为ID带到每一个URL中标示用户。然而这个方法问题多到💥。 Cookie技术：由网景公司开发的技术，一致沿用至今。Cookie的基本思想是让浏览器累积一组服务器特有的的信息，每次都将这些信息带上访问服务器。Cookie有两个版本：0和1。现在大规模使用的都是由网景公司制定的版本0（因为1版本太复杂了吧） 问题 什么是幂等？（答：如果一个事务，不管执行多少次结果都是相等的，这个事务就是幂等的。） 什么是事务？（答：HTTP中指的是一次HTTP请求的完整流程。） 总结 阅读完《HTTP权威指南》，共耗时5～6个小时，该书是基于HTTP/1.1版本进行讲解的（现在已经有HTTP/2.0版本）很多已经过时或者内容与HTTP没有太多关联的章节都跳过了。这个书是一个HTTP协议的大致介绍，讲解的内容不是很细，还有很多内容都是过时的内容（毕竟出版比较久了）。由于内容比较简单笔记也做的不多。总的来说让我对HTTP协议有了基本的认识和了解，了解了HTTP协议的一个进化过程，通过从HTTP/0.9到HTTP/1.1的这个过程遇到很多web开发中比较常见的问题（比如代理、缓存、DNS解析、认证机制等）。也引出了TCP/IP的重要性，毕竟HTTP是属于应用层的协议，涉及到的内容不会太过于复杂，对于TCP、IP这样的协议属于传输层更加靠近底层会复杂许多。" />
<meta property="og:description" content="TCP连接相关 并行连接：会消耗更多的资源（比如内存），也会受到带宽的限制，打开连接数量有限，会受到TCP慢启动和拥塞适应的影响。所以也不一定快。用户体验上会感觉快了。 持久连接：在一个HTTP事务完成之后不关闭连接，直到服务器或客户端通知关闭连接，可以避免TCP慢启动，进入已调协状态，提高传输效率。HTTP/1.0 使用的是 Connection：keep-alive关键字进行标记是否保持连接，默认是关闭的。HTTP/1.1 默认开启了持久连接，如果在首部没法标记：Connection：close就默认为开启持久连接。 代理对于HTTP报文的某些字段并不会转发（比如Connection字段等） 管道化连接：在HTTP/1.1的持久连接的基础上开通管道，将多条请求窜行发送。必须保证有序的应答，失败重试机制可能无法适用于POST这样的非幂等请求。 TCP是双向连接（输入和输出），当输入端被关闭然而数据并没有传输完，就会受到操作系统的异常提示“连接已经被充值”（难怪之前做DHT的时候老是遇到这个reset exception) 关闭输入通道比较危险，关闭输出相对安全 代理 连接两个或多个使用相同协议的应用程序 通过代理起到流量监控、访问控制、缓存、服务器加速（反向代理） 通过将代理服务器部署在网络结构中的不同位置来实现不同的功能 （可以自己实现流量监控或者匿名功能？） 如何让流量流向代理服务器？（基于如何获取HTTP的流量信息） 修改客户端 修改网络 （很黑客） 修改DNS的命名空间 （很黑客） 修改Web服务器 HTTP/1.1存在的问题 复杂性，实现难度较大 可拓展性，协议拓展没有兼容性 性能 传输协议的依赖，依赖于TCP/IP网络协议栈 为了解决以上的问题，成了1997年HTTP-NG组，然而在一年之后就解散了（由于当时HTTP/1.1还没有普及，所以暂时停止了重构HTTP协议，再后来HTTP/2.0就来了） 如何保存用户状态 周所周知HTTP是无状态的，那么早期的大佬们是如何保存用户的状态的呢？ 胖URL：通过将用户登录后生产的为ID带到每一个URL中标示用户。然而这个方法问题多到💥。 Cookie技术：由网景公司开发的技术，一致沿用至今。Cookie的基本思想是让浏览器累积一组服务器特有的的信息，每次都将这些信息带上访问服务器。Cookie有两个版本：0和1。现在大规模使用的都是由网景公司制定的版本0（因为1版本太复杂了吧） 问题 什么是幂等？（答：如果一个事务，不管执行多少次结果都是相等的，这个事务就是幂等的。） 什么是事务？（答：HTTP中指的是一次HTTP请求的完整流程。） 总结 阅读完《HTTP权威指南》，共耗时5～6个小时，该书是基于HTTP/1.1版本进行讲解的（现在已经有HTTP/2.0版本）很多已经过时或者内容与HTTP没有太多关联的章节都跳过了。这个书是一个HTTP协议的大致介绍，讲解的内容不是很细，还有很多内容都是过时的内容（毕竟出版比较久了）。由于内容比较简单笔记也做的不多。总的来说让我对HTTP协议有了基本的认识和了解，了解了HTTP协议的一个进化过程，通过从HTTP/0.9到HTTP/1.1的这个过程遇到很多web开发中比较常见的问题（比如代理、缓存、DNS解析、认证机制等）。也引出了TCP/IP的重要性，毕竟HTTP是属于应用层的协议，涉及到的内容不会太过于复杂，对于TCP、IP这样的协议属于传输层更加靠近底层会复杂许多。" />
<link rel="canonical" href="http://localhost:4000/2019/12/04/Learning-HTTP-Protocol.html" />
<meta property="og:url" content="http://localhost:4000/2019/12/04/Learning-HTTP-Protocol.html" />
<meta property="og:site_name" content="Joe" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2019-12-04T00:00:00+08:00" />
<script type="application/ld+json">
{"url":"http://localhost:4000/2019/12/04/Learning-HTTP-Protocol.html","headline":"HTTP Note - 01","dateModified":"2019-12-04T00:00:00+08:00","datePublished":"2019-12-04T00:00:00+08:00","description":"TCP连接相关 并行连接：会消耗更多的资源（比如内存），也会受到带宽的限制，打开连接数量有限，会受到TCP慢启动和拥塞适应的影响。所以也不一定快。用户体验上会感觉快了。 持久连接：在一个HTTP事务完成之后不关闭连接，直到服务器或客户端通知关闭连接，可以避免TCP慢启动，进入已调协状态，提高传输效率。HTTP/1.0 使用的是 Connection：keep-alive关键字进行标记是否保持连接，默认是关闭的。HTTP/1.1 默认开启了持久连接，如果在首部没法标记：Connection：close就默认为开启持久连接。 代理对于HTTP报文的某些字段并不会转发（比如Connection字段等） 管道化连接：在HTTP/1.1的持久连接的基础上开通管道，将多条请求窜行发送。必须保证有序的应答，失败重试机制可能无法适用于POST这样的非幂等请求。 TCP是双向连接（输入和输出），当输入端被关闭然而数据并没有传输完，就会受到操作系统的异常提示“连接已经被充值”（难怪之前做DHT的时候老是遇到这个reset exception) 关闭输入通道比较危险，关闭输出相对安全 代理 连接两个或多个使用相同协议的应用程序 通过代理起到流量监控、访问控制、缓存、服务器加速（反向代理） 通过将代理服务器部署在网络结构中的不同位置来实现不同的功能 （可以自己实现流量监控或者匿名功能？） 如何让流量流向代理服务器？（基于如何获取HTTP的流量信息） 修改客户端 修改网络 （很黑客） 修改DNS的命名空间 （很黑客） 修改Web服务器 HTTP/1.1存在的问题 复杂性，实现难度较大 可拓展性，协议拓展没有兼容性 性能 传输协议的依赖，依赖于TCP/IP网络协议栈 为了解决以上的问题，成了1997年HTTP-NG组，然而在一年之后就解散了（由于当时HTTP/1.1还没有普及，所以暂时停止了重构HTTP协议，再后来HTTP/2.0就来了） 如何保存用户状态 周所周知HTTP是无状态的，那么早期的大佬们是如何保存用户的状态的呢？ 胖URL：通过将用户登录后生产的为ID带到每一个URL中标示用户。然而这个方法问题多到💥。 Cookie技术：由网景公司开发的技术，一致沿用至今。Cookie的基本思想是让浏览器累积一组服务器特有的的信息，每次都将这些信息带上访问服务器。Cookie有两个版本：0和1。现在大规模使用的都是由网景公司制定的版本0（因为1版本太复杂了吧） 问题 什么是幂等？（答：如果一个事务，不管执行多少次结果都是相等的，这个事务就是幂等的。） 什么是事务？（答：HTTP中指的是一次HTTP请求的完整流程。） 总结 阅读完《HTTP权威指南》，共耗时5～6个小时，该书是基于HTTP/1.1版本进行讲解的（现在已经有HTTP/2.0版本）很多已经过时或者内容与HTTP没有太多关联的章节都跳过了。这个书是一个HTTP协议的大致介绍，讲解的内容不是很细，还有很多内容都是过时的内容（毕竟出版比较久了）。由于内容比较简单笔记也做的不多。总的来说让我对HTTP协议有了基本的认识和了解，了解了HTTP协议的一个进化过程，通过从HTTP/0.9到HTTP/1.1的这个过程遇到很多web开发中比较常见的问题（比如代理、缓存、DNS解析、认证机制等）。也引出了TCP/IP的重要性，毕竟HTTP是属于应用层的协议，涉及到的内容不会太过于复杂，对于TCP、IP这样的协议属于传输层更加靠近底层会复杂许多。","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/2019/12/04/Learning-HTTP-Protocol.html"},"@type":"BlogPosting","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->

    </head>

    <body style="background-color: rgba(220, 238, 203, 0.781)">
        <script async src="/assets/js/theme.min.js"></script>

        <header>
            
        </header>

        <main>
            <article>
                <h1 class="post-headline">HTTP Note - 01</h1>
<p class="meta"><small>December 04, 2019</small></p>

<h3 id="tcp连接相关">TCP连接相关</h3>

<ul>
  <li><em>并行连接</em>：会消耗更多的资源（比如内存），也会受到带宽的限制，打开连接数量有限，会受到TCP慢启动和拥塞适应的影响。<strong>所以也不一定快</strong>。用户体验上会感觉快了。</li>
  <li><em>持久连接</em>：在一个HTTP事务完成之后不关闭连接，直到服务器或客户端通知关闭连接，可以避免TCP慢启动，进入已调协状态，提高传输效率。HTTP/1.0 使用的是 <strong>Connection：keep-alive</strong>关键字进行标记是否保持连接，默认是关闭的。HTTP/1.1 默认开启了持久连接，如果在首部没法标记：<strong>Connection：close</strong>就默认为开启持久连接。</li>
  <li><em>代理对于HTTP报文的某些字段并不会转发（比如Connection字段等）</em></li>
  <li><em>管道化连接</em>：在HTTP/1.1的持久连接的基础上开通管道，将多条请求窜行发送。必须保证有序的应答，失败重试机制可能无法适用于POST这样的非幂等请求。</li>
  <li><em>TCP是双向连接（输入和输出），当输入端被关闭然而数据并没有传输完，就会受到操作系统的异常提示“连接已经被充值”（难怪之前做DHT的时候老是遇到这个reset exception)</em> 关闭输入通道比较危险，关闭输出相对安全</li>
</ul>

<h3 id="代理">代理</h3>

<ul>
  <li><em>连接两个或多个使用相同协议的应用程序</em></li>
  <li><em>通过代理起到流量监控、访问控制、缓存、服务器加速（反向代理）</em></li>
  <li><em>通过将代理服务器部署在网络结构中的不同位置来实现不同的功能</em> （可以自己实现流量监控或者匿名功能？）</li>
</ul>

<h4 id="如何让流量流向代理服务器基于如何获取http的流量信息">如何让流量流向代理服务器？（基于如何获取HTTP的流量信息）</h4>

<ul>
  <li>修改客户端</li>
  <li><strong>修改网络</strong> （很黑客）</li>
  <li><strong>修改DNS的命名空间</strong> （很黑客）</li>
  <li>修改Web服务器</li>
</ul>

<h3 id="http11存在的问题">HTTP/1.1存在的问题</h3>

<ul>
  <li><em>复杂性，实现难度较大</em></li>
  <li><em>可拓展性，协议拓展没有兼容性</em></li>
  <li><em>性能</em></li>
  <li><em>传输协议的依赖，依赖于TCP/IP网络协议栈</em></li>
</ul>

<p>为了解决以上的问题，成了1997年HTTP-NG组，然而在一年之后就解散了（由于当时HTTP/1.1还没有普及，所以暂时停止了重构HTTP协议，再后来HTTP/2.0就来了）</p>

<h3 id="如何保存用户状态">如何保存用户状态</h3>

<p>周所周知HTTP是无状态的，那么早期的大佬们是如何保存用户的状态的呢？</p>

<ul>
  <li><em>胖URL</em>：通过将用户登录后生产的为ID带到每一个URL中标示用户。然而这个方法问题多到💥。</li>
  <li><em>Cookie技术</em>：由网景公司开发的技术，一致沿用至今。Cookie的基本思想是让浏览器累积一组服务器特有的的信息，每次都将这些信息带上访问服务器。Cookie有两个版本：0和1。现在大规模使用的都是由网景公司制定的版本0（因为1版本太复杂了吧）</li>
</ul>

<h3 id="问题">问题</h3>

<ol>
  <li>什么是幂等？（答：如果一个事务，不管执行多少次结果都是相等的，这个事务就是幂等的。）</li>
  <li>什么是事务？（答：HTTP中指的是一次HTTP请求的完整流程。）</li>
</ol>

<h3 id="总结">总结</h3>

<p>阅读完《HTTP权威指南》，共耗时5～6个小时，该书是基于HTTP/1.1版本进行讲解的（现在已经有HTTP/2.0版本）很多已经过时或者内容与HTTP没有太多关联的章节都跳过了。这个书是一个HTTP协议的大致介绍，讲解的内容不是很细，还有很多内容都是过时的内容（毕竟出版比较久了）。由于内容比较简单笔记也做的不多。总的来说让我对HTTP协议有了基本的认识和了解，了解了HTTP协议的一个进化过程，通过从HTTP/0.9到HTTP/1.1的这个过程遇到很多web开发中比较常见的问题（比如代理、缓存、DNS解析、认证机制等）。也引出了TCP/IP的重要性，毕竟HTTP是属于应用层的协议，涉及到的内容不会太过于复杂，对于TCP、IP这样的协议属于传输层更加靠近底层会复杂许多。</p>


<!-- Comments only for posts -->

    
        <hr class="divider">
<div id="disqus_thread"></div>
<script defer>
(function() {
    var d = document, s = d.createElement('script');
    s.src = '//takijoe.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the comments</noscript>
                              
    


            </article>
        </main>

        <footer>
            <p class="copy">
                <small>Copyrights by
                    Joe
                    | Developed by
                    <a href="http://webjeda.com">webjeda</a>
                </small>
            </p>
        </footer>
        <!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-157580785-1"></script>
<script>
    window.dataLayer = window.dataLayer || [];
    function gtag() { dataLayer.push(arguments); }
    gtag('js', new Date());

    gtag('config', 'UA-157580785-1');
</script>
    </body>

</html>
