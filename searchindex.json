{"categories":[{"title":"mysql","uri":"https://holicc.github.io/categories/mysql/"},{"title":"programing","uri":"https://holicc.github.io/categories/programing/"},{"title":"protocol","uri":"https://holicc.github.io/categories/protocol/"}],"posts":[{"content":"通过使用关键struct可以定义一个类，呸，是定义一个结构体。\nstruct User { username: String, email: String, sign_in_count: u64, active: bool, } fn main() { let user1 = User { email: String::from(\u0026quot;someone@example.com\u0026quot;), username: String::from(\u0026quot;someusername123\u0026quot;), active: true, sign_in_count: 1, }; }  struct与Java中的类是不同的两种数据结构，具体的使用方式也有所不同。\nfn build_user(email: String, username: String) -\u0026gt; User { User { email: email, username: username, active: true, sign_in_count: 1, } }  有一个算是语法糖的功能就是,结构体复用;使用..符号能够复用一个已经创建好的结构中的字段;\nstruct User { username: String, email: String, sign_in_count: u64, active: bool, } fn main() { let user1 = User { email: String::from(\u0026quot;someone@example.com\u0026quot;), username: String::from(\u0026quot;someusername123\u0026quot;), active: true, sign_in_count: 1, }; let user2 = User { email: String::from(\u0026quot;another@example.com\u0026quot;), username: String::from(\u0026quot;anotherusername567\u0026quot;), ..user1 }; }  也可以定义一种类似Java中Record的数据结构\nfn main() { struct Color(i32, i32, i32); struct Point(i32, i32, i32); let black = Color(0, 0, 0); let origin = Point(0, 0, 0); }  看起来虽然跟Golang没什么太大的区别,但是加上了所有权之后就有了一些限制;\nstruct User { username: \u0026amp;str, email: \u0026amp;str, sign_in_count: u64, active: bool, } fn main() { let user1 = User { email: \u0026quot;someone@example.com\u0026quot;, username: \u0026quot;someusername123\u0026quot;, active: true, sign_in_count: 1, }; }  这是Rust团队深思熟虑过后的设计,为了能够让struct的实例能够拥有成员变量的所有权\n In the User struct definition in Listing 5-1, we used the owned String type rather than the \u0026amp;str string slice type. This is a deliberate choice because we want instances of this struct to own all of its data and for that data to be valid for as long as the entire struct is valid.\n 不懂的是为什么这里username使用了\u0026amp;str就没有了username成员变量的所有权?\n难道是因为\u0026amp;str是一个slice类型? slice就是一中没有所有权的数据类型.\n Another data type that does not have ownership is the slice\n 好像是这样的,可以的,Rust强(吹)!\n想要像在Java中一样自由的打印对象,需要在struct上进行一些特殊处理,相当于需要实现一个toString()方法一样.\n#[derive(Debug)] struct Rectangle { width: u32, height: u32, } fn main() { let rect1 = Rectangle { width: 30, height: 50, }; println!(\u0026quot;rect1 is {:?}\u0026quot;, rect1); }  完(有点水了)!\n","id":0,"section":"posts","summary":"通过使用关键struct可以定义一个类，呸，是定义一个结构体。 struct User { username: String, email: String, sign_in_count: u64, active: bool, } fn main() { let user1 = User { email: String::from(\u0026quot;someone@example.com\u0026quot;), username: String::from(\u0026quot;someusername123\u0026quot;), active: true, sign_in_count: 1, }; } struct与Ja","tags":["programing","rust"],"title":"Rust Struct","uri":"https://holicc.github.io/2020/07/rust-struct/","year":"2020"},{"content":"Rust中的引用(Reference)与借用(Borrowing) 在上一节的所有权系统的最后，官方抛出了一个问题，就是在函数使用的时候，如果把参数传进去就把所有权移交到了函数中，那么后续又如何使用这个移交所有权后的变量呢？\nfn main() { let s1 = String::from(\u0026quot;hello\u0026quot;); let (s2, len) = calculate_length(s1); println!(\u0026quot;The length of '{}' is {}.\u0026quot;, s2, len); } fn calculate_length(s: String) -\u0026gt; (String, usize) { let length = s.len(); // len() returns the length of a String (s, length) }  官方给出的代码如上，但是这样写就太繁琐了。\n本节就是讲如何使用Reference和Borrorwing来解决这个问题。\n先来一段代码起手\nfn main() { let s1 = String::from(\u0026quot;hello\u0026quot;); let len = calculate_length(\u0026amp;s1); println!(\u0026quot;The length of '{}' is {}.\u0026quot;, s1, len); } fn calculate_length(s: \u0026amp;String) -\u0026gt; usize { s.len() }  上面这段代码，我理解的是传递的是s1变量的指针，所有s1变量的所有权没有移交出去。\n\u0026amp;这个符号，记得在C语言中是取地址的意思。\n The \u0026amp;s1 syntax lets us create a reference that refers to the value of s1 but does not own it. Because it does not own it, the value it points to will not be dropped when the reference goes out of scope.\n 在Rust中这样使用引用的方式叫做Borrowing借用,这种方式允许获取一个值的引用而不用移交所有权,因为你始终是东西的主人，别人只是借用了你的东西。\n We call having references as function parameters borrowing. As in real life, if a person owns something, you can borrow it from them. When you’re done, you have to give it back.\n 那么就有个问题，别人借的东西‘弄坏了怎么办？’\n一下代码不能编译通过是因为我们不能修改别人的东西。\nfn main() { let s = String::from(\u0026quot;hello\u0026quot;); change(\u0026amp;s); } fn change(some_string: \u0026amp;String) { some_string.push_str(\u0026quot;, world\u0026quot;); }  如果强行修改别人的东西那么就需要这样写（相当于在修改别人的东西时，先问一句：“我可以修改你的数据吗？”）\nfn main() { let mut s = String::from(\u0026quot;hello\u0026quot;); change(\u0026amp;mut s); } fn change(some_string: \u0026amp;mut String) { some_string.push_str(\u0026quot;, world\u0026quot;); }  但是呢，这样又有很多的限制，你不能把东西借给多个想要修改的人。\nfn main() { let mut s = String::from(\u0026quot;hello\u0026quot;); let r1 = \u0026amp;mut s; let r2 = \u0026amp;mut s; println!(\u0026quot;{}, {}\u0026quot;, r1, r2); }   Data races cause undefined behavior and can be difficult to diagnose and fix when you’re trying to track them down at runtime; Rust prevents this problem from happening because it won’t even compile code with data races!\n 为什么不许允许同一引用的多出修改，是为了避免数据竞争带来的各种不安全的行为。\n一种折中的写法是：\nfn main() { let mut s = String::from(\u0026quot;hello\u0026quot;); { let r1 = \u0026amp;mut s; } // r1 goes out of scope here, so we can make a new reference with no problems. let r2 = \u0026amp;mut s; }  但是不能通是把不可变引用和可变引用都借出去：\nfn main() { let mut s = String::from(\u0026quot;hello\u0026quot;); let r1 = \u0026amp;s; // no problem let r2 = \u0026amp;s; // no problem let r3 = \u0026amp;mut s; // BIG PROBLEM println!(\u0026quot;{}, {}, and {}\u0026quot;, r1, r2, r3); }  WTF?! 打脸\nfn main() { let mut s = String::from(\u0026quot;hello\u0026quot;); let r1 = \u0026amp;s; // no problem let r2 = \u0026amp;s; // no problem println!(\u0026quot;{} and {}\u0026quot;, r1, r2); // r1 and r2 are no longer used after this point let r3 = \u0026amp;mut s; // no problem println!(\u0026quot;{}\u0026quot;, r3); }   Note that a reference’s scope starts from where it is introduced and continues through the last time that reference is used. For instance, this code will compile because the last usage of the immutable references occurs before the mutable reference is introduced:\n 官方文档告诉我，只要不可变的引用被使用了，那么就会被释放，从而后续定义的可变引用r3定义就是能够编译通过的。\n这个“奇怪”的设计，官方也给出了安慰\n Even though borrowing errors may be frustrating at times, remember that it’s the Rust compiler pointing out a potential bug early (at compile time rather than at runtime) and showing you exactly where the problem is. Then you don’t have to track down why your data isn’t what you thought it was.\n 编译时期发能发现的问题，总比运行时的异常好吧 😂。\n之前说到会把”借来的东西玩坏“，就是一下这种情况，专业术语dangle 悬垂指针:\nfn main() { let reference_to_nothing = dangle(); } fn dangle() -\u0026gt; \u0026amp;String { // dangle returns a reference to a String let s = String::from(\u0026quot;hello\u0026quot;); // s is a new String \u0026amp;s // we return a reference to the String, s } // Here, s goes out of scope, and is dropped. Its memory goes away. // Danger!  因为是借用来的东西，在使用完后就会被释放掉，然而这里把他作为返回值返回就会造成悬垂指针的出现。\n解决这个问题也很简单，只要返回一个新的东西就行了。\nfn main() { let string = no_dangle(); } fn no_dangle() -\u0026gt; String { let s = String::from(\u0026quot;hello\u0026quot;); s }  学习到现在，这些东西都还是能够理解的，都是为了解决垃圾回收内存安全相关而发明的特性。\n完!\n","id":1,"section":"posts","summary":"Rust中的引用(Reference)与借用(Borrowing) 在上一节的所有权系统的最后，官方抛出了一个问题，就是在函数使用的时候，如果","tags":["programing","rust"],"title":"Rust Reference And Borrowing","uri":"https://holicc.github.io/2020/07/rust-references-and-borrowing/","year":"2020"},{"content":"Rust中的所有权系统(Ownership) 目前大部分的编程语言管理内存都是使用的：1.自动管理(垃圾回收机制，像Java) 2.手动编码控制内存的分配(像C或C++) 然而Rust不一样，另辟蹊径，靠的是编译器来保证内存的分配和回收。也叫做Ownership,这一概念是在Rust中独有的，是Rust独有的特性之一。如何看待这一特性，就是仁者见仁智者见智了，对于一个Java程序员来说，这一特性彷佛没有那么好，反而有点让人接受不了(可能是因为Rust是一门系统级别的编程语言，比较注重性能和安全性)\n memory is managed through a system of ownership with a set of rules that the compiler checks at compile time. None of the ownership features slow down your program while it’s running.\n 要明白所有权系统，要先对堆栈有基本的认识。\n All data stored on the stack must have a known, fixed size. Data with an unknown size at compile time or a size that might change must be stored on the heap instead\n 这个点不知道，记录一下\n When your code calls a function, the values passed into the function (including, potentially, pointers to data on the heap) and the function’s local variables get pushed onto the stack. When the function is over, those values get popped off the stack.\n 函数中的局部变量是分配在栈上的，每当函数调用完成，变量也已经被弹出栈顶了。\n官方文档也总结的很到位\n Keeping track of what parts of code are using what data on the heap, minimizing the amount of duplicate data on the heap, and cleaning up unused data on the heap so you don’t run out of space are all problems that ownership addresses. Once you understand ownership, you won’t need to think about the stack and the heap very often, but knowing that managing heap data is why ownership exists can help explain why it works the way it does.\n 所有权系统主要是为了帮助你更好的管理变量在堆栈上的分配。系统级别的编程语言比较在变量是分配到堆还是栈上，对于使用Java的我来说，对与这个概念是相当模糊的，只是大概知道Java中的对象大部分都是分配到堆上的，而且GC也是针对堆上的对象进行的回收。 为此顺便学习一下Java方面的知识吧。\nJVM规范让每个Java线程拥有自己的独立的JVM栈，也就是Java方法的调用栈。\nJVM里的“堆”（heap）特指用于存放Java对象的内存区域。所以根据这个定义，Java对象全部都在堆上\n要注意，这个“堆”并不是数据结构意义上的堆（Heap (data structure)，一种有序的树），而是动态内存分配意义上的堆——用于管理动态生命周期的内存区域。\nJVM的堆被同一个JVM实例中的所有Java线程共享。它通常由某种自动内存管理机制所管理，这种机制通常叫做“垃圾回收”（garbage collection，GC）。JVM规范并不强制要求JVM实现采用哪种GC算法。\n好了，回到Rust中的所有权系统。\n所有权系统需要熟知一下三条规则：\n Each value in Rust has a variable that’s called its owner(每一变量都有其拥有者//不知道这样翻译对不对 - -). There can only be one owner at a time.(同一时刻一个变量只能有一个拥有者) When the owner goes out of scope, the value will be dropped.(当拥有者不在作用域中了，那么这个值就会被释放掉)  规则比我想象的要简单明了许多，看上去很简洁，实际上却饱含了很多信息量。。。\n其中提到了scope(作用域)这个概念，有点类似于Spring中的scope的样子或者http中的session作用域和request作用域。\n官方给的例子还是很容易理解的\nfn main() { { // s is not valid here, it’s not yet declared let s = \u0026quot;hello\u0026quot;; // s is valid from this point forward // do stuff with s } // this scope is now over, and s is no longer valid }  有一点特殊的是String和literal\n在IDEA的提示下发现这是两种不同的类型，然儿在Java中都是统一的String\n\n原因是因为literal是固定长度的不可变的，分配在栈上的数据结构。而String是跟Java中的String类型一样是可变的。\n同为String类型但是有点不同的是。\nJava中的String可以这样写\nclass Scratch { public static void main(String[] args) { String a = \u0026quot;a\u0026quot;; String b = a; a += \u0026quot;zxc\u0026quot;; System.out.println(a + \u0026quot; \u0026quot; + b); } }  然而在Rust中这却不能这样\nfn main() { let s1 = String::from(\u0026quot;hello\u0026quot;); // let s2 = s1; 编译不通过 println!(\u0026quot;{}, world!\u0026quot;, s1); }  原因是因为Rust中是s2并没有对s1进行值拷贝，传递的是s1的指针。根据官方的解释，这里涉及到了 浅拷贝和深拷贝\n If you’ve heard the terms shallow copy and deep copy while working with other languages, the concept of copying the pointer, length, and capacity without copying the data probably sounds like making a shallow copy. But because Rust also invalidates the first variable, instead of being called a shallow copy, it’s known as a move. In this example, we would say that s1 was moved into s2.\n Rust并没有隐式的进行浅拷贝操作。而是让s1失效，这样的操作叫做 moved,相当于把s1上的值的指针移动到了s2上这样 s1就失效了。 为什么要这样做可能是为了能够更好的追踪内存并回收吧。\n如果要使用深拷贝,就要使用clone方法。该方法会对堆和栈上的所有内容进行拷贝。\nfn main() { let s1 = String::from(\u0026quot;hello\u0026quot;); let s2 = s1.clone(); println!(\u0026quot;s1 = {}, s2 = {}\u0026quot;, s1, s2); }  在有些地方，跟Java类似，对于基本的数据类型，都不需要使用显示的使用clone方法\nfn main() { let x = 5; let y = x; println!(\u0026quot;x = {}, y = {}\u0026quot;, x, y); }  在Rust中所有都遵循所有权系统的规则\n在函数中，传递进去的参数也是所有权移交的一种方式\nfn main() { let s = String::from(\u0026quot;hello\u0026quot;); // s comes into scope takes_ownership(s); // s's value moves into the function... // ... and so is no longer valid here let x = 5; // x comes into scope makes_copy(x); // x would move into the function, // but i32 is Copy, so it’s okay to still // use x afterward } // Here, x goes out of scope, then s. But because s's value was moved, nothing // special happens. fn takes_ownership(some_string: String) { // some_string comes into scope println!(\u0026quot;{}\u0026quot;, some_string); } // Here, some_string goes out of scope and `drop` is called. The backing // memory is freed. fn makes_copy(some_integer: i32) { // some_integer comes into scope println!(\u0026quot;{}\u0026quot;, some_integer); } // Here, some_integer goes out of scope. Nothing special happens.  返回值中就更好理解了\nfn main() { let s1 = gives_ownership(); // gives_ownership moves its return // value into s1 let s2 = String::from(\u0026quot;hello\u0026quot;); // s2 comes into scope let s3 = takes_and_gives_back(s2); // s2 is moved into // takes_and_gives_back, which also // moves its return value into s3 } // Here, s3 goes out of scope and is dropped. s2 goes out of scope but was // moved, so nothing happens. s1 goes out of scope and is dropped. fn gives_ownership() -\u0026gt; String { // gives_ownership will move its // return value into the function // that calls it let some_string = String::from(\u0026quot;hello\u0026quot;); // some_string comes into scope some_string // some_string is returned and // moves out to the calling // function } // takes_and_gives_back will take a String and return one fn takes_and_gives_back(a_string: String) -\u0026gt; String { // a_string comes into // scope a_string // a_string is returned and moves out to the calling function }  所有权系统就像是给每一个变量进行了一个轨迹追踪一样。这样的话写代码感觉会更加清晰明了，但是阅读起来可能有点难受吧？\n总体来说还是不错的设计。\n完！\n参考 Java虚拟机的堆、栈、堆栈如何去理解？ RednaxelaFX大佬解答\n","id":2,"section":"posts","summary":"Rust中的所有权系统(Ownership) 目前大部分的编程语言管理内存都是使用的：1.自动管理(垃圾回收机制，像Java) 2.手动编码控制","tags":["programing","rust"],"title":"Rust Function","uri":"https://holicc.github.io/2020/07/rust-ownership/","year":"2020"},{"content":"Rust中的数据类型 Rust是一门静态类型的语言(跟Java一样)，每一个值都有其对应的数据类型(Every value in Rust is of a certain data type)\nNumber Types Rust作为一门面向底层的编程语言，在数据类型上拥有了更多的类型，例如int类型在Java中只有一种表象形式，及表达32位的整形；然而在Rust中分的就特别细了。 在Rust中整型分为 Signed和Unsigned分别对应8，16，32，64，128位; 那么什么是 Signed有符号和 Unsigned 无符号呢？\n 有符号：0111 1111 = 26+25+24+23+22+21+2^0=127;范围是 -128 ~ 127\n无符号：1111 1111 = 27+26+25+24+23+22+21+20=255；范围是 0 ~ 255\n 除了这些，基本的运算符都是相同的，还有包括 float 也是有32位和84位的,char类型是是4字节子的,通用的 bool 类型。\n相比Java而言Rust多了一些复合类型的数据结构，例如： Tuple元组类型，元组是固定大小的，一旦定义完成就不能改变大小。 可以定义不同类型的元组\nfn main() { let tup: (i32, f64, u8) = (500, 6.4, 1); }  其中还包含相应的解包、模式匹配操作。\nfn main() { let tup = (500, 6.4, 1); let (x, y, z) = tup; println!(\u0026quot;The value of y is: {}\u0026quot;, y); }  获取Tuple中的元素直接使用下标就行了\nfn main() { let x: (i32, f64, u8) = (500, 6.4, 1); let five_hundred = x.0; let six_point_four = x.1; let one = x.2; }  接下来是 Array 也和大部分编程语言相同，只是定义的时候有点奇怪,类型和大小使用分号隔开的\nlet a: [i32; 5] = [1, 2, 3, 4, 5];  或者使用一个语法糖的方式定义\nlet a = [3; 5]; // [3, 3, 3, 3, 3]  也是一些基本的数据类型，没啥太特别的东西。\n完！\n","id":3,"section":"posts","summary":"Rust中的数据类型 Rust是一门静态类型的语言(跟Java一样)，每一个值都有其对应的数据类型(Every value in Rust is of a certain data type) Number Types Rust作","tags":["programing","rust"],"title":"Rust Data Types","uri":"https://holicc.github.io/2020/07/rust-data-types/","year":"2020"},{"content":"Rust中的函数 Rust是支持函数编程的，不像Java完全是使用面向对象的编程语言，虽然可以使用Function等，但是还是有些差距的。\nRust中定义函数的关键真是的超级简短，并且提倡使用蛇形命名法（这个挺好的）\nfn main() { another_function(5); } fn another_function(x: i32) { println!(\u0026quot;The value of x is: {}\u0026quot;, x); }  神奇的是你还可以这样写\nfn main() { let x = (let y = 6); }  但是这样写不能编译通过，官方是这样解释的\n Statements do not return values. Therefore, you can’t assign a let statement to another variable, as the following code tries to do; you’ll get an error\n 既然let语句是一个不会有返回值的语句那么如果在表达式中明确了返回值的话就可以了吧\nfn main() { let x = 5; let y = { let x = 3; x + 1 }; println!(\u0026quot;The value of y is: {}\u0026quot;, y); }  这样看来就有点函数式编程的味道了\n在返回值的地方可能有点奇怪,;是被省略掉了。可能对于Java程序员的我来说有点不习惯这样的操作。\n官方文档举出了一个列子来说明;的作用\nfn main() { let x = plus_one(5); println!(\u0026quot;The value of x is: {}\u0026quot;, x); } fn plus_one(x: i32) -\u0026gt; i32 { x + 1 } // 这样写会便宜不通过的 // fn plus_one(x: i32) -\u0026gt; i32 { // x + 1; // }  官方给出的解释如下：\n The main error message, “mismatched types,” reveals the core issue with this code. The definition of the function plus_one says that it will return an i32, but statements don’t evaluate to a value, which is expressed by (), an empty tuple. Therefore, nothing is returned, which contradicts the function definition and results in an error. In this output, Rust provides a message to possibly help rectify this issue: it suggests removing the semicolon, which would fix the error.\n 上了分号表示这是一个 statements ，返回值为一个空的元组及为空，所以和函数定义的返回i32类型不符合，所以编译不通过。\n嗯…… 奇怪\n完！\n","id":4,"section":"posts","summary":"Rust中的函数 Rust是支持函数编程的，不像Java完全是使用面向对象的编程语言，虽然可以使用Function等，但是还是有些差距的。 Ru","tags":["programing","rust"],"title":"Rust Function","uri":"https://holicc.github.io/2020/07/rust-function/","year":"2020"},{"content":"Rust中的变量与常量的定义 Rust中定义变量使用的关键字是 let 关键字，该关键字定义的变量是不可变的;想要定义一个可变的变量需要再使用一个关键 let mut对变量进行定义;\nfn main() { let mut x = 5; println!(\u0026quot;The value of x is: {}\u0026quot;, x); x = 6; println!(\u0026quot;The value of x is: {}\u0026quot;, x); }  为什么这样设计官方给出了解释:\n There are multiple trade-offs to consider in addition to the prevention of bugs. For example, in cases where you’re using large data structures, mutating an instance in place may be faster than copying and returning newly allocated instances. With smaller data structures, creating new instances and writing in a more functional programming style may be easier to think through, so lower performance might be a worthwhile penalty for gaining that clarity.\n 大致是说这是一种折中的设计，为了能够在操纵大的数据结构（类型Java中的对象）时，避免使用拷贝创建一个新的实例，而是直接操作其引用对其进行修改；相反在操作小的对象时拷贝创建一个新的对象更加符合函数式编程的风格更容易理解，当然也会消耗一点性能；\n*这样说是不是意味着 let的使用是进行值的拷贝，let mut只是传递的引用？*\n不过这样设计对于Java程序员来说也是能够理解的。\n定义常量使用的是关键字 const，可以在任何地方定义常量,但是需要注意的是定义常量的时候要把类型补充上去;\nconst A :u8 = 1; fn main() { const C:u16=33; let x = 5; println!(\u0026quot;x has the value {}\u0026quot;, x); }  Rust变量遮蔽(Shadowing) 这是算是一个有意思的特性吧。通过定义同名的变量来进行变量的遮蔽;\nfn main() { let x = 5; let x = x + 1; let x = x * 2; println!(\u0026quot;The value of x is: {}\u0026quot;, x); }  咋一看这不就是定义一个变量然后可以修改它的值嘛。Java中都有这样的,换个名字就变成 Shadowing 了。 - -| 高级。。\npublic static void main(String[] args) { int x = 5; x = x + 1; x = x * 2; System.out.println(x); }  或者相当于\nfn main() { let mut x = 5; x = x + 1; x = x * 2; println!(\u0026quot;The value of x is: {}\u0026quot;, x); }  对于以上的两种方式，官方给出了两个解释:\n Shadowing is different from marking a variable as mut, because we’ll get a compile-time error if we accidentally try to reassign to this variable without using the let keyword. By using let, we can perform a few transformations on a value but have the variable be immutable after those transformations have been completed.\n 第一个解释可以理解为：如果我们不使用let关键来进行遮蔽，那么意味着let定义的变量是可变的。这会导致编译出错，也会给let关键字带来歧义（本身代表的是不可变的意思），这个解释勉强可以理解吧。\n The other difference between mut and shadowing is that because we’re effectively creating a new variable when we use the let keyword again, we can change the type of the value but reuse the same name. For example, say our program asks a user to show how many spaces they want between some text by inputting space characters, but we really want to store that input as a number:\n 第二个解释就很好理解了，只用看一下官方的列子就能明白了。\nfn main() { let spaces = \u0026quot; \u0026quot;; let spaces = spaces.len(); }  完！\n","id":5,"section":"posts","summary":"Rust中的变量与常量的定义 Rust中定义变量使用的关键字是 let 关键字，该关键字定义的变量是不可变的;想要定义一个可变的变量需要再使用一个关键","tags":["programing","rust"],"title":"Rust Variables","uri":"https://holicc.github.io/2020/07/rust-variable/","year":"2020"},{"content":"安装Rust 直接到Rust官方网站 找到适合自己系统的安装包exe文件下载进行安装就行了\n\n官方提供win32位和64位的安装版本，不过一般都是64位的。还提供了WSL的安装版本。\n如果安装rust很慢，使用镜像：\n $ENV:RUSTUP_DIST_SERVER=‘https://mirrors.ustc.edu.cn/rust-static‘\n$ENV:RUSTUP_UPDATE_ROOT=‘https://mirrors.ustc.edu.cn/rust-static/rustup‘\n 然后到微软的官网下载 找到Visual Studio 2019 工具 下载好之后就可以进行安装了。\n勾选基本的C++构建环境\n\n再选择语言包\n\n最后配置IDE插件，本人使用的是IDEA(也可以用Clion)作为IDE。直接到官网找到Rust对应的插件RUST-FOR-IDEA\n(移动网真是太垃圾了，慢的要死) \n安装完之后重启IDEA，创建项目的时候就能看到Rust项目的选项了。\n然后配置一下源(类似Maven的阿里源一样) 清华源\n完！\n","id":6,"section":"posts","summary":"安装Rust 直接到Rust官方网站 找到适合自己系统的安装包exe文件下载进行安装就行了 官方提供win32位和64位的安装版本，不过一般都是6","tags":["programing","rust"],"title":"Install Rust On Win10","uri":"https://holicc.github.io/2020/07/install-rust-win10/","year":"2020"},{"content":"索引是什么 索引（在MySQL中也称为“键（key）”），用于存储引擎快速找到记录的一种数据结构。这是索引的基础功能。 索引可以包含一个列或多个列，当索引包含多个列的时候，那么列的顺序也十分重要，因为MySQL只能使用最左前缀列。\n索引的目的  索引大大减少了服务器扫描的数据量 帮助服务器避免排序和临时表 索引可以将随机I/O变为顺序I/O  索引的种类 在MySQL中，索引是由存储引擎实现的而不是由服务层实现的，所以并没有同一的标准：不同存储引擎的索引工作方式并不一样，也不是所有的存储引擎都支持所有类型的索引。即时多个存储引擎支持同种索引，其底层实现也可能不同。\nB-Tree索引 B-Tree是为磁盘等外存储设备设计的一种平衡查找树。因此在讲B-Tree之前先了解下磁盘的相关知识。\n系统从磁盘读取数据到内存时是以磁盘块（block）为基本单位的，位于同一个磁盘块中的数据会被一次性读取出来，而不是需要什么取什么。\nInnoDB存储引擎中有 页（Page） 的概念，页是其磁盘管理的最小单位。InnoDB存储引擎中默认每个页的大小为16KB，可通过参数innodb_page_size将页的大小设置为4K、8K、16K，在MySQL中可通过如下命令查看页的大小：\n show variables like 'innodb_page_size';\n 而系统一个磁盘块的存储空间往往没有这么大，因此InnoDB每次申请磁盘空间时都会是若干地址连续磁盘块来达到页的大小16KB。InnoDB在把磁盘数据读入到磁盘时会以页为基本单位，在查询数据时如果一个页中的每条数据都能有助于定位数据记录的位置，这将会减少磁盘I/O次数，提高查询效率。\nB-Tree结构的数据可以让系统高效的找到数据所在的磁盘块。为了描述B-Tree，首先定义一条记录为一个二元组[key, data] ，key为记录的键值，对应表中的主键值，data为一行记录中除主键外的数据。对于不同的记录，key值互不相同。\n\n每个节点占用一个盘块的磁盘空间，一个节点上有两个升序排序的关键字和三个指向子树根节点的指针，指针存储的是子节点所在磁盘块的地址。两个关键词划分成的三个范围域对应三个指针指向的子树的数据的范围域。以根节点为例，关键字为17和35，P1指针指向的子树的数据范围为小于17，P2指针指向的子树的数据范围为17~35，P3指针指向的子树的数据范围为大于35。\nB+Tree索引 从B-Tree结构图中可以看到每个节点中不仅包含数据的key值，还有data值。而每一个页的存储空间是有限的，如果data数据较大时将会导致每个节点（即一个页）能存储的key的数量很小，当存储的数据量很大时同样会导致B-Tree的深度较大，增大查询时的磁盘I/O次数，进而影响查询效率。在B+Tree中，所有数据记录节点都是按照键值大小顺序存放在同一层的叶子节点上，而非叶子节点上只存储key值信息，这样可以大大加大每个节点存储的key值数量，降低B+Tree的高度。\n由于B+Tree的非叶子节点只存储键值信息，假设每个磁盘块能存储4个键值及指针信息，则变成B+Tree后其结构如下图所示：\n\n适用条件：\n 全值匹配 匹配最左前缀 匹配范围值 精确匹配某一列并范围匹配另一列 值访问索引的查询  限制：\n 如果不是按照索引的最左列开始查找，则无法使用索引 不能跳过索引中的列 如果查询中有某个列的范围查询，则其右边所有列都无法使用索引优化查找  Hash索引 哈希索引（hash index）基于哈希表实现，只有精确匹配索引所有列的查询才有效，对于每一行数据，存储引擎都会对所有的索引列计算一个哈希值，哈希值是一个较小的值，并不同的键值的行计算的哈希值也不一样。哈希索引将所有的哈希值存储在索引中，同时在哈希表中保存指向每个数据行的指针。\n限制：\n 哈希索引只包含哈希值和行指针，不存储字段值，所以不能使用索引中的字段避免读取行 哈希索引数据无法用于排序 不支持索引列匹配查找，例如，在数据列（A，B）上建立的索引，如果查询只用到列A列则无法使用该索引 哈希索引只支持等值比较查询 哈希冲突太多会导致性能很低  InnoDB中有一个特殊的功能叫做“自适应索引”InnoDB会注意到使用非常频繁的索引值，会在内存中基于B-Tree索引之上再创建一个哈希索引。\n如何正确的使用索引 独立的列 “独立的列”是指索引列不能是表达式的一部分，也不能是函数的参数。\n例如：\n mysql\u0026gt; SELECT actor_id from actors where actor_id +1 =5 ;\n 这个例子就无法使用索引列 actor_id 。所以在使用WHERE条件的时候，始终将索引列单独放在比较符号的一侧，也不能对索引列使用函数。\n前缀索引和索引选择性 由于需要索引列是一个很长的字符串，这样会导致索引边的慢且大。这时可以通过使用前缀索引来解决，这样可以大大节约索引空间，从而提高索引效率。但是这样会降低索引的选择性。\n 选择性=补充度的索引值(基数)/数据表的记录时总数\n 索引的选择性越高则查询效率越高，唯一索引的选择性是1，这时最好的索引选择性，性能也是最好的。\n多列索引 在多个列上建立独立的单列索引大部分情况下并不能提高MySQL的查询性能。新版本的MySQL中引入了一种叫“索引合并”的策略\n聚簇索引 聚族索引并不是一种单独的索引类型，而是一种数据存储方式。InnoDB聚族索引实际上在同一个结构中保存了B-Tree索引和数据行\n聚簇索引就是按照每张表的主键构造一颗B+树，同时叶子节点中存放的就是整张表的行记录数据，也将聚集索引的叶子节点称为数据页。这个特性决定了索引组织表中数据也是索引的一部分，每张表只能拥有一个聚簇索引。\n聚簇索引的每一个叶节点都包含了主键值、 事务ID、 用于事务和MVCC的回滚指针、以及剩余的列\n\nInnodb通过主键聚集数据，如果没有定义主键，innodb会选择非空的唯一索引代替。如果没有这样的索引，innodb会隐式的定义一个主键来作为聚簇索引。\n聚簇索引的优缺点\n 优点：  数据访问更快，因为聚簇索引将索引和数据保存在同一个B+树中，因此从聚簇索引中获取数据比非聚簇索引更快 聚簇索引对于主键的排序查找和范围查找速度非常快 使用 覆盖索引 扫描的查询可以直接使用页节点中的主键值  缺点：  插入速度严重依赖于插入顺序，按照主键的顺序插入是最快的方式，否则将会出现页分裂，严重影响性能(例如：使用UUID作为索引，它会使插入边的完全随机就会造成页分裂和产生随机碎片)。因此，对于InnoDB表，我们一般都会定义一个自增的ID列为主键 更新主键的代价很高，因为将会导致被更新的行移动。因此，对于InnoDB表，我们一般定义主键为不可更新。 二级索引访问需要两次索引查找，第一次找到主键值，第二次根据主键值找到行数据。 聚簇索引可能导致全表扫描变慢，尤其是行比较稀疏，或者由于 页分裂 导致数据存储不连续的时候   辅助索引（非聚簇索引） 在聚簇索引之上创建的索引称之为辅助索引，辅助索引访问数据总是需要二次查找。辅助索引叶子节点存储的不再是行的物理位置，而是主键值。通过辅助索引首先找到的是主键值，再通过主键值找到数据行的数据页，再通过数据页中的Page Directory找到数据行。\nInnodb辅助索引的叶子节点并不包含行记录的全部数据，叶子节点除了包含键值外，还包含了相应行数据的聚簇索引键。这样的策略减少了当出现行移动或者数据页分裂时二级索引的维护工作。使用主键当作指针会让二级索引占用更多的空间，换来的好处是，InnoDB在移动行时无须更新二级索引中的这个“指针”\n辅助索引的存在不影响数据在聚簇索引中的组织，所以一张表可以有多个辅助索引。在innodb中有时也称辅助索引为二级索引。\n\n与MyISAM引擎中索引的区别如下图：\n\n覆盖索引 如果一个索引包含（或者说是覆盖）所有需要查询的字段的值，我们就称之为“覆盖索引”，覆盖索引的优点本质上就一条：覆盖索引能够避免 *回表*；\n不是所有类型的索引都可以称为覆盖所有。覆盖所有必须要存储索引列的值，而哈希索引、空间索引和全文索引等都不存储索引列的值，所以MySQL只能使用B-Tree索引做覆盖索引。\n当发起一个被索引覆盖的查询（也叫做索引覆盖查询）时，在EXPLAIN的Extra列可以看到“Using index”的信息\nMySQL查询优化器会在执行查询前判断是否有一个索引能够进行覆盖\n参考  聚簇索引和非聚簇索引(通俗易懂 言简意赅) Mysql 索引  ","id":7,"section":"posts","summary":"索引是什么 索引（在MySQL中也称为“键（key）”），用于存储引擎快速找到记录的一种数据结构。这是索引的基础功能。 索引可以包含一个列或多个","tags":["index","mysql"],"title":"MySQL 索引","uri":"https://holicc.github.io/2020/03/about-mysql-index/","year":"2020"},{"content":"TCP是什么 ? 传输控制协议（TCP）是互联网协议组中重要的组成部分之一。TCP的实现之初是为了补充互联网协议（IP）。因此，这一对组合经常被称为TCP/IP。TCP协议的特点：可靠性、顺序性、错误检查、数据流传输。大部分常见的应用都是使用的是TCP协议，例如：World Wide Web、Email、文件传输.TCP是面向连接的，这就需要客户端主动与服务端建立起连接之后才能开始传输数据。如果应用不需要可靠的数据流传输服务可能UPD协议是个更好的选择。\n为什么需要TCP ? TCP是个重要的协议是因为它在互联网的基础上建立了一套规则与标准化的信息数据传输机制。TCP让互联网之间的数据传输能够无视各种条件的限制（不管是地区限制、软件或硬件的限制），并且它是灵活的可拓展的（比如TCP/IP、增加SSL等），并且它是开源的不是私人所有。\n如何保证传输的可靠性? TCP segment structure TCP报文段分为两段：报头、数据段。报头包含10个字段和一个可选的拓展字段。数据段紧跟在 报头后面，里面装的都是应用传输的数据。数据的大小（length）不包括在 报头中；但是可以通过IP数据报的报头中指定的长度减去TCP报头的长度就得到了数据段的大小了。\n\n源端口(16 bits) \u0026amp; 目的端口(16 bits) 本机端口和目的地端口\n序列号(32 bits) 序列号就是用来标记每一个请求的，相当于请求的ID。\n 如果含有同步标识（SYN），则此为最初的序列号；第一个数据比特的序列码为本序列号加一 如果没有同步标识（SYN），则此为第一个数据比特的序列码  确认号 (32 bits) ACK如果被启用了，那么表示收到信息，并且ACK=（发送者的序列号+1）用于验证。\n连接建立 TCP连接的建立需要进行三次握手。在客户端尝试连接服务端之前，服务端需要绑定一个端口并监听它（passive open），之后客户端会主动向服务端发送建立连接请求，并进行 三次握手 建立连接。\n1.客户端向服务端发起一个 SYN请求，并将生成一个随机的序列号A。\n2.作为响应，服务端回复带有SYN-ACK标示的应答。其中ACK=A+1，并同时生成一个随机序列号B。\n3.最后，客户端收到服务端的ACK应答之后。客户端又会给服务端一个ACK应答并且序列号也会加一也A+1，然后ACK的序列号也加一B+1\n到这时候，客户端和服务端都收到了确认连接的消息。步骤1、2建立一个方向的连接参数(序列号)并确认。步骤2、3建立另一个方向的连接参数(序列号)并确认。有了这些，就可以建立全双工通信。\n\nTCP 连接使用三次握手的首要原因：为了 阻止历史的重复连接初始化造成的混乱问题。如果通信双方的通信次数只有两次，那么发送方一旦发出建立连接的请求之后它就没有办法撤回这一次请求，如果在网络状况复杂或者较差的网络中，发送方连续发送多次建立连接的请求，如果 TCP 建立连接只能通信两次，那么接收方只能选择接受或者拒绝发送方发起的请求，它并不清楚这一次请求是不是由于网络拥堵而早早过期的连接。\n所以，TCP 选择使用三次握手来建立连接并在连接引入了 RST 这一控制消息，接收方当收到请求时会将发送方发来的 SEQ+1 发送给对方，这时由发送方来判断当前连接是否是历史连接：\n如果当前连接是历史连接，即 SEQ 过期或者超时，那么发送方就会直接发送 RST 控制消息中止这一次连接； 如果当前连接不是历史连接，那么发送方就会发送 ACK 控制消息，通信双方就会成功建立连接； 使用三次握手和 RST 控制消息将是否建立连接的最终控制权交给了发送方，因为只有发送方有足够的上下文来判断当前连接是否是错误的或者过期的，这也是 TCP 使用三次握手建立连接的最主要原因。\n连接终止 TCP连接的关闭需要进行 四次挥手，两边都需要关闭连接，整个TCP连接才算完整的关闭。希望关闭连接，就会传送 FIN 包并包含之前的ACK包。所以关闭连接需要 一组 FIN 和 ACK。当一边的发送了第一个 FIN和最后的 ACK，会进入一个等待超时状态 TIME_WATI 之道整个连接关闭，在整个连接关闭之前TCP占用的端口不能被其他新连接所使用；这防止了由于延迟发包带来的混乱问题。\n\n对于复杂的网络状态，TCP 的实现提出了多种应对措施， TIME_WAIT 状态的提出就是为了应对其中一种异常状况。在 TIME_WAIT 阶段，主动端等待 2*MSL（最大分段寿命：表示一个 TCP 分段可以存在于互联网系统中的最大时间，由 TCP 的实现，超出这个寿命的分片都会被丢弃） 时间， MSL 建议为 2 分钟。\n如果没有 TIME_WAIT 状态，Client 不再保存这个连接的信息，收到一个不存在的连接的包，Client 会响应 RST 包，导致 Server 端异常响应。此时， TIME_WAIT 是为了 保证全双工的 TCP 连接正常终止。\n如果双方挥手之后，一个 网络四元组（src/dst ip/port）被回收，而此时网络中还有一个迟到的数据包没有被 Server 接收，Client 应用程序又立刻使用了同样的四元组再创建了一个新的连接后，这个迟到的数据包才到达 Server，那么这个数据包就会让 Server 以为是 Client 刚发过来的。此时， TIME_WAIT 的存在是为了 保证网络中迷失的数据包正常过期。\n连接可以处于半开状态，意思就是TCP的有一方连接已经关闭了，另一方还没有关闭。\n\n数据传输 可靠性传输 TCP使用 序列号标记每一份数据，通过使用序号和确认号，TCP 层可以把收到的报文段中的字节按正确的顺序交付给应用层，TCP 协议使用序号标识每端发出的字节的顺序，从而另一端接收数据时可以重建顺序，无惧传输时的包的乱序交付或丢包。在发送第一个包时（SYN包），选择一个 随机数 作为序号的初值，以克制 TCP 序号预测攻击。\n发送确认包（Acks），携带了接收到的对方发来的字节流的编号，称为确认号，以告诉对方 已经成功接收的数据流的字节位置。Ack并不意味着数据已经交付了上层应用程序。可\n靠性通过发送方检测到丢失的传输数据并重传这些数据。包括 超时重传（Retransmission timeout，RTO）与 重复累计确认 （duplicate cumulative acknowledgements，DupAcks）。\n重复累计确认重传 如果一个包（不妨设它的序号是 100 ，即该包始于第 100 字节）丢失，接收方就不能确认这个包及其以后的包，因为采用了 累计ACK 。接收方在收到 100 以后的包时，发出对包含第 99 字节的包的确认。这种重复确认是包丢失的信号。发送方如果收到 3 次对同一个包的确认，就重传最后一个未被确认的包。阈值设为 3 被证实可以减少乱序包导致的无作用的重传（spurious retransmission）现象。选择性确认（SACK）的使用能明确反馈哪个包收到了，极大改善了TCP重传必要的包的能力。\n超时重传 发送方使用一个保守估计的时间作为收到数据包的确认的超时上限。如果超过这个上限仍未收到确认包，发送方将重传这个数据包。每当发送方收到确认包后，会重置这个重传定时器。典型地，定时器的值设定为 \\({\\displaystyle {\\text{smoothed RTT}}+\\max(G,4\\times {\\text{RTT variation}})}\\) 是时钟粒度。进一步，如果重传定时器被触发，仍然没有收到确认包，定时器的值将被设为前次值的二倍（直到特定阈值）。这可对抗 中间人攻击方式的拒绝服务攻击，这种攻击愚弄发送者重传很多次导致接受者被压垮。\n流量控制 流量控制用来避免主机分组发送得过快而使接收方来不及完全收下，一般由接收方通告给发送方进行调控，这里的窗口被称为 接收通知窗口（Receiver's Advertised Window）。\n流量控制通过 滑动窗口机制 来实现： 报文发送方 在 WIN 域指出还可接收的字节数量（rwnd）。报文接收方在没有新的确认包的情况下至多发送 WIN 允许的字节数量。在数据传输过程中，报文发送方可修改 WIN 的值。\n拥塞控制 TCP 拥塞控制算法是互联网上主要的拥塞控制措施，它使用一套基于 线増积减（Additive increase/multiplicative decrease，AIMD）的网络拥塞控制方法来控制拥塞，防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载。\n除了 拥塞窗口大小（cwnd） 之外，TCP 连接的双方都有 接收窗口大小（rwnd）。客户端能够同时传输的最大数据段的数量是接收窗口大小和拥塞窗口大小的最小值，即 min(rwnd, cwnd)min(rwnd,cwnd) 。\nTCP 协议使用慢启动阈值（Slow start threshold, ssthresh）来决定使用慢启动或者拥塞避免算法：\n当拥塞窗口大小小于慢启动阈值时，使用慢启动； 当拥塞窗口大小大于慢启动阈值时，使用拥塞避免算法； 当拥塞窗口大小等于慢启动阈值时，使用慢启动或者拥塞避免算法；\n慢开始和拥塞避免 客户端维持一个 拥塞窗口 cwnd 的状态变量，初始值一般为 2\\times MSS2×MSS 。\n 慢开始：由小到大的指数增大拥塞窗口。首先将 cwnd 设置为一个最大报文段 MMS ，在收到一个对新的报文段的确认后，把拥塞窗口增加一个 MMS 。\n 拥塞避免：当慢开始到阈值（ssthresh）后，使用拥塞避免算法（ cwnd 每次加1 ）。当发送方发送的数据包丢包时，将 ssthresh 置为 cwnd 的一半，将 cwnd 置为1，再次执行慢开始。\n  快重传和快恢复 快速重传和恢复（fast retransmit and recovery，FRR） 是一种拥塞控制算法，它能快速恢复丢失的数据包。没有 FRR，如果数据包丢失了，TCP 将会使用定时器来要求传输暂停。在暂停的这段时间内，没有新的或复制的数据包被发送。有了FRR，如果接收机接收到一个不按顺序的数据段，它会立即给客户端发送一个重复确认。如果客户端接收到三个重复确认，它会认定数据段丢失，并立即重传这些丢失的数据段。\n有了 FRR，就不会因为重传时要求的暂停被耽误。当有单独的数据包丢失时，快速重传和恢复（FRR）能最有效地工作。当有多个数据信息包在某一段很短的时间内丢失时，它则不能很有效地工作。\nBBR BBR（Bottleneck Bandwidth and Round-trip propagation time）是 Google 研发的新的拥塞控制算法。自从 20 世纪 80年代后， TCP 中的拥塞控制算法都使用的是 基于丢包的拥塞控制（拥塞避免），在之前的网络带宽、路由器 Buffer 的情况下，该算法效果良好。\n但是在当前的网络条件下，基于丢包的拥塞控制算法则会导致 TCP 性能问题：\n在小 Buffer 路由器环境下，丢包发生在拥塞之前。在高速，长途链路中，基于丢包的拥塞控制会导致吞吐量过低，因为它反应过度，即使丢包是由瞬时流量突发引起的，也会因丢包而将发送速率减半（即使链路大部分处于空闲状态，这种丢包也可能非常频繁） 在大 Buffer 路由器环境下，拥塞发生在丢包之前。在互联网的边缘，基于丢包的拥塞控制通过反复填充大量的缓存，从而导致了臭名昭著的 bufferbloat 问题。 bufferbloat 问题：由于路由器的大缓存，减少链路丢包。再加上网络中 TCP 大量使用基于丢包的拥塞控制算法（丢包才触发速度下调，但是要丢包，缓存就得先被填满，缓存都填满，延迟更高）\nBBR 算法使用最大带宽和往返时间来建立网络的显式模型。每次对包传递进行累积或选择性确认，都会生成一个速率样本，该速率采样记录在数据包传输与该包确认之间的时间间隔内传递的数据量，从而使拥塞控制算法能够提供更高的吞吐量和更低的延迟。\n最大分段大小 最大分段大小 (MSS) 是在单个分段中 TCP 愿意接受的数据的字节数最大值。MSS应当足够小以避免IP分片，它会导致丢包或过多的重传。\n在 TCP 连接创建时，双端在 SYN 报文中用 MSS 选项宣布各自的 MSS ，这是从双端各自直接相连的数据链路层的最大传输单元(MTU)的尺寸减去固定的 IP 首部和 TCP 首部长度。以太网MTU为 1500 字节， MSS值可达 1460 字节。使用 IEEE 802.3 的 MTU 为 1492 字节，MSS 可达 1452 字节。\n如果目的IP地址为“非本地的”，MSS通常的默认值为 536（这个默认值允许 20 字节的 IP 首部和 20 字节的 TCP 首部以适合 576字节 IP 数据报）。此外，发送方可用传输路径 MTU 发现（RFC 1191）推导出从发送方到接收方的网络路径上的最小 MTU，以此动态调整 MSS 以避免网络 IP 分片。\nMSS 发布也被称作“MSS协商”（MSS negotiation）。严格讲，这并非是协商出来一个统一的MSS值，TCP 允许连接两端使用各自不同的MSS值。例如，这会发生在参与 TCP 连接的一台设备使用非常少的内存处理到来的 TCP 分组。\n选择确认 最初采取累计确认的 TCP 协议在丢包时效率很低。例如，假设通过10个分组发出了1万个字节的数据。如果第一个分组丢失，在纯粹的累计确认协议下，接收方不能说它成功收到了 1,000 到 9,999 字节，但未收到包含 0 到 999 字节的第一个分组。因而，发送方可能必须重传所有1万个字节。\n为此，TCP采取了 选择确认（selective acknowledgment，SACK） 选项。RFC 2018 对此定义为 允许接收方确认它成功收到的分组的不连续的块，以及基础 TCP 确认的成功收到最后连续字节序号。这种确认可以指出 SACK block，包含了已经成功收到的连续范围的开始与结束字节序号。在上述例子中，接收方可以发出 SACK 指出序号 1000 到 9999 ，发送方因此知道只需重发第一个分组(字节 0 到 999)。\nTCP 发送方会把乱序收包当作丢包，因此会重传乱序收到的包，导致连接的性能下降。重复SACK选项（duplicate-SACK option）是定义在RFC 2883中的SACK的一项扩展，可解决这一问题。接收方发出 D-SACK 指出没有丢包，接收方恢复到高传输率。 D-SACK 使用了 SACK 的第一个段来做标志：\n  如果 SACK 的第一个段的范围被 ACK 所覆盖，那么就是 D-SACK; 如果 SACK 的第一个段的范围被 SACK 的第二个段覆盖，那么就是 D-SACK D-SACK旨在告诉发送端：收到了重复的数据，数据包没有丢，丢的是ACK包；   SACK 选项并不是强制的。仅当双端都支持时才会被使用。 TCP 连接创建时会在 TCP 头中协商 SACK 细节。在 Linux下，可以通过 tcp_sack 参数打开 SACK 功能（Linux 2.4后默认打开）。Linux下的 tcp_dsack 参数用于开启D-SACK功能（Linux 2.4后默认打开）。选择确认也用于流控制传输协议 (SCTP)。\n参考  TCP TCP Protocol From Wikipedia Why TCP is important 《TCP IP 详解 第四版》  ","id":8,"section":"posts","summary":"TCP是什么 ? 传输控制协议（TCP）是互联网协议组中重要的组成部分之一。TCP的实现之初是为了补充互联网协议（IP）。因此，这一对组合经常被","tags":["networking","tcp"],"title":"About TCP Protocol","uri":"https://holicc.github.io/2020/03/about-tcp-protocol/","year":"2020"}],"tags":[{"title":"index","uri":"https://holicc.github.io/tags/index/"},{"title":"mysql","uri":"https://holicc.github.io/tags/mysql/"},{"title":"networking","uri":"https://holicc.github.io/tags/networking/"},{"title":"programing","uri":"https://holicc.github.io/tags/programing/"},{"title":"rust","uri":"https://holicc.github.io/tags/rust/"},{"title":"tcp","uri":"https://holicc.github.io/tags/tcp/"}]}