{"categories":[{"title":"mysql","uri":"https://holicc.github.io/categories/mysql/"},{"title":"programing","uri":"https://holicc.github.io/categories/programing/"},{"title":"protocol","uri":"https://holicc.github.io/categories/protocol/"},{"title":"rocketMQ","uri":"https://holicc.github.io/categories/rocketmq/"},{"title":"windows","uri":"https://holicc.github.io/categories/windows/"}],"posts":[{"content":"Receiver Type Choosing whether to use a value or pointer receiver on methods can be difficult, especially to new Go programmers. If in doubt, use a pointer, but there are times when a value receiver makes sense, usually for reasons of efficiency, such as for small unchanging structs or values of basic type. Some useful guidelines:\n If the receiver is a map, func or chan, don't use a pointer to them. If the receiver is a slice and the method doesn't reslice or reallocate the slice, don't use a pointer to it. If the method needs to mutate the receiver, the receiver must be a pointer. If the receiver is a struct that contains a sync.Mutex or similar synchronizing field, the receiver must be a pointer to avoid copying. If the receiver is a large struct or array, a pointer receiver is more efficient. How large is large? Assume it's equivalent to passing all its elements as arguments to the method. If that feels too large, it's also too large for the receiver. Can function or methods, either concurrently or when called from this method, be mutating the receiver? A value type creates a copy of the receiver when the method is invoked, so outside updates will not be applied to this receiver. If changes must be visible in the original receiver, the receiver must be a pointer. If the receiver is a struct, array or slice and any of its elements is a pointer to something that might be mutating, prefer a pointer receiver, as it will make the intention more clear to the reader. If the receiver is a small array or struct that is naturally a value type (for instance, something like the time.Time type), with no mutable fields and no pointers, or is just a simple basic type such as int or string, a value receiver makes sense. A value receiver can reduce the amount of garbage that can be generated; if a value is passed to a value method, an on-stack copy can be used instead of allocating on the heap. (The compiler tries to be smart about avoiding this allocation, but it can't always succeed.) Don't choose a value receiver type for this reason without profiling first. Finally, when in doubt, use a pointer receiver.  type User struct { Name string Age int } func NewUser(name string, age int) *User { return \u0026amp;User{ Name: name, Age: age, } }  Return a pointer rather than a struct to void data copy !\n","id":0,"section":"posts","summary":"Receiver Type Choosing whether to use a value or pointer receiver on methods can be difficult, especially to new Go programmers. If in doubt, use a pointer, but there are times when a value receiver makes sense, usually for reasons of efficiency, such as for small unchanging structs or values of basic type. Some useful guidelines:\n If the receiver is a map, func or chan, don't use a pointer to them.","tags":["programing"],"title":"Go Code Style","uri":"https://holicc.github.io/2020/08/go-code-style/","year":"2020"},{"content":"Rust Concurrency Rustä¸­çš„çº¿ç¨‹ï¼ˆThreadï¼‰ä½¿ç”¨çš„æ˜¯1:1 modelè€Œä¸æ˜¯åƒGolangä¸­çš„goroutineä½¿ç”¨çš„æ˜¯M:N modelï¼›\nå› ä¸ºRustæ˜¯ä¸€é—¨æ›´æ¥è¿‘åº•å±‚çš„ç¼–ç¨‹è¯­è¨€ï¼Œä½¿ç”¨M:Næ¨¡å‹éœ€è¦æ›´å¤§çš„è¿è¡Œæ—¶å¼€é”€æ¥æ”¯æŒã€‚\n The green-threading M:N model requires a larger language runtime to manage threads. As such, the Rust standard library only provides an implementation of 1:1 threading. Because Rust is such a low-level language, there are crates that implement M:N threading if you would rather trade overhead for aspects such as more control over which threads run when and lower costs of context switching, for example.\n çº¿ç¨‹çš„åˆ›å»º\nuse std::thread; use std::time::Duration; fn main() { thread::spawn(|| { for i in 1..10 { println!(\u0026quot;hi number {} from the spawned thread!\u0026quot;, i); thread::sleep(Duration::from_millis(1)); } }); for i in 1..5 { println!(\u0026quot;hi number {} from the main thread!\u0026quot;, i); thread::sleep(Duration::from_millis(1)); } }  æ˜¯ä¸ªçº¿ç¨‹å°±æœ‰joinæ–¹æ³•\nuse std::thread; use std::time::Duration; fn main() { let handle = thread::spawn(|| { for i in 1..10 { println!(\u0026quot;hi number {} from the spawned thread!\u0026quot;, i); thread::sleep(Duration::from_millis(1)); } }); handle.join().unwrap(); for i in 1..5 { println!(\u0026quot;hi number {} from the main thread!\u0026quot;, i); thread::sleep(Duration::from_millis(1)); } }  Rustçš„çº¿ç¨‹é€šä¿¡å€Ÿé‰´äº†Goä½¿ç”¨äº†channel.\n One increasingly popular approach to ensuring safe concurrency is message passing, where threads or actors communicate by sending each other messages containing data. Hereâ€™s the idea in a slogan from the Go language documentation: â€œDo not communicate by sharing memory; instead, share memory by communicating.â€\n ä½¿ç”¨mpsc::channelå‡½æ•°æ¥åˆ›å»ºchannel,å…¶ä¸­mpscè¡¨ç¤ºå¤šä¸ªç”Ÿäº§è€…ä¸€ä¸ªæ¶ˆè´¹è€…ï¼ˆmultiple producer, single consumerï¼‰ï¼Œåªè¦æ¶ˆè´¹è€…æ¥æ”¶åˆ°äº†ä¸€ä¸ªç”Ÿäº§è€…çš„æ¶ˆæ¯å°±ä¼šä¸­æ–­æ•´ä¸ªchannelã€‚\nuse std::sync::mpsc::channel; use std:ğŸ§µ:spawn; fn main() { let (tx, rx) = channel(); spawn(move || { tx.send(String::from(\u0026quot;hello\u0026quot;)).unwrap(); }); let received = rx.recv().unwrap(); println!(\u0026quot;Got: {}\u0026quot;, received); }  ä¸ºäº†èƒ½å¤Ÿæœ‰å¤šä¸ªç”Ÿäº§è€…ï¼Œéœ€è¦cloneä¸€ä¸‹tx\nuse std::rc::Rc; use std::sync::mpsc; use std:ğŸ§µ:{sleep, spawn}; use std::time::Duration; fn main() { let (tx, rx) = mpsc::channel(); let tx1 = tx.clone(); spawn(move || { tx.send(\u0026quot;one\u0026quot;).unwrap(); sleep(Duration::from_millis(1000)); }); spawn(move || { tx1.send(\u0026quot;two\u0026quot;).unwrap(); sleep(Duration::from_millis(1000)); }); for received in rx { println!(\u0026quot;Got: {}\u0026quot;, received); } }  rxä¸­çš„recvæ–¹æ³•ä¼šé˜»å¡å½“å‰çº¿ç¨‹ç›´åˆ°æ¥æ”¶åˆ°æ¶ˆæ¯ã€‚å¦‚æœä¸æƒ³é˜»å¡å¯ä»¥ä½¿ç”¨try_recvæ–¹æ³•ï¼Œè¯¥æ–¹æ³•ä¼šç«‹å³è¿”å›ã€‚\nä½¿ç”¨äº’æ–¥é”è§£å†³å¹¶å‘æ•°æ®è®¿é—®é—®é¢˜ã€‚\nuse std::sync::Mutex; fn main() { let m = Mutex::new(5); { let mut num = m.lock().unwrap(); *num = 6; } println!(\u0026quot;m = {:?}\u0026quot;, m); }  æ­£ç¡®ä½¿ç”¨é”çš„å§¿åŠ¿\nuse std::sync::{Arc, Mutex}; use std::thread; fn main() { let counter = Arc::new(Mutex::new(0)); let mut handles = vec![]; for _ in 0..10 { let counter = Arc::clone(\u0026amp;counter); let handle = thread::spawn(move || { let mut num = counter.lock().unwrap(); *num += 1; }); handles.push(handle); } for handle in handles { handle.join().unwrap(); } println!(\u0026quot;Result: {}\u0026quot;, *counter.lock().unwrap()); }  å†…å®¹æœ‰ç‚¹å°‘å•Š.\nå®Œï¼\n","id":1,"section":"posts","summary":"Rust Concurrency Rustä¸­çš„çº¿ç¨‹ï¼ˆThreadï¼‰ä½¿ç”¨çš„æ˜¯1:1 modelè€Œä¸æ˜¯åƒGolangä¸­çš„goroutineä½¿ç”¨çš„æ˜¯M:N modelï¼› å› ä¸ºRust","tags":["programing","rust"],"title":"Rust Concurrency","uri":"https://holicc.github.io/2020/08/rust-concurrency/","year":"2020"},{"content":"Rust Unsafe ä½¿ç”¨unsafeçš„äº”ç§ç‰¹æ€§ï¼š\n Dereference a raw pointer Call an unsafe function or method Access or modify a mutable static variable Implement an unsafe trait Access fields of unions  Dereferencing a Raw Pointer å®šä¹‰ raw pointer\nfn main() { let mut num = 5; let r1 = \u0026amp;num as *const i32; let r2 = \u0026amp;mut num as *mut i32; }  é‡Šæ”¾\nfn main() { let mut num = 5; let r1 = \u0026amp;num as *const i32; let r2 = \u0026amp;mut num as *mut i32; unsafe { println!(\u0026quot;r1 is: {}\u0026quot;, *r1); println!(\u0026quot;r2 is: {}\u0026quot;, *r2); } }  Calling an Unsafe Function or Method use std::slice; fn split_at_mut(slice: \u0026amp;mut [i32], mid: usize) -\u0026gt; (\u0026amp;mut [i32], \u0026amp;mut [i32]) { let len = slice.len(); let ptr = slice.as_mut_ptr(); assert!(mid \u0026lt;= len); unsafe { ( slice::from_raw_parts_mut(ptr, mid), slice::from_raw_parts_mut(ptr.add(mid), len - mid), ) } } fn main() { let mut vector = vec![1, 2, 3, 4, 5, 6]; let (left, right) = split_at_mut(\u0026amp;mut vector, 3); }  FFIï¼ˆForeign Function Interfaceï¼‰ç‰¹æ€§\nextern \u0026quot;C\u0026quot; { fn abs(input: i32) -\u0026gt; i32; } fn main() { unsafe { println!(\u0026quot;Absolute value of -3 according to C: {}\u0026quot;, abs(-3)); } }  Accessing or Modifying a Mutable Static Variable ä¿®æ”¹é™æ€å˜é‡\nstatic mut COUNTER: u32 = 0; fn add_to_count(inc: u32) { unsafe { COUNTER += inc; } } fn main() { add_to_count(3); unsafe { println!(\u0026quot;COUNTER: {}\u0026quot;, COUNTER); } }  Advanced Traits ç±»å‹å‚æ•°ï¼ˆç‰¹è´¨ä¸­å®šä¹‰ç±»å‹åˆ«åï¼‰\nstruct Counter { count: u32, } impl Counter { fn new() -\u0026gt; Counter { Counter { count: 0 } } } impl Iterator for Counter { type Item = u32; fn next(\u0026amp;mut self) -\u0026gt; Option\u0026lt;Self::Item\u0026gt; { // --snip-- if self.count \u0026lt; 5 { self.count += 1; Some(self.count) } else { None } } }  æ²¡çœ‹æ‡‚ï¼Œï¼ˆä¸æ³›å‹çš„åŒºåˆ«ï¼‰ - -|\n The difference is that when using generics, as in Listing 19-13, we must annotate the types in each implementation; because we can also implement Iterator for Counter or any other type, we could have multiple implementations of Iterator for Counter. In other words, when a trait has a generic parameter, it can be implemented for a type multiple times, changing the concrete types of the generic type parameters each time. When we use the next method on Counter, we would have to provide type annotations to indicate which implementation of Iterator we want to use. With associated types, we donâ€™t need to annotate types because we canâ€™t implement a trait on a type multiple times. In Listing 19-12 with the definition that uses associated types, we can only choose what the type of Item will be once, because there can only be one impl Iterator for Counter. We donâ€™t have to specify that we want an iterator of u32 values everywhere that we call next on Counter.\n æ“ä½œç¬¦é‡è½½\nuse std::ops::Add; #[derive(Debug, PartialEq)] struct Point { x: i32, y: i32, } impl Add for Point { type Output = Point; fn add(self, other: Point) -\u0026gt; Point { Point { x: self.x + other.x, y: self.y + other.y, } } } fn main() { assert_eq!( Point { x: 1, y: 0 } + Point { x: 2, y: 3 }, Point { x: 3, y: 3 } ); }  æ³›å‹å‚æ•°çš„é»˜è®¤å€¼\n#![allow(unused_variables)] fn main() { trait Add\u0026lt;RHS=Self\u0026gt; { type Output; fn add(self, rhs: RHS) -\u0026gt; Self::Output; } }  åŒåæ–¹æ³•\ntrait Pilot { fn fly(\u0026amp;self); } trait Wizard { fn fly(\u0026amp;self); } struct Human; impl Pilot for Human { fn fly(\u0026amp;self) { println!(\u0026quot;This is your captain speaking.\u0026quot;); } } impl Wizard for Human { fn fly(\u0026amp;self) { println!(\u0026quot;Up!\u0026quot;); } } impl Human { fn fly(\u0026amp;self) { println!(\u0026quot;*waving arms furiously*\u0026quot;); } } fn main() { let person = Human; //will call Human's fly method directly person.fly(); }  è°ƒç”¨åŒåæ–¹æ³•\ntrait Pilot { fn fly(\u0026amp;self); } trait Wizard { fn fly(\u0026amp;self); } struct Human; impl Pilot for Human { fn fly(\u0026amp;self) { println!(\u0026quot;This is your captain speaking.\u0026quot;); } } impl Wizard for Human { fn fly(\u0026amp;self) { println!(\u0026quot;Up!\u0026quot;); } } impl Human { fn fly(\u0026amp;self) { println!(\u0026quot;*waving arms furiously*\u0026quot;); } } fn main() { let person = Human; Pilot::fly(\u0026amp;person); Wizard::fly(\u0026amp;person); person.fly(); }  å…¨é™å®šåè°ƒç”¨ æ ¼å¼ï¼š\u0026lt;Type as Trait\u0026gt;::function(receiver_if_method, next_arg, ...);\ntrait Animal { fn baby_name() -\u0026gt; String; } struct Dog; impl Dog { fn baby_name() -\u0026gt; String { String::from(\u0026quot;Spot\u0026quot;) } } impl Animal for Dog { fn baby_name() -\u0026gt; String { String::from(\u0026quot;puppy\u0026quot;) } } fn main() { println!(\u0026quot;A baby dog is called a {}\u0026quot;, Dog::baby_name()); // println!(\u0026quot;A baby dog is called a {}\u0026quot;, Animal::baby_name()); not work rust doesn't known which implement is println!(\u0026quot;A baby dog is called a {}\u0026quot;, \u0026lt;Dog as Animal\u0026gt;::baby_name()); }  Advanced Types ç±»å‹åˆ«å\nfn main() { type Thunk = Box\u0026lt;dyn Fn() + Send + 'static\u0026gt;; let f: Thunk = Box::new(|| println!(\u0026quot;hi\u0026quot;)); fn takes_long_type(f: Thunk) { // --snip-- } fn returns_long_type() -\u0026gt; Thunk { // --snip-- Box::new(|| ()) } }  è¿˜æ”¯æŒæ³›å‹\nuse std::fmt; type Result\u0026lt;T\u0026gt; = std::result::Result\u0026lt;T, std::io::Error\u0026gt;; pub trait Write { fn write(\u0026amp;mut self, buf: \u0026amp;[u8]) -\u0026gt; Result\u0026lt;usize\u0026gt;; fn flush(\u0026amp;mut self) -\u0026gt; Result\u0026lt;()\u0026gt;; fn write_all(\u0026amp;mut self, buf: \u0026amp;[u8]) -\u0026gt; Result\u0026lt;()\u0026gt;; fn write_fmt(\u0026amp;mut self, fmt: fmt::Arguments) -\u0026gt; Result\u0026lt;()\u0026gt;; } fn main() {}  å¦‚ä½•è¿”å›é—­åŒ…å‡½æ•°ï¼Ÿ Box Everything\n#![allow(unused_variables)] fn main() { fn returns_closure() -\u0026gt; Box\u0026lt;dyn Fn(i32) -\u0026gt; i32\u0026gt; { Box::new(|x| x + 1) } }  Macros ä½¿ç”¨macro_rules!å®šä¹‰å®\nè§„åˆ™å¦‚ä¸‹ï¼š\n Custom #[derive] macros that specify code added with the derive attribute used on structs and enums Attribute-like macros that define custom attributes usable on any item Function-like macros that look like function calls but operate on the tokens specified as their argument  å®çš„ä½œç”¨ï¼š\n macros are a way of writing code that writes other code, which is known as metaprogramming\n #![allow(unused_variables)] fn main() { #[macro_export] macro_rules! vec { ( $( $x:expr ),* ) =\u0026gt; { { let mut temp_vec = Vec::new(); $( temp_vec.push($x); )* temp_vec } }; } }  #[macro_export]ç”¨æ¥ä¾›å¤–éƒ¨ä½¿ç”¨å®šä¹‰çš„å®\nå®å†™èµ·æ¥å°±åƒæ˜¯å†å†™ASTå’Œæ­£åˆ™è¡¨è¾¾å¼ï¼Œ$n:exprç”¨æ¥åŒ¹é…ä»»æ„è¡¨è¾¾å¼ $(,)?ç›¸å½“äºåŒ¹é…é€—å·æ˜¯å¦å‡ºç°ï¼›\nprocedural macrosè¿‡ç¨‹å®(å¤ªå¤æ‚ä»¥åé‡åˆ°äº†åœ¨ç ”ç©¶)\nuse proc_macro; #[some_attribute] pub fn some_name(input: TokenStream) -\u0026gt; TokenStream { }  Rustç‰ˆæ³¨è§£\nuse proc_macro::TokenStream; #[route(GET,\u0026quot;/\u0026quot;)] fn index(){} fn main() { index(); } #[proc_macro_attribute] fn route(attr:TokenStream,item:TokenStream)-\u0026gt;TokenStream{ }  å®Œ!\n","id":2,"section":"posts","summary":"Rust Unsafe ä½¿ç”¨unsafeçš„äº”ç§ç‰¹æ€§ï¼š Dereference a raw pointer Call an unsafe function or method Access or modify a mutable static variable Implement an unsafe trait Access fields of unions Dereferencing a Raw Pointer å®šä¹‰ raw pointer fn main() { let mut num = 5; let r1 = \u0026amp;num as *const i32; let r2 = \u0026amp;mut num as","tags":["programing","rust"],"title":"Rust Features","uri":"https://holicc.github.io/2020/08/rust-features/","year":"2020"},{"content":"Unixæ—¶é—´æˆ³ï¼š\nGet-Date -UFormat %s  æŸ¥çœ‹æ–‡ä»¶ï¼ˆç±»ä¼¼catçš„åŠŸèƒ½ï¼‰\ntype $file  åˆ›å»ºæ–‡ä»¶ï¼š\nNew-Item [path]  ä½¿ç”¨è®°äº‹æœ¬æ‰“å¼€æ–‡ä»¶\nStart-Process notepad $file  æ‰“å¼€æ–‡ä»¶å¤¹\nii .  æˆ–è€…\nInvoke-Item .  ","id":3,"section":"posts","summary":"Unixæ—¶é—´æˆ³ï¼š Get-Date -UFormat %s æŸ¥çœ‹æ–‡ä»¶ï¼ˆç±»ä¼¼catçš„åŠŸèƒ½ï¼‰ type $file åˆ›å»ºæ–‡ä»¶ï¼š New-Item [path] ä½¿ç”¨è®°äº‹æœ¬æ‰“å¼€æ–‡ä»¶ Start-Process notepad $file æ‰“å¼€æ–‡ä»¶å¤¹ ii . æˆ–è€… Invoke-Item .","tags":["powershell"],"title":"Powershell Notes","uri":"https://holicc.github.io/2020/08/powershell-notes/","year":"2020"},{"content":"Rust Smart Pointer (æ™ºèƒ½æŒ‡é’ˆ) æ™®é€šæŒ‡é’ˆï¼ˆReferenceï¼‰: \u0026amp; ä½¿ç”¨è¿™ä¸ªå®šä¹‰çš„ï¼Œåªæ˜¯æŒ‡å‘äº†å¯¹åº”çš„å†…å­˜åœ°å€ï¼Œå¹¶æ²¡æœ‰å…¶ä»–çš„åŠŸèƒ½ï¼›\næ™ºèƒ½æŒ‡é’ˆï¼ˆSmart Pointerï¼‰å°±æ˜¯èƒ½å¤Ÿæ‹¥æœ‰å¤šä¸ªownerå¹¶ä¸”åœ¨æ²¡æœ‰owneræ—¶è‡ªåŠ¨æ¸…ç†å›æ”¶ã€‚ï¼ˆGCï¼Ÿï¼ï¼‰ï¼Œå¹¶ä¸”æä¾›äº†ä¸€äº›å…¶ä»–åŠŸèƒ½ï¼›\n This pointer enables you to have multiple owners of data by keeping track of the number of owners and, when no owners remain, cleaning up the data.\n Rustä¸­æ™®é€šçš„æŒ‡é’ˆåªæ˜¯ä¸€ä¸ªå€Ÿç”¨ï¼Œç„¶è€Œæ™ºèƒ½æŒ‡é’ˆæ˜¯æ‹¥æœ‰\n In Rust, which uses the concept of ownership and borrowing, an additional difference between references and smart pointers is that references are pointers that only borrow data; in contrast, in many cases, smart pointers own the data they point to.\n æŒ‡é’ˆæŒ‡é’ˆæ˜¯ä¸€ç§å®ç°äº†Derefå’ŒDropæ¥å£çš„ç»“æ„ä½“\nboxæ˜¯Rustä¸­å¸¸ç”¨çš„æ™ºèƒ½æŒ‡é’ˆï¼Œå®ƒä¼šå°†å­˜å‚¨çš„æ•°æ®æ”¾åœ¨å †ä¸­è€Œä¸æ˜¯æ ˆä¸Šã€‚è¯¥æŒ‡é’ˆä¹Ÿä¸ä¼šå½±å“æ€§èƒ½ï¼Œåªæ˜¯æ²¡æœ‰é¢å¤–çš„åŠŸèƒ½ç½¢äº†ã€‚\n When you have a type whose size canâ€™t be known at compile time and you want to use a value of that type in a context that requires an exact size When you have a large amount of data and you want to transfer ownership but ensure the data wonâ€™t be copied when you do so When you want to own a value and you care only that itâ€™s a type that implements a particular trait rather than being of a specific type  fn main() { let b = Box::new(5); println!(\u0026quot;b = {}\u0026quot;, b); }  ä½¿ç”¨Derefæ¥æ§åˆ¶è§£å¼•ç”¨çš„è¿‡ç¨‹\nuse std::ops::Deref; impl\u0026lt;T\u0026gt; Deref for MyBox\u0026lt;T\u0026gt; { type Target = T; fn deref(\u0026amp;self) -\u0026gt; \u0026amp;T { \u0026amp;self.0 } } struct MyBox\u0026lt;T\u0026gt;(T); impl\u0026lt;T\u0026gt; MyBox\u0026lt;T\u0026gt; { fn new(x: T) -\u0026gt; MyBox\u0026lt;T\u0026gt; { MyBox(x) } } fn main() { let x = 5; let y = MyBox::new(x); assert_eq!(5, x); assert_eq!(5, *y); }  å½“ä¸€ä¸ªå˜é‡çš„å€¼å°†è¦ç¦»å¼€ä½œç”¨åŸŸçš„æ—¶å€™ï¼Œå¯ä»¥ä½¿ç”¨Dropç‰¹è´¨æ¥æå‰æ„ŸçŸ¥è¿™ä¸€æ“ä½œå¹¶åšå‡ºç›¸åº”çš„å¤„ç†ã€‚ä¾‹å¦‚ï¼šBoxå°±æ˜¯ä½¿ç”¨æ¥Dropæ¥é‡Šæ”¾å®ƒæ‰€æŒæœ‰çš„æŒ‡é’ˆçš„ã€‚\nstruct CustomSmartPointer { data: String, } impl Drop for CustomSmartPointer { fn drop(\u0026amp;mut self) { println!(\u0026quot;Dropping CustomSmartPointer with data `{}`!\u0026quot;, self.data); } } fn main() { let c = CustomSmartPointer { data: String::from(\u0026quot;my stuff\u0026quot;), }; let d = CustomSmartPointer { data: String::from(\u0026quot;other stuff\u0026quot;), }; println!(\u0026quot;CustomSmartPointers created.\u0026quot;); }  Dropç‰¹è´¨ç›¸å½“ä¸å‘Šè¯‰ç¼–è¯‘å™¨ï¼Œåœ¨ç‰¹å®šçš„åœ°æ–¹è‡ªåŠ¨æ’å…¥ä»£ç ä½¿å…¶è°ƒç”¨dropæ–¹æ³•ï¼Œå¥½è®©å˜é‡è‡ªåŠ¨é‡Šæ”¾ã€‚\nè¯¥ç‰¹è´¨çš„dropæ–¹æ³•ä¸æ”¯æŒæ‰‹åŠ¨è°ƒç”¨ï¼Œè¯¥æ–¹æ³•å¿…é¡»ç”±ç¼–è¯‘å™¨æ¥è‡ªåŠ¨è°ƒç”¨ï¼Œå¦‚æœæ‰‹åŠ¨è°ƒç”¨è¯¥æ–¹æ³•ä¼šç¼–è¯‘ä¸é€šè¿‡çš„ ï¼ˆexplicit destructor calls not allowedï¼‰ã€‚\nåŸå› å¾ˆç®€å•ï¼ŒRustå¹¶ä¸ä¼šæ™ºèƒ½åˆ°è§åˆ°åˆ°äº†æ‰‹åŠ¨è°ƒç”¨dropå°±ä¼šä¸æ‰§è¡Œå·²ç»æ’å…¥çš„è‡ªåŠ¨dropæ–¹æ³•ï¼Œæ‰€ä»¥ä¼šé€ æˆä¸¤æ¬¡é‡Šæ”¾åŒä¸€ä¸ªå˜é‡\n Rust doesnâ€™t let us call drop explicitly because Rust would still automatically call drop on the value at the end of main. This would be a double free error because Rust would be trying to clean up the same value twice.\n å½“ç„¶æœ‰äº›æƒ…å†µæˆ‘ä»¬æ˜¯æƒ³è¦æå‰é‡Šæ”¾èµ„æºï¼Œè¿™ç§æƒ…å†µå°±éœ€è¦ä½¿ç”¨æ ‡å‡†åº“ä¸­std::mem::dropçš„dropå‡½æ•°\nstruct CustomSmartPointer { data: String, } impl Drop for CustomSmartPointer { fn drop(\u0026amp;mut self) { println!(\u0026quot;Dropping CustomSmartPointer with data `{}`!\u0026quot;, self.data); } } fn main() { let c = CustomSmartPointer { data: String::from(\u0026quot;some data\u0026quot;), }; println!(\u0026quot;CustomSmartPointer created.\u0026quot;); drop(c); println!(\u0026quot;CustomSmartPointer dropped before the end of main.\u0026quot;); }  Rc\u0026lt;T\u0026gt;ï¼ˆå…¨ç§°ï¼šreference countingï¼‰æ˜¯ä¸€ä¸ªå¯ä»¥è®©å˜é‡æ‹¥æœ‰å¤šä¸ªownerçš„æŒ‡é’ˆã€‚\nå®˜æ–¹ä¸¾äº†ä¸ªä¾‹å­ï¼Œç”ŸåŠ¨å½¢è±¡çš„ç†è§£Rc\u0026lt;T\u0026gt;\n Imagine Rc as a TV in a family room. When one person enters to watch TV, they turn it on. Others can come into the room and watch the TV. When the last person leaves the room, they turn off the TV because itâ€™s no longer being used. If someone turns off the TV while others are still watching it, there would be uproar from the remaining TV watchers!\n enum List { Cons(i32, Rc\u0026lt;List\u0026gt;), Nil, } use crate::List::{Cons, Nil}; use std::rc::Rc; fn main() { let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil))))); let b = Cons(3, Rc::clone(\u0026amp;a)); let c = Cons(4, Rc::clone(\u0026amp;a)); }  Rc::cloneä½¿ç”¨çš„æ˜¯æµ…æ‹·è´ï¼Œè¿™é‡Œæ¯æ¬¡æ‹·è´äº†ä¹‹åä¼šä½¿aå¼•ç”¨è®¡æ•°åŠ ä¸€ã€‚ä¹Ÿå¯ä»¥ä½¿ç”¨a.clone()ï¼Œå¦‚ä½•ä½¿ç”¨cloneå–å†³äºä½¿ç”¨åœºæ™¯ã€‚\n We could have called a.clone() rather than Rc::clone(\u0026amp;a), but Rustâ€™s convention is to use Rc::clone in this case. The implementation of Rc::clone doesnâ€™t make a deep copy of all the data like most typesâ€™ implementations of clone do. The call to Rc::clone only increments the reference count, which doesnâ€™t take much time. Deep copies of data can take a lot of time. By using Rc::clone for reference counting, we can visually distinguish between the deep-copy kinds of clones and the kinds of clones that increase the reference count. When looking for performance problems in the code, we only need to consider the deep-copy clones and can disregard calls to Rc::clone.\n å¯ä»¥ä½¿ç”¨Rc::strong_count(\u0026amp;a)æŸ¥çœ‹å½“å‰å˜é‡æœ‰å¤šå°‘ä¸ªå¼•ç”¨ã€‚\nRefCell\u0026lt;T\u0026gt; (ä¸çŸ¥åæŒ‡é’ˆ)ç”¨äºæ‰“ç ´Rustè§„åˆ™çš„æŒ‡é’ˆã€‚å› ä¸ºæœ‰æ—¶Rustç¼–è¯‘å™¨ä¸èƒ½æ­£ç¡®çš„åˆ†æå‡ºä»£ç çš„Ownershipå°±ä¼šæ‹’ç»ç¼–è¯‘ï¼Œä½†æ˜¯ç¼–å†™ä»£ç è€…èƒ½å¤Ÿä¿è¯è¿™æ®µä»£ç æ˜¯ç¬¦åˆRustè§„åˆ™çš„ï¼Œæ‰€ä»¥è¿™ä¸ªæ—¶å€™å°±å¯ä»¥ä½¿ç”¨è¿™ä¸ªæŒ‡é’ˆæ¥ä½¿ç¼–è¯‘é€šè¿‡ï¼Œå¹¶ä¸”åœ¨è¿è¡Œæ—¶æ¥è¿›è¡ŒOwnershipçš„æ£€æŸ¥å·¥ä½œï¼Œå¦‚æœå‘ç°è§„åˆ™è¢«æ‰“ç ´ï¼Œå°±ä¼španicã€‚\n The advantage of checking the borrowing rules at runtime instead is that certain memory-safe scenarios are then allowed, whereas they are disallowed by the compile-time checks. Static analysis, like the Rust compiler, is inherently conservative. Some properties of code are impossible to detect by analyzing the code: the most famous example is the Halting Problem, which is beyond the scope of this book but is an interesting topic to research.\nBecause some analysis is impossible, if the Rust compiler canâ€™t be sure the code complies with the ownership rules, it might reject a correct program; in this way, itâ€™s conservative. If Rust accepted an incorrect program, users wouldnâ€™t be able to trust in the guarantees Rust makes. However, if Rust rejects a correct program, the programmer will be inconvenienced, but nothing catastrophic can occur. The RefCell type is useful when youâ€™re sure your code follows the borrowing rules but the compiler is unable to understand and guarantee that.\n Rc\u0026lt;T\u0026gt;, RefCell\u0026lt;T\u0026gt;è¿™ä¸¤ä¸ªæŒ‡é’ˆéƒ½åªèƒ½åœ¨å•çº¿ç¨‹çš„ç¯å¢ƒä¸‹ä½¿ç”¨ã€‚\nBox\u0026lt;T\u0026gt;, Rc\u0026lt;T\u0026gt;, RefCell\u0026lt;T\u0026gt;ä¸‰è€…çš„åŒºåˆ«\n Rc\u0026lt;T\u0026gt;å…è®¸ä¸€ä¸ªå˜é‡æœ‰å¤šä¸ªæ‹¥æœ‰è€…ï¼Œå…¶ä»–ä¸¤ä¸ªåªèƒ½æœ‰ä¸€ä¸ªã€‚ Box\u0026lt;T\u0026gt;æ”¯æŒç¼–è¯‘æœŸçš„å¯å˜çš„å’Œä¸å¯å˜çš„å€Ÿç”¨æ£€æŸ¥ï¼›Rc\u0026lt;T\u0026gt;æ”¯æŒç¼–è¯‘æœŸçš„ä¸å¯å˜çš„å€Ÿç”¨æ£€æŸ¥ï¼›RefCell\u0026lt;T\u0026gt;æ”¯æŒè¿è¡Œæ—¶çš„å¯å˜çš„å’Œä¸å¯å˜çš„å€Ÿç”¨æ£€æŸ¥ï¼› Refcell\u0026lt;T\u0026gt;å¯ä»¥æ”¹å˜ä¸€ä¸ªä¸å¯å˜çš„å˜é‡ï¼ˆBecause RefCell allows mutable borrows checked at runtime, you can mutate the value inside the RefCell even when the RefCell is immutable.ï¼‰  çªå˜æ¨¡å¼ï¼Ÿï¼\n Mutating the value inside an immutable value is the interior mutability pattern.\n #[derive(Debug)] enum List { Cons(Rc\u0026lt;RefCell\u0026lt;i32\u0026gt;\u0026gt;, Rc\u0026lt;List\u0026gt;), Nil, } use crate::List::{Cons, Nil}; use std::cell::RefCell; use std::rc::Rc; fn main() { let value = Rc::new(RefCell::new(5)); let a = Rc::new(Cons(Rc::clone(\u0026amp;value), Rc::new(Nil))); let b = Cons(Rc::new(RefCell::new(6)), Rc::clone(\u0026amp;a)); let c = Cons(Rc::new(RefCell::new(10)), Rc::clone(\u0026amp;a)); *value.borrow_mut() += 10; println!(\u0026quot;a after = {:?}\u0026quot;, a); println!(\u0026quot;b after = {:?}\u0026quot;, b); println!(\u0026quot;c after = {:?}\u0026quot;, c); }  å¾ªç¯ä¾èµ–å¯èƒ½ä¼šé€ æˆå†…å­˜æ³„æ¼çš„é—®é¢˜ï¼Œå› ä¸ºä½¿ç”¨äº†Rc\u0026lt;T\u0026gt;å¦‚æœç›¸äº’ä¾èµ–é‚£ä¹ˆå¼•ç”¨æ•°å°±æ°¸è¿œä¸ä¼šä¸º0ã€‚ï¼ˆJavaä¸­çš„GCä¹Ÿæœ‰è¿™ä¸ªé—®é¢˜ï¼Œç”¨å¯è¾¾æ€§åˆ†æè§£å†³çš„ï¼‰\nuse crate::List::{Cons, Nil}; use std::cell::RefCell; use std::rc::Rc; #[derive(Debug)] enum List { Cons(i32, RefCell\u0026lt;Rc\u0026lt;List\u0026gt;\u0026gt;), Nil, } impl List { fn tail(\u0026amp;self) -\u0026gt; Option\u0026lt;\u0026amp;RefCell\u0026lt;Rc\u0026lt;List\u0026gt;\u0026gt;\u0026gt; { match self { Cons(_, item) =\u0026gt; Some(item), Nil =\u0026gt; None, } } } fn main() { let a = Rc::new(Cons(5, RefCell::new(Rc::new(Nil)))); println!(\u0026quot;a initial rc count = {}\u0026quot;, Rc::strong_count(\u0026amp;a)); println!(\u0026quot;a next item = {:?}\u0026quot;, a.tail()); let b = Rc::new(Cons(10, RefCell::new(Rc::clone(\u0026amp;a)))); println!(\u0026quot;a rc count after b creation = {}\u0026quot;, Rc::strong_count(\u0026amp;a)); println!(\u0026quot;b initial rc count = {}\u0026quot;, Rc::strong_count(\u0026amp;b)); println!(\u0026quot;b next item = {:?}\u0026quot;, b.tail()); if let Some(link) = a.tail() { *link.borrow_mut() = Rc::clone(\u0026amp;b); } println!(\u0026quot;b rc count after changing a = {}\u0026quot;, Rc::strong_count(\u0026amp;b)); println!(\u0026quot;a rc count after changing a = {}\u0026quot;, Rc::strong_count(\u0026amp;a)); // Uncomment the next line to see that we have a cycle; // it will overflow the stack // println!(\u0026quot;a next item = {:?}\u0026quot;, a.tail()); }  Rustæ— æ³•å¤„ç†å¾ªç¯ä¾èµ–å¯¼è‡´çš„å†…å­˜æ³„éœ²é—®é¢˜ï¼Œå› ä¸ºè¿™éƒ½æ˜¯å†™ä»£ç è‡ªå·±çš„å†™çš„é—®é¢˜ï¼Œæ¢æˆå…¶ä»–è¯­è¨€ä¹Ÿä¼šå‡ºç°è¿™æ ·çš„é—®é¢˜ã€‚\nä½†Rustä¹Ÿä¸æ˜¯ä»»äººè‡ªç”Ÿè‡ªç­ï¼Œå¦‚ä½•é˜²æ­¢å¾ªç¯å¼•ç”¨çš„å½¢æˆï¼ŒRustä¸­å¼•å…¥äº†å¼±å¼•ç”¨çš„æ¦‚å¿µï¼ˆJavaä¸­çš„è™šå¼•ç”¨ï¼‰ï¼Œä½¿ç”¨Rc\u0026lt;T\u0026gt;ä¸­çš„Rc::downgradeä¼šå¢åŠ weak_countçš„æ•°é‡ï¼Œç„¶è€Œå›æ”¶çš„æ—¶å€™ä¸ç®¡week_countæ˜¯å¦æ˜¯0éƒ½ä¼šå›æ”¶é‡Šæ”¾èµ„æºï¼Œåªè¦strong_countä¸º0æ—¶ã€‚\nä¸ºäº†èƒ½å¤Ÿä»æ–°è·å–å¼±å¼•ç”¨ï¼Œå¯ä»¥ä½¿ç”¨upgradeæ–¹æ³•å¯¹å…¶è¿›è¡Œå‡çº§ï¼Œè¿”å›çš„æ˜¯ä¸€ä¸ªOption\u0026lt;Rc\u0026lt;T\u0026gt;\u0026gt;\nuse std::cell::RefCell; use std::rc::{Rc, Weak}; #[derive(Debug)] struct Node { value: i32, parent: RefCell\u0026lt;Weak\u0026lt;Node\u0026gt;\u0026gt;, children: RefCell\u0026lt;Vec\u0026lt;Rc\u0026lt;Node\u0026gt;\u0026gt;\u0026gt;, } fn main() { let leaf = Rc::new(Node { value: 3, parent: RefCell::new(Weak::new()), children: RefCell::new(vec![]), }); println!(\u0026quot;leaf parent = {:?}\u0026quot;, leaf.parent.borrow().upgrade()); let branch = Rc::new(Node { value: 5, parent: RefCell::new(Weak::new()), children: RefCell::new(vec![Rc::clone(\u0026amp;leaf)]), }); *leaf.parent.borrow_mut() = Rc::downgrade(\u0026amp;branch); println!(\u0026quot;leaf parent = {:?}\u0026quot;, leaf.parent.borrow().upgrade()); }  æ™ºèƒ½æŒ‡é’ˆï¼Œæœ‰ç‚¹å¤æ‚...\nå®Œï¼\n","id":4,"section":"posts","summary":"Rust Smart Pointer (æ™ºèƒ½æŒ‡é’ˆ) æ™®é€šæŒ‡é’ˆï¼ˆReferenceï¼‰: \u0026amp; ä½¿ç”¨è¿™ä¸ªå®šä¹‰çš„ï¼Œåªæ˜¯æŒ‡å‘äº†å¯¹åº”çš„å†…å­˜åœ°å€ï¼Œå¹¶æ²¡æœ‰å…¶ä»–çš„åŠŸèƒ½ï¼› æ™ºèƒ½æŒ‡é’ˆï¼ˆSmart Poin","tags":["programing","rust"],"title":"Rust Smart Pointer","uri":"https://holicc.github.io/2020/08/rust-smart-pointer/","year":"2020"},{"content":"Rustå•å…ƒæµ‹è¯• åœ¨Rustä¸­ä½¿ç”¨æµ‹è¯•ï¼Œç›¸å½“äºåœ¨Javaä¸­ä½¿ç”¨@Testæ³¨è§£ä¸€æ ·\n#[cfg(test)] mod tests { #[test] fn it_works() { assert_eq!(2 + 2, 4); } }  å…¶ä¸­#[test]å°±ç›¸å½“äºä¸€ä¸ªæ³¨è§£è¡¨ç¤ºè¿™ä¸ªå‡½æ•°æ˜¯ä¸€ä¸ªæµ‹è¯•å‡½æ•°ï¼Œä½¿ç”¨assert_eq!æ¥è¿›è¡ŒæœŸæœ›åˆ¤æ–­ã€‚\nç„¶åä½¿ç”¨cargo testå°±å¯ä»¥è¿è¡Œå•å…ƒæµ‹è¯•äº†\nRustçš„æµ‹è¯•è¿˜è‡ªå¸¦æ€§èƒ½æµ‹è¯•åªä¸è¿‡éœ€è¦ä½¿ç”¨å°é²œç‰ˆ\né™¤æ­¤ä¹‹å¤–Rustä¹Ÿå¸¦æœ‰assertåŠŸèƒ½ï¼Œå…¶å®Javaä¸­ä¹Ÿæœ‰ï¼Œåªä¸è¿‡ç”¨çš„äººå¤ªå°‘äº†ï¼Œéƒ½ç”¨çš„junitçš„assert\nJavaä¸­çš„assert\nclass Scratch { public static void main(String[] args) { assert \u0026quot;hello\u0026quot;.equals(args[0]); } }  Rustä¸­çš„assert\n#[derive(Debug)] struct Rectangle { width: u32, height: u32, } impl Rectangle { fn can_hold(\u0026amp;self, other: \u0026amp;Rectangle) -\u0026gt; bool { self.width \u0026gt; other.width \u0026amp;\u0026amp; self.height \u0026gt; other.height } } #[cfg(test)] mod tests { use super::*; #[test] fn larger_can_hold_smaller() { let larger = Rectangle { width: 8, height: 7, }; let smaller = Rectangle { width: 5, height: 1, }; assert!(larger.can_hold(\u0026amp;smaller)); } }  ä¸¤ä¸ªéƒ½æ˜¯åˆ¤æ–­ä¸€ä¸ªbooleanå€¼ï¼Œtrueå°±ç›¸å®‰æ— äº‹ï¼Œfalseå°±æ— æ³•é€šè¿‡æµ‹è¯•\nç”±äºRustä¸­ä½¿ç”¨çš„æ˜¯å®æä¾›çš„åŠŸèƒ½ç›¸å¯¹å¤šä¸€ç‚¹ï¼šassert_eq! å’Œ assert_ne!\nè¿˜æ”¯æŒè‡ªå®šä¹‰é”™è¯¯ä¿¡æ¯\npub fn greeting(name: \u0026amp;str) -\u0026gt; String { format!(\u0026quot;Hello {}!\u0026quot;, name) } #[cfg(test)] mod tests { use super::*; #[test] fn greeting_contains_name() { let result = greeting(\u0026quot;Carol\u0026quot;); assert!(result.contains(\u0026quot;Carol\u0026quot;)); } }  å¯¹é”™è¯¯å¼‚å¸¸è¿›è¡Œæµ‹è¯•\npub struct Guess { value: i32, } impl Guess { pub fn new(value: i32) -\u0026gt; Guess { if value \u0026lt; 1 || value \u0026gt; 100 { panic!(\u0026quot;Guess value must be between 1 and 100, got {}.\u0026quot;, value); } Guess { value } } } #[cfg(test)] mod tests { use super::*; #[test] #[should_panic] fn greater_than_100() { Guess::new(200); } }  è¿˜æ”¯æŒä½¿ç”¨Result\u0026lt;T,E\u0026gt;ç±»å‹ä½œä¸ºè¿”å›å€¼æ¥ç¼–å†™å•å…ƒæµ‹è¯•\n#![allow(unused_variables)] fn main() { #[cfg(test)] mod tests { #[test] fn it_works() -\u0026gt; Result\u0026lt;(), String\u0026gt; { if 2 + 2 == 4 { Ok(()) } else { Err(String::from(\u0026quot;two plus two does not equal four\u0026quot;)) } } } }  ä½†æ˜¯è¿™æ ·å†™äº†å°±ä¸èƒ½ä½¿ç”¨#[should_panic] äº†.\nå†æ¥è¯´è¯´cargo testå‘½ä»¤ï¼Œè¿™ä¸ªå‘½ä»¤ç‰¹åˆ«å¼ºå¤§ï¼Œèƒ½æ”¯æŒçš„ä¸œè¥¿å¾ˆå¤šï¼›\nä¾‹å¦‚ä½ å¯ä»¥è®©æµ‹è¯•å¹¶è¡Œæ‰§è¡Œæˆ–è€…ä¸²è¡Œï¼ŒRusté»˜è®¤ä½¿ç”¨çš„æ˜¯å¹¶è¡Œæ‰§è¡Œå•å…ƒæµ‹è¯•çš„ã€‚\nå¯ä»¥é€šè¿‡å‚æ•°è®¾ç½®è®©å•å…ƒæµ‹è¯•å¹¶è¡Œæˆ–ä¸²è¡Œ\n$ cargo test -- --test-threads=1  Showing Function Outputäººæ€§åŒ–çš„è®¾è®¡ï¼Œåœ¨å•å…ƒæµ‹è¯•ä¸­çš„æ‰“å°ä¿¡æ¯println!ï¼Œåªæœ‰åœ¨å•å…ƒæµ‹è¯•ä¸é€šè¿‡çš„æƒ…å†µä¸‹æ‰ä¼šæ‰“å°åœ¨ç»ˆç«¯ä¸Šï¼›\nå¦‚æœæƒ³ä¸ç®¡æ˜¯å¦é€šè¿‡éƒ½æ‰“å°ä¿¡æ¯ä½¿ç”¨å‚æ•°\n$ cargo test -- --show-output  ä¹Ÿå¯ä»¥é€šè¿‡æŒ‡å®šæµ‹è¯•çš„åç§°æ¥è¿è¡Œå•ä¸ªå•å…ƒæµ‹è¯•æˆ–è€…å¤šä¸ªå•å…ƒæµ‹è¯•\n#![allow(unused_variables)] fn main() { pub fn add_two(a: i32) -\u0026gt; i32 { a + 2 } #[cfg(test)] mod tests { use super::*; #[test] fn add_two_and_two() { assert_eq!(4, add_two(2)); } #[test] fn add_three_and_two() { assert_eq!(5, add_two(3)); } #[test] fn one_hundred() { assert_eq!(102, add_two(100)); } } }  ä»¥ä¸Šçš„å•å…ƒæµ‹è¯•å¯ä»¥é€šè¿‡åœ¨å‘½ä»¤cargo test one_two æ¥åªè¿è¡Œ add_two_and_twoè¿™ä¸ªå•å…ƒæµ‹è¯•ï¼Œä¹Ÿå¯ä»¥é€šè¿‡ å‘½ä»¤ cargo test addæ¥è¿è¡Œä»¥addå¼€å¤´çš„å•å…ƒæµ‹è¯•\nå¯¹äºå¿½è§†çš„å•å…ƒæµ‹è¯•ç›´æ¥åœ¨å•å…ƒæµ‹è¯•ä¸ŠåŠ ä¸Š#[ignore]æ³¨è§£å°±è¡Œäº†\nå¦‚æœè¦æ‰§è¡Œä¹‹å‰å¿½è§†çš„å•å…ƒæµ‹è¯•åªéœ€è¦ä½¿ç”¨å‘½ä»¤\n$ cargo test -- --ignored  Rustå¯ä»¥æµ‹è¯•privateçš„å‡½æ•°ï¼ï¼ï¼èµ\npub fn add_two(a: i32) -\u0026gt; i32 { internal_adder(a, 2) } fn internal_adder(a: i32, b: i32) -\u0026gt; i32 { a + b } #[cfg(test)] mod tests { use super::*; #[test] fn internal() { assert_eq!(4, internal_adder(2, 2)); } }  å®Œ!\n","id":5,"section":"posts","summary":"Rustå•å…ƒæµ‹è¯• åœ¨Rustä¸­ä½¿ç”¨æµ‹è¯•ï¼Œç›¸å½“äºåœ¨Javaä¸­ä½¿ç”¨@Testæ³¨è§£ä¸€æ · #[cfg(test)] mod tests { #[test] fn it_works() { assert_eq!(2 + 2, 4); } } å…¶ä¸­#[test]å°±ç›¸å½“äºä¸€ä¸ªæ³¨è§£","tags":["programing","rust"],"title":"Rust Testing","uri":"https://holicc.github.io/2020/07/rust-testing/","year":"2020"},{"content":"Rustä¸­çš„é”™è¯¯å¤„ç† Rustä¸­æ²¡æœ‰Exceptionè¿™ä¸ªæ¦‚å¿µï¼Œè€Œæ˜¯æŠŠé”™è¯¯åˆ†ä¸ºäº†ä¸¤ç§ï¼Œä¸€ç§æ˜¯å¯æ¢å¤çš„é”™è¯¯ï¼Œä¸€ç§æ˜¯ä¸å¯æ¢å¤çš„é”™è¯¯\nå¯¹äºå¯æ¢å¤çš„é”™è¯¯ä½¿ç”¨Result\u0026lt;T,E\u0026gt;ç±»å‹æ¥å°è£…ï¼Œä¸å¯æ¢å¤çš„é”™è¯¯ç±»å‹ä½¿ç”¨panic!æ¥å®šä¹‰ï¼›\nå¯¹äºä¸å¯æ¢å¤çš„panic!é”™è¯¯ï¼ŒRustæœ‰ä¸¤ç§å¤„ç†æƒ…å†µï¼Œ ä¸€ç§æ˜¯æ¸…ç†ç¨‹åºè¿è¡Œæ—¶äº§ç”Ÿçš„â€˜åƒåœ¾æ•°æ®â€™ï¼ˆè¿™ç§æ–¹æ³•éœ€è¦èŠ±è´¹ä¸€äº›æ—¶é—´è¿˜ä¼šå¯¼è‡´æ‰“åŒ…çš„åº”ç”¨å˜å¤§ï¼‰ï¼Œ ä¸€ç§æ˜¯ä»€ä¹ˆéƒ½ä¸åšï¼Œè®©æ“ä½œç³»ç»Ÿæ¥å¤„ç†ï¼ˆè¿™ç§æ–¹æ³•ä¼šé©¬ä¸Šé€€å‡ºï¼Œå¹¶ä¸”æ‰“åŒ…å‡ºæ¥çš„åŒ…ä¼šå¾ˆå°ï¼‰\nå¯ä»¥åœ¨Cargo.tomlæ–‡ä»¶ä¸­å®šä¹‰[profile]æ¥å†³å®šä½¿ç”¨å“ªä¸€ç§æ–¹å¼ï¼š\n[profile.release] panic = 'abort'  æœ‰æ—¶å€™panic!æ‰“å°çš„æŠ¥é”™ä¿¡æ¯å¹¶ä¸æ˜¯é‚£ä¹ˆçš„æ¸…æ™°æ˜äº†ï¼Œä¸åƒJavaä¸­çš„æ‰“å°ä¿¡æ¯ä¸€æ ·ï¼›ä¸ºäº†èƒ½å¤Ÿçœ‹åˆ°æ›´å¤šçš„é”™è¯¯æ ˆä¿¡æ¯ï¼Œå¯ä»¥é€šè¿‡è®¾ç½®ä¸€ä¸ªå‚æ•°æ¥æ‰“å°é”™è¯¯æ ˆ\n run with RUST_BACKTRACE=1 environment variable to display a backtrace.\n å¯¹äºå¯æ¢å¤çš„é”™è¯¯ç±»å‹ä½¿ç”¨Result\u0026lt;T,E\u0026gt;å°è£…çš„\n#![allow(unused_variables)] fn main() { enum Result\u0026lt;T, E\u0026gt; { Ok(T), Err(E), } }  Rustä¸­çš„é”™è¯¯å¤„ç†å†é…åˆä¸Šæ¨¡å¼åŒ¹é…çœŸçš„è¿˜æŒºå¥½ç”¨çš„ï¼Œç±»ä¼¼ä¸Javaä¸­çš„try-catchä½†æ˜¯æ›´åŠ å¼ºå¤§\nuse std::fs::File; use std::io::ErrorKind; fn main() { let f = File::open(\u0026quot;hello.txt\u0026quot;); let f = match f { Ok(file) =\u0026gt; file, Err(error) =\u0026gt; match error.kind() { ErrorKind::NotFound =\u0026gt; match File::create(\u0026quot;hello.txt\u0026quot;) { Ok(fc) =\u0026gt; fc, Err(e) =\u0026gt; panic!(\u0026quot;Problem creating the file: {:?}\u0026quot;, e), }, other_error =\u0026gt; { panic!(\u0026quot;Problem opening the file: {:?}\u0026quot;, other_error) } }, }; }  å¯ä»¥ä½¿ç”¨ç±»ä¼¼lamdaè¡¨è¾¾å¼çš„ä¸œè¥¿ï¼Œå¯ä»¥å†™çš„æ›´åŠ ç®€æ´\nuse std::fs::File; use std::io::ErrorKind; fn main() { let f = File::open(\u0026quot;hello.txt\u0026quot;).unwrap_or_else(|error| { if error.kind() == ErrorKind::NotFound { File::create(\u0026quot;hello.txt\u0026quot;).unwrap_or_else(|error| { panic!(\u0026quot;Problem creating the file: {:?}\u0026quot;, error); }) } else { panic!(\u0026quot;Problem opening the file: {:?}\u0026quot;, error); } }); }  Resulst\u0026lt;T,E\u0026gt;ç±»å‹æœ‰å¾ˆå¤šçš„APIç±»å‹Javaçš„Streamå’ŒOptionalä¸€æ ·ï¼›\nOptional.orElseThrow()  use std::fs::File; fn main() { let f = File::open(\u0026quot;hello.txt\u0026quot;).unwrap(); }  Optional.orElseThrow(()-\u0026gt;new Exception(\u0026quot;Failed to open hello.txt\u0026quot;))  use std::fs::File; fn main() { let f = File::open(\u0026quot;hello.txt\u0026quot;).expect(\u0026quot;Failed to open hello.txt\u0026quot;); }  #![allow(unused_variables)] fn main() { use std::fs::File; use std::io; use std::io::Read; fn read_username_from_file() -\u0026gt; Result\u0026lt;String, io::Error\u0026gt; { let f = File::open(\u0026quot;hello.txt\u0026quot;); let mut f = match f { Ok(file) =\u0026gt; file, Err(e) =\u0026gt; return Err(e), }; let mut s = String::new(); match f.read_to_string(\u0026amp;mut s) { Ok(_) =\u0026gt; Ok(s), Err(e) =\u0026gt; Err(e), } } }  ä¸Šè¿°çš„ä»£ç å¯ä»¥ä½¿ç”¨è¯­æ³•ç³–?æ“ä½œç¬¦æ¥ç®€åŒ–\n#![allow(unused_variables)] fn main() { use std::fs::File; use std::io; use std::io::Read; fn read_username_from_file() -\u0026gt; Result\u0026lt;String, io::Error\u0026gt; { let mut f = File::open(\u0026quot;hello.txt\u0026quot;)?; let mut s = String::new(); f.read_to_string(\u0026amp;mut s)?; Ok(s) } }  è¿˜å¯ä»¥æ›´ç®€åŒ–ä¸€ç‚¹\n#![allow(unused_variables)] fn main() { use std::fs::File; use std::io; use std::io::Read; fn read_username_from_file() -\u0026gt; Result\u0026lt;String, io::Error\u0026gt; { let mut s = String::new(); File::open(\u0026quot;hello.txt\u0026quot;)?.read_to_string(\u0026amp;mut s)?; Ok(s) } }  ç„¶åæ›´ç®€å•\nuse std::fs; fn main() { let s = fs::read_to_string(\u0026quot;C:\\\\Users\\\\Joe\\\\IdeaProjects\\\\rust-test\\\\src\\\\main.rs\u0026quot;).unwrap(); println!(\u0026quot;{}\u0026quot;,s) }  ?æ“ä½œç¬¦åªè¢«å…è®¸æ˜¯ç”¨æ¥å‡½æ•°ä¸­è¿”å›å€¼ç±»å‹æ˜¯Resultæˆ–è€…Optionæˆ–è€…å®ç°äº† std::ops::Try çš„ç±»å‹ã€‚\né”™è¯¯å¤„ç†çœ‹èµ·æ¥æŒºæ£’çš„ã€‚\nå®Œï¼\n","id":6,"section":"posts","summary":"Rustä¸­çš„é”™è¯¯å¤„ç† Rustä¸­æ²¡æœ‰Exceptionè¿™ä¸ªæ¦‚å¿µï¼Œè€Œæ˜¯æŠŠé”™è¯¯åˆ†ä¸ºäº†ä¸¤ç§ï¼Œä¸€ç§æ˜¯å¯æ¢å¤çš„é”™è¯¯ï¼Œä¸€ç§æ˜¯ä¸å¯æ¢å¤çš„é”™è¯¯ å¯¹äºå¯æ¢å¤çš„é”™è¯¯","tags":["programing","rust"],"title":"Rust Error","uri":"https://holicc.github.io/2020/07/rust-error/","year":"2020"},{"content":"Rustä¸­çš„é›†åˆç±»å‹ Rustçš„æ ‡å‡†åº“ä¸­æä¾›äº†å¸¸ç”¨çš„é›†åˆç±»å‹ï¼šVect(ç›¸å½“äºJavaä¸­çš„List)ï¼ŒMap(ç›¸å½“äºJavaä¸­çš„Map)ï¼Œåœ¨ä½¿ç”¨è¿™äº›é›†åˆçš„è¿‡ç¨‹ä¸­éœ€è¦æ³¨æ„çš„æ˜¯ Ownershipå’Œlet \u0026amp; let mutçš„ä¸€äº›æ³¨æ„äº‹é¡¹\nä½¿ç”¨Vectç›´æ¥ä½¿ç”¨å‡½æ•°åˆ›å»ºæˆ–è€…ä½¿ç”¨å®\nlet v: Vec\u0026lt;i32\u0026gt; = Vec::new(); //let c = Vec![1,2,3,4];  å¯ä»¥çœ‹åˆ°Vecæ˜¯ä¸€ä¸ªæ”¯æŒæ³›å‹çš„é›†åˆç±»å‹ï¼Œåœ¨åˆ›å»ºçš„æ—¶å€™éœ€è¦æŒ‡å®šå…¶å†…éƒ¨å…ƒç´ çš„å…·ä½“ç±»å‹ï¼›\nä½¿ç”¨mutå®šä¹‰Vectorå°±å¯ä»¥å¯¹å®ƒè¿›è¡Œä¿®æ”¹\nlet mut v = Vec::new(); v.push(5); v.push(6); v.push(7); v.push(8);  å½“ç„¶äº†æ ¹æ®ä»»ä½•å˜é‡éƒ½æœ‰å…¶ä½œç”¨åŸŸï¼ˆScopeï¼‰å¦‚æœä¸åœ¨ä½œç”¨åŸŸä¸­äº†å°±ä¼šè¢«é‡Šæ”¾æ‰ï¼Œå¹¶ä¸”Vectorä¸­çš„å…ƒç´ ä¹Ÿä¼šç›¸åº”çš„è¢«é‡Šæ”¾æ‰\n{ let v = vec![1, 2, 3, 4]; // do stuff with v } // \u0026lt;- v goes out of scope and is freed here  rustä¸­è®¿é—®Vectorå…ƒç´ æœ‰ä¸¤ç§æ–¹æ³•ä¸€ç§æ˜¯ä½¿ç”¨ä¸‹æ ‡è®¿é—®ä¸€ç§æ˜¯ä½¿ç”¨getæ–¹æ³•ï¼š\nfn main() { let v = vec![1, 2, 3, 4, 5]; let third: \u0026amp;i32 = \u0026amp;v[2]; println!(\u0026quot;The third element is {}\u0026quot;, third); match v.get(2) { Some(third) =\u0026gt; println!(\u0026quot;The third element is {}\u0026quot;, third), None =\u0026gt; println!(\u0026quot;There is no third element.\u0026quot;), } }  åŒºåˆ«åœ¨äºgetæ–¹æ³•æ˜¯ç©ºå®‰å…¨çš„ï¼Œè¿”å›çš„æ˜¯ä¸€ä¸ªOption\u0026lt;\u0026amp;T\u0026gt;ç±»å‹ï¼Œå°±æ˜¯è¯´å¦‚æœgetçš„ä¸€ä¸ªä¸å­˜åœ¨vectorä¸­çš„å…ƒç´ åªä¼šè¿”å›ä¸€ä¸ªOption\u0026lt;None\u0026gt;,è€Œä½¿ç”¨\n\u0026amp;[]ä¸‹æ ‡è®¿é—®ä¼španicï¼Œå› ä¸ºä½ è®¿é—®äº†ä¸€ä¸ªä¸å­˜åœ¨çš„å…ƒç´ ï¼›\nfn main() { let mut v = vec![1, 2, 3, 4, 5]; let first = \u0026amp;v[0]; v.push(6); println!(\u0026quot;The first element is: {}\u0026quot;, first); }  ä¸ºä»€ä¹ˆä»¥ä¸Šä»£ç æ— æ³•ç¼–è¯‘é€šè¿‡ï¼Œå¯ä»¥è¯´æ˜¯å……æ»¡äº†Rustçš„å“²å­¦ğŸ˜‚\n This error is due to the way vectors work: adding a new element onto the end of the vector might require allocating new memory and copying the old elements to the new space, if there isnâ€™t enough room to put all the elements next to each other where the vector currently is. In that case, the reference to the first element would be pointing to deallocated memory. The borrowing rules prevent programs from ending up in that situation.\n å®˜æ–¹è§£é‡Šè¯´è¿™è·ŸVectorçš„å®ç°æœºåˆ¶æœ‰å…³ï¼Œåœ¨å¾€Vectorä¸­æ·»åŠ æ–°çš„å…ƒç´ çš„æ—¶å€™å¯èƒ½ä¼šå› ä¸ºåŸå§‹ç©ºé—´ä¸å¤Ÿå®¹çº³è¿™ä¹ˆå¤šå…ƒç´ è€Œå¯¼è‡´å°†åŸæ¥çš„å…ƒç´ éƒ½æ‹·è´åˆ°ä¸€ä¸ªæ–°çš„åœ°æ–¹ï¼Œä»è€Œæ”¹å˜äº†å†…éƒ¨å…ƒç´ çš„æŒ‡é’ˆï¼Œå¦‚æœè¿™æ—¶æœ‰ä¸€ä¸ªå¤–éƒ¨å€Ÿç”¨çš„æŒ‡é’ˆè¿˜åœç•™åœ¨åŸå§‹çš„æœªçŸ¥å°±ä¼šé€ æˆå†…å­˜è®¿é—®ä¸æ­£ç¡®çš„é—®é¢˜ã€‚\nè¿­ä»£æ–¹å¼\nfn main() { let v = vec![100, 32, 57]; for i in \u0026amp;v { println!(\u0026quot;{}\u0026quot;, i); } for i in \u0026amp;mut v { *i += 50; //* è¡¨ç¤ºè§£å¼•ç”¨ } }  å®˜æ–¹æ–‡æ¡£ä¹Ÿè®²äº†ä¸€äº›Vectorçš„ä¸€äº›æŠ€å·§\nfn main() { enum SpreadsheetCell { Int(i32), Float(f64), Text(String), } let row = vec![ SpreadsheetCell::Int(3), SpreadsheetCell::Text(String::from(\u0026quot;blue\u0026quot;)), SpreadsheetCell::Float(10.12), ]; }  åœ¨Rustä¸­Stringä¹Ÿä½¿ç”¨é›†åˆç±»å‹å®ç°çš„ï¼Œåº•å±‚å°±æ˜¯ä¸€ä¸ªbytesé›†åˆï¼Œæ‰€ä»¥å®˜æ–¹ä¹Ÿæ”¾åˆ°äº†è¿™ä¸€ç« èŠ‚æ¥è®²ã€‚\nfn main() { let mut s = String::from(\u0026quot;foo\u0026quot;); s.push_str(\u0026quot;bar\u0026quot;); }  å¯¹äºå¦‚ä½•åœ¨Stringä¸­ä½¿ç”¨+ï¼Œè¿™ä¹Ÿæ˜¯ä¸€é—¨å­¦é—®\n This isnâ€™t the exact signature thatâ€™s in the standard library: in the standard library, add is defined using generics. Here, weâ€™re looking at the signature of add with concrete types substituted for the generic ones, which is what happens when we call this method with String values. Weâ€™ll discuss generics in Chapter 10. This signature gives us the clues we need to understand the tricky bits of the + operator.\nFirst, s2 has an \u0026amp;, meaning that weâ€™re adding a reference of the second string to the first string because of the s parameter in the add function: we can only add a \u0026amp;str to a String; we canâ€™t add two String values together. But waitâ€”the type of \u0026amp;s2 is \u0026amp;String, not \u0026amp;str, as specified in the second parameter to add. So why does Listing 8-18 compile?\nThe reason weâ€™re able to use \u0026amp;s2 in the call to add is that the compiler can coerce the \u0026amp;String argument into a \u0026amp;str. When we call the add method, Rust uses a deref coercion, which here turns \u0026amp;s2 into \u0026amp;s2[..]. Weâ€™ll discuss deref coercion in more depth in Chapter 15. Because add does not take ownership of the s parameter, s2 will still be a valid String after this operation.\nSecond, we can see in the signature that add takes ownership of self, because self does not have an \u0026amp;. This means s1 in Listing 8-18 will be moved into the add call and no longer be valid after that. So although let s3 = s1 + \u0002 looks like it will copy both strings and create a new one, this statement actually takes ownership of s1, appends a copy of the contents of s2, and then returns ownership of the result. In other words, it looks like itâ€™s making a lot of copies but isnâ€™t; the implementation is more efficient than copying.\n å®˜æ–¹ç”¨äº†å¾ˆé•¿ä¸€æ®µæ¥è¯´æ˜å¦‚ä½•å¯¹Stringç±»å‹æ¥ä½¿ç”¨+å·ï¼Œæ€»ç»“ä¸€ä¸‹å°±æ˜¯+å…¶å®æ˜¯å°±æ˜¯Stringçš„addæ–¹æ³•\nçœ‹ä¸€ä¸‹æ–¹æ³•ç­¾å\nfn add(self, s: \u0026amp;str) -\u0026gt; String  æ¥å—çš„å¯¹è±¡æ˜¯ä¸€ä¸ª\u0026amp;str,æ‰€ä»¥åœ¨ä½¿ç”¨çš„æ—¶å€™å¯ä»¥æ˜¯\nlet a = String::from(\u0026quot;test\u0026quot;); let b = a + \u0026quot;zxc\u0026quot;;  ä¹Ÿå¯ä»¥æ˜¯\nlet a = String::from(\u0026quot;test\u0026quot;); let b = String::from(\u0026quot;hello\u0026quot;); let c = a + \u0026amp;b  è¿™é‡Œçš„\u0026amp;bæ˜¯ä¸€ä¸ª\u0026amp;Stringä¼šè¢«å¼ºè½¬ä¸ºä¸€ä¸ª \u0026amp;strç±»å‹ã€‚\nStringç±»å‹ä¹Ÿä¸æ”¯æŒä¸‹æ ‡è®¿é—®ï¼Œï¼ˆå¯¹Javaç¨‹åºå‘˜æ¥è¯´å¾ˆOKï¼‰\næœ€åå®˜æ–¹è¯´äº†ä¸€å¥è®©äººæ— è¯­çš„è¯\n To summarize, strings are complicated. Different programming languages make different choices about how to present this complexity to the programmer. Rust has chosen to make the correct handling of String data the default behavior for all Rust programs, which means programmers have to put more thought into handling UTF-8 data upfront. This trade-off exposes more of the complexity of strings than is apparent in other programming languages, but it prevents you from having to handle errors involving non-ASCII characters later in your development life cycle.\n å¥½å§ï¼Œä¸‹ä¸€ä¸ªæ˜¯HashMap\nfn main() { use std::collections::HashMap; let mut scores = HashMap::new(); scores.insert(String::from(\u0026quot;Blue\u0026quot;), 10); scores.insert(String::from(\u0026quot;Yellow\u0026quot;), 50); }  å¯¹äºéæ‹·è´çš„å€¼ä¾‹å¦‚Stringç±»å‹ï¼Œå¦‚æœæŠŠå€¼insertåˆ°mapä¸­å°±æ˜¯å¯¹è¿™ä¸ªå€¼æ‰€æœ‰æƒçš„è½¬ç§»åˆ°mapä¸­äº†ï¼›\nfn main() { use std::collections::HashMap; let field_name = String::from(\u0026quot;Favorite color\u0026quot;); let field_value = String::from(\u0026quot;Blue\u0026quot;); let mut map = HashMap::new(); map.insert(field_name, field_value); // field_name and field_value are invalid at this point, try using them and // see what compiler error you get! }  å¦‚ä½•è¿­ä»£ï¼Œå¾ˆå¥½ç†è§£\nfn main() { use std::collections::HashMap; let mut scores = HashMap::new(); scores.insert(String::from(\u0026quot;Blue\u0026quot;), 10); scores.insert(String::from(\u0026quot;Yellow\u0026quot;), 50); for (key, value) in \u0026amp;scores { println!(\u0026quot;{}: {}\u0026quot;, key, value); } }  ä¸€äº›apiä»‹ç»\nfn main() { use std::collections::HashMap; let mut scores = HashMap::new(); scores.insert(String::from(\u0026quot;Blue\u0026quot;), 10); scores.entry(String::from(\u0026quot;Yellow\u0026quot;)).or_insert(50); scores.entry(String::from(\u0026quot;Blue\u0026quot;)).or_insert(50); println!(\u0026quot;{:?}\u0026quot;, scores); }  ç›¸å½“äºJavaä¸­çš„map.putIfAbsent\nå…¶ä»–çš„å°±ä¸èµ˜è¿°äº†ï¼Œå°±æ˜¯äº†è§£ä¸€ä¸‹Rustä¸­çš„é›†åˆ\nå®Œï¼\n","id":7,"section":"posts","summary":"Rustä¸­çš„é›†åˆç±»å‹ Rustçš„æ ‡å‡†åº“ä¸­æä¾›äº†å¸¸ç”¨çš„é›†åˆç±»å‹ï¼šVect(ç›¸å½“äºJavaä¸­çš„List)ï¼ŒMap(ç›¸å½“äºJavaä¸­çš„Map)ï¼Œåœ¨ä½¿","tags":["programing","rust"],"title":"Rust Collections","uri":"https://holicc.github.io/2020/07/rust-collections/","year":"2020"},{"content":"RocketMQæœåŠ¡éƒ¨ç½²æƒ…å†µä»‹ç» ç”±äºé¡¹ç›®å¯¹æ¶ˆæ¯çš„å¯é æ€§è¦æ±‚æ¯”è¾ƒé«˜æ‰€ä»¥é‡‡ç”¨çš„æ˜¯SYNC_MASTER+SLAVEçš„éƒ¨ç½²æ–¹å¼, å¹¶ä¸”ä½¿ç”¨äº†ASYNC_FLUSHï¼ˆåŒæ­¥åˆ·æ–°ï¼‰æœºåˆ¶ï¼Œè™½ç„¶MasterèŠ‚ç‚¹å®•æœºçš„æ—¶å€™ä¼šä¸¢å¤±ä¸€éƒ¨åˆ†çš„æ¶ˆæ¯æ•°æ®ï¼Œä½†æ˜¯æ€§èƒ½ä¸Šæ˜¯å¾ˆå¤§çš„æå‡ï¼›\næ ¹æ®å®˜æ–¹è¯´æ˜çš„ä¼˜ç¼ºç‚¹ï¼š\n ä¼˜ç‚¹ï¼šæ•°æ®ä¸æœåŠ¡éƒ½æ— å•ç‚¹æ•…éšœï¼ŒMasterå®•æœºæƒ…å†µä¸‹ï¼Œæ¶ˆæ¯æ— å»¶è¿Ÿï¼ŒæœåŠ¡å¯ç”¨æ€§ä¸æ•°æ®å¯ç”¨æ€§éƒ½éå¸¸é«˜ï¼› ç¼ºç‚¹ï¼šæ€§èƒ½æ¯”å¼‚æ­¥å¤åˆ¶æ¨¡å¼ç•¥ä½ï¼ˆå¤§çº¦ä½10%å·¦å³ï¼‰ï¼Œå‘é€å•ä¸ªæ¶ˆæ¯çš„RTä¼šç•¥é«˜ï¼Œä¸”ç›®å‰ç‰ˆæœ¬åœ¨ä¸»èŠ‚ç‚¹å®•æœºåï¼Œå¤‡æœºä¸èƒ½è‡ªåŠ¨åˆ‡æ¢ä¸ºä¸»æœºï¼ˆé’ˆå¯¹4.5ä»¥å‰çš„ç‰ˆæœ¬ï¼‰ã€‚  ç”±äºæˆ‘ä»¬ä½¿ç”¨çš„æ˜¯4.7.0ç‰ˆæœ¬å·²ç»ä½¿ç”¨äº†raft åè®®è§£å†³äº†è¿™ä¸ªé—®é¢˜ã€‚å¦‚æœè¦ä½¿é›†ç¾¤èƒ½å¤Ÿè‡ªåŠ¨å®¹ç¾åˆ‡æ¢ï¼Œéœ€è¦è‡³å°‘ä¸‰å°æœºå™¨\næˆ‘ä»¬ä¸€å…±æœ‰4å°æœºå™¨ï¼Œæ¯å°æœºå™¨çš„é…ç½®ï¼š\n32gå†…å­˜ï¼Œ2Tçš„ç¡¬ç›˜ï¼Œ8æ ¸CPU  ä¸€å°æœºå™¨ä½œä¸ºnameserverï¼Œå…¶ä½™éƒ½æ˜¯brokerï¼Œbrokerä¹‹é—´å¯ä»¥è¿›è¡Œè‡ªåŠ¨é€‰ä¸¾masterèŠ‚ç‚¹\néƒ¨ç½²æƒ…å†µï¼š\n\né…ç½®æ–‡ä»¶ç¼–å†™æƒ…å†µï¼š\n#æ‰€å±é›†ç¾¤åå­— brokerClusterName=RaftCluster brokerName=RaftNode00 ## å¯ç”¨DLeger enableDLegerCommitLog=true dLegerGroup=RaftNode00 dLegerPeers=n0-127.0.0.1:40911;n1-127.0.0.1:40912;n2-127.0.0.1:40913 dLegerSelfId=n0 #0 è¡¨ç¤º Masterï¼Œ\u0026gt;0 è¡¨ç¤º Slave brokerId=0 #nameServeråœ°å€ï¼Œåˆ†å·åˆ†å‰² namesrvAddr=rocketmq-nameserver-0:9876 autoCreateTopicEnable=false autoCreateSubscriptionGroup=false #Broker å¯¹å¤–æœåŠ¡çš„ç›‘å¬ç«¯å£ï¼Œ10911ä¸ºé»˜è®¤å€¼ listenPort=10911 #è¡¨ç¤ºMasterç›‘å¬Slaveè¯·æ±‚çš„ç«¯å£,é»˜è®¤ä¸ºæœåŠ¡ç«¯å£+1 haListenPort=10912 #- SLAVE brokerRole=ASYNC_MASTER #åˆ·ç›˜æ–¹å¼ flushDiskType=ASYNC_FLUSH  RocketMQæ¶ˆè´¹ç«¯è®¾ç½®æƒ…å†µ Consumerä½¿ç”¨çš„æ˜¯å…¬å¸å°è£…çš„æ‰€ä»¥èƒ½å¤Ÿé…ç½®çš„å‚æ•°æœ‰é™ï¼Œé€šè¿‡é˜…è¯»å°è£…çš„ä»£ç å‘ç°ï¼Œ\nconsumeMessageBatchMaxSize=10ä¸€æ‰¹æ¬¡å¯ä»¥å¤„ç†10æ¡æ•°æ® setConsumeThreadMin=3åé¢ä¿®æ”¹ä¸ºäº†CPUæ ¸å¿ƒæ•° setConsumeThreadMax=3åé¢ä¿®æ”¹ä¸ºäº†CPUæ ¸å¿ƒæ•° setMessageModel=MessageModel.CLUSTERING é›†ç¾¤æ¨¡å¼ setConsumeFromWhere=ConsumeFromWhere.CONSUME_FROM_LAST_OFFSET æ¥ç€ä¸Šæ¬¡æ¶ˆè´¹çš„è¿›åº¦å¼€å§‹æ¶ˆè´¹\nå…¶ä½™çš„å‚æ•°éƒ½æ²¡æœ‰è¿›è¡Œæ”¹åŠ¨\nRocketMQæ¶ˆæ¯å †ç§¯äº†å¦‚ä½•è§£å†³ åŸå› ï¼šæ¶ˆè´¹æœåŠ¡å¤ªæ…¢å¯¼è‡´æ¶ˆæ¯å †ç§¯ï¼›\nè¿™é‡Œçš„å †ç§¯æŒ‡çš„æ˜¯Consumeræ‹‰å–çš„æ¶ˆæ¯æ¶ˆè´¹ä¸è¿‡æ¥äº†å¯¼è‡´çš„å †ç§¯\næˆ‘ä»¬çš„ç³»ç»Ÿä¸­ä½¿ç”¨çš„æ˜¯PUSHçš„æ¶ˆè´¹æ¨¡å¼ï¼Œæœ¬è´¨ä¸Šæ˜¯ä½¿ç”¨PULLä¸æ–­çš„å‘Brokeræ‹‰å–æ¶ˆæ¯æœºåˆ¶çš„å°è£…ã€‚\nè§£å†³åŠæ³•ï¼š\n å…ˆä¿®å¤ consumer çš„é—®é¢˜ï¼Œç¡®ä¿å…¶æ¢å¤æ¶ˆè´¹é€Ÿåº¦ï¼Œç„¶åå°†ç°æœ‰ consumer éƒ½åœæ‰ã€‚ï¼ˆå› ä¸ºå†å²æ•°æ®ç§¯å‹å¤ªå¤šï¼ŒçŸ­æ—¶é—´å†…æ— æ³•æ¶ˆè´¹å®Œï¼‰ å»ºç«‹æ–°çš„topicï¼Œä¸´æ—¶å»ºç«‹å¥½åŸå…ˆ 10 å€çš„ queue æ•°é‡ã€‚ ç„¶åå†™ä¸€ä¸ªä¸´æ—¶çš„åˆ†å‘æ•°æ®çš„ consumer ç¨‹åºï¼Œè¿™ä¸ªç¨‹åºéƒ¨ç½²ä¸Šå»æ¶ˆè´¹ç§¯å‹çš„æ•°æ®ï¼Œæ¶ˆè´¹ä¹‹åä¸åšè€—æ—¶çš„å¤„ç†ï¼Œç›´æ¥å‡åŒ€è½®è¯¢å†™å…¥ä¸´æ—¶å»ºç«‹å¥½çš„ 10 å€æ•°é‡çš„ queue æ¥ç€ä¸´æ—¶å¾æ‰©å®¹æœºå™¨æœºå™¨æ¥éƒ¨ç½² consumerï¼Œæ¯ä¸€æ‰¹ consumer æ¶ˆè´¹ä¸€ä¸ªä¸´æ—¶ queue çš„æ•°æ®ã€‚ ç­‰å¿«é€Ÿæ¶ˆè´¹å®Œç§¯å‹æ•°æ®ä¹‹åï¼Œå¾—æ¢å¤åŸå…ˆéƒ¨ç½²çš„æ¶æ„ï¼Œé‡æ–°ç”¨åŸå…ˆçš„ consumer æœºå™¨æ¥æ¶ˆè´¹æ¶ˆæ¯ã€‚  ","id":8,"section":"posts","summary":"RocketMQæœåŠ¡éƒ¨ç½²æƒ…å†µä»‹ç» ç”±äºé¡¹ç›®å¯¹æ¶ˆæ¯çš„å¯é æ€§è¦æ±‚æ¯”è¾ƒé«˜æ‰€ä»¥é‡‡ç”¨çš„æ˜¯SYNC_MASTER+SLAVEçš„éƒ¨ç½²æ–¹å¼, å¹¶ä¸”ä½¿ç”¨äº†ASYN","tags":["programing","rocketMQ"],"title":"Rust Function","uri":"https://holicc.github.io/2020/07/rocketmq-overstock/","year":"2020"},{"content":"Rust Packages Crates and Modules æ¯ä¸ªæ–°å‡ºçš„ç¼–ç¨‹è¯­è¨€éƒ½æœ‰ä¸€å¥—å¯¹åº”çš„åŒ…ç®¡ç†å·¥å…·ï¼ŒRustä¹Ÿä¸åˆ—å¤–ï¼ŒRustä½¿ç”¨çš„æ˜¯cargoä½œä¸ºå…¶åŒ…ç®¡ç†å·¥å…·ï¼›\ncrateæ˜¯ä¸€ä¸ªå•ä¸€çš„åº“çš„æ„æ€;\n A crate is a binary or library. The crate root is a source file that the Rust compiler starts from and makes up the root module of your crate\n packageæ˜¯ä¸€ä¸ªåŒ…çš„æ„æ€ï¼Œä¸€ä¸ªåŒ…å¯ä»¥åŒ…å«æœ‰å¤šä¸ªcrate; å…¶ä¸­åŒ…å«ä¸€ä¸ª Cargo.tomlæ–‡ä»¶ï¼Œè¿™ä¸ªæ–‡ä»¶ç›¸å½“äºmavené¡¹ç›®ä¸­çš„pom.xmlæ–‡ä»¶ä¸€æ ·çš„åŠŸèƒ½ï¼›\n A package is one or more crates that provide a set of functionality. A package contains a Cargo.toml file that describes how to build those crates.\n æ¨¡å—ç®¡ç†ï¼Œé€šè¿‡ä½¿ç”¨moduleæ¥ç®¡ç†å‡½æ•°ï¼Œæ˜¯å‡½æ•°èƒ½å¤Ÿåˆ†åˆ°å¯¹åº”çš„æ¨¡å—ä¸­ï¼Œå¹¶å†å…¶ä»–åœ°æ–¹èƒ½å¤Ÿä½¿ç”¨ä»–ä»¬ï¼›æœ‰ç‚¹ç±»ä¼¼Javaçš„åŒ…ç©ºé—´ï¼›\nmod front_of_house { mod hosting { fn add_to_waitlist() {} fn seat_at_table() {} } mod serving { fn take_order() {} fn serve_order() {} fn take_payment() {} } }  çœ‹äº†ä¸Šé¢çš„ä¾‹å­æˆ‘å‘ç°ï¼ŒRustä¸­çš„å…³é”®å­—å®šä¹‰éƒ½ä½¿ç”¨æ˜¯ä¸‰ä¸ªå­—æ¯....\nåœ¨Rustä¸­crateåˆ†ä¸ºbinaryå’Œlibrary,binaryæ–‡ä»¶å°±æ˜¯å¯¹åº”çš„main.rsè€Œlibraryå¯¹åº”çš„æ˜¯lib.rs ä»–ä»¬éƒ½æ˜¯crate roots\nå¼•å…¥å¹¶ä½¿ç”¨æ¨¡å—ä¸­çš„å‡½æ•°ï¼Œä½¿ç”¨çš„æ˜¯pathsæ¥å®šä¹‰,å¯ä»¥ä½¿ç”¨ç»å¯¹è·¯å¾„å’Œç›¸å¯¹è·¯å¾„ï¼›\nmod front_of_house { mod hosting { fn add_to_waitlist() {} } } pub fn eat_at_restaurant() { // Absolute path crate::front_of_house::hosting::add_to_waitlist(); // Relative path front_of_house::hosting::add_to_waitlist(); }  pubå…³é”®å­—ç”¨æ¥æä¾›å‡½æ•°çš„è®¿é—®æƒé™ï¼Œç›¸å½“ä¸Javaä¸­çš„public\\private\\proctect\nsuperå…³é”®å­—ç±»ä¼¼ä¸ç›¸å¯¹è·¯å¾„çš„åŠŸèƒ½,æœ‰å•¥åŒºåˆ«å‘¢ï¼Ÿä¸çŸ¥é“ã€‚ã€‚ã€‚\nfn serve_order() {} mod back_of_house { fn fix_incorrect_order() { cook_order(); super::serve_order(); } fn cook_order() {} }  å¥½äº†ä¸‹é¢ä»‹ç»ä¸€ä¸‹importå…³é”®å­—ï¼Œå‘¸ï¼Œæ˜¯use\nmod front_of_house { pub mod hosting { pub fn add_to_waitlist() {} } } use crate::front_of_house::hosting::add_to_waitlist; pub fn eat_at_restaurant() { add_to_waitlist(); add_to_waitlist(); add_to_waitlist(); }  21ä¸–çºªçš„ç¼–ç¨‹è¯­è¨€éƒ½å¸¦æœ‰å¼•åŒ…åˆ«åçš„åŠŸèƒ½ as\n#![allow(unused_variables)] fn main() { use std::fmt::Result; use std::io::Result as IoResult; fn function1() -\u0026gt; Result { // --snip-- Ok(()) } fn function2() -\u0026gt; IoResult\u0026lt;()\u0026gt; { // --snip-- Ok(()) } }  è¿˜å¯ä»¥Re-exporting é€šè¿‡ä½¿ç”¨ pub use\nmod front_of_house { pub mod hosting { pub fn add_to_waitlist() {} } } pub use crate::front_of_house::hosting; pub fn eat_at_restaurant() { hosting::add_to_waitlist(); hosting::add_to_waitlist(); hosting::add_to_waitlist(); }  ä¸æ˜¯å¾ˆæ˜ç™½è®¾è®¡äº†è¿™ä¹ˆå¤šï¼Œæå¾—æœ‰ç‚¹å¤æ‚ï¼Œæ˜¯ä¸æ˜¯å› ä¸ºæœ¬èº«é—®é¢˜å¾ˆå¤šéœ€è¦å¼•å…¥è¿™ä¹ˆå¤šæŠ€æœ¯æ¥è§£å†³å‘¢ï¼Ÿ\nå®Œï¼\n","id":9,"section":"posts","summary":"Rust Packages Crates and Modules æ¯ä¸ªæ–°å‡ºçš„ç¼–ç¨‹è¯­è¨€éƒ½æœ‰ä¸€å¥—å¯¹åº”çš„åŒ…ç®¡ç†å·¥å…·ï¼ŒRustä¹Ÿä¸åˆ—å¤–ï¼ŒRustä½¿ç”¨çš„æ˜¯cargoä½œä¸ºå…¶åŒ…ç®¡ç†å·¥å…·ï¼› crateæ˜¯ä¸€ä¸ªå•ä¸€çš„åº“","tags":["programing","rust"],"title":"Rust Packages Management","uri":"https://holicc.github.io/2020/07/rust-packages-management/","year":"2020"},{"content":"Rustä¸­çš„æšä¸¾ enumæšä¸¾ç±»å‹ï¼Œä¸€ç§ç†Ÿæ‚‰çš„æ•°æ®ç»“æ„ï¼Œåœ¨Javaä¸­ä¹Ÿæœ‰å¯¹åº”çš„ç±»å‹ï¼Œå°±ä¸èµ˜è¿°äº†.\nfn main() { enum IpAddrKind { V4, V6, } struct IpAddr { kind: IpAddrKind, address: String, } let home = IpAddr { kind: IpAddrKind::V4, address: String::from(\u0026quot;127.0.0.1\u0026quot;), }; let loopback = IpAddr { kind: IpAddrKind::V6, address: String::from(\u0026quot;::1\u0026quot;), }; }  æšä¸¾ç±»ä¸­ä¹Ÿå¯ä»¥æœ‰æˆå‘˜å˜é‡\nfn main() { enum IpAddr { V4(String), V6(String), } let home = IpAddr::V4(String::from(\u0026quot;127.0.0.1\u0026quot;)); let loopback = IpAddr::V6(String::from(\u0026quot;::1\u0026quot;)); }  ä¸ä»…å¦‚æ­¤ï¼Œæšä¸¾ç±»ä¸­çš„æˆå‘˜è¿˜å¯ä»¥æ‹¥æœ‰ä¸åŒçš„ç±»å‹ï¼›\nfn main() { enum IpAddr { V4(u8, u8, u8, u8), V6(String), } let home = IpAddr::V4(127, 0, 0, 1); let loopback = IpAddr::V6(String::from(\u0026quot;::1\u0026quot;)); }  ç”šè‡³è¿˜å¯ä»¥æ”¾ç½®åŒ¿åç»“æ„ä½“\nenum Message { Quit, Move { x: i32, y: i32 }, Write(String), ChangeColor(i32, i32, i32), }  å…¶ä¸­çš„Moveå°±æ˜¯å®šä¹‰çš„åŒ¿åç»“æ„ä½“.\nåé¢å°±è®²äº†ä¸€ä¸‹Option,è¿™ä¸ªJava1.8ä»¥åä¹Ÿæœ‰çš„ä¸œè¥¿ï¼Œæ‰€ä»¥è¿˜æ˜¯å¾ˆç†Ÿæ‚‰çš„ï¼Œåªæ˜¯åœ¨Rustä¸­å®ƒä½¿ç”¨ä¸€ä¸ªæšä¸¾ç±»å‹ï¼›\nç”¨æ³•å’ŒJavaéƒ½ç±»ä¼¼çš„.\nrustç‰ˆæœ¬\nfn main() { let a: Option\u0026lt;i32\u0026gt; = None; let c = a.expect(\u0026quot;error message \u0026quot;); println!(\u0026quot;hello world {}\u0026quot;, c) }  javaç‰ˆæœ¬\nclass Scratch { public static void main(String[] args) throws Exception { String a=\u0026quot;asd\u0026quot;; Optional.ofNullable(a).orElseThrow(()-\u0026gt;new Exception(\u0026quot;zxc\u0026quot;)); } }  ç¥å¥‡çš„matchæ¨¡å¼åŒ¹é…ï¼Ÿå¯æƒœåœ¨Scalaä¸­å°±å·²ç»è§è¿‡äº†ï¼Œæ„Ÿè§‰æ²¡å•¥å¥½å­¦ä¹ çš„ã€‚\n#[derive(Debug)] enum UsState { Alabama, Alaska, // --snip-- } enum Coin { Penny, Nickel, Dime, Quarter(UsState), } fn value_in_cents(coin: Coin) -\u0026gt; u8 { match coin { Coin::Penny =\u0026gt; 1, Coin::Nickel =\u0026gt; 5, Coin::Dime =\u0026gt; 10, Coin::Quarter(state) =\u0026gt; { println!(\u0026quot;State quarter from {:?}!\u0026quot;, state); 25 } } } fn main() { value_in_cents(Coin::Quarter(UsState::Alaska)); }  æœ€åè¿™ä¸ªif letè¡¨è¾¾å¼è®©æˆ‘æœ‰ç‚¹æ‡µé€¼ï¼Œå’‹ä¸€çœ‹æ„Ÿè§‰æ²¡å•¥ç”¨å•Šã€‚\nfn main() { let some_u8_value = Some(0u8); match some_u8_value { Some(3) =\u0026gt; println!(\u0026quot;three\u0026quot;), _ =\u0026gt; (), } }  åŠ ä¸ªletæœ‰å•¥ç”¨å‘¢ï¼Ÿè¿˜ä¸å¦‚ç›´æ¥å†™æˆif-elseçš„å½¢å¼å°±è¡Œäº†å˜›ï¼Ÿ\nfn main() { let some_u8_value = Some(0u8); if let Some(3) = some_u8_value { println!(\u0026quot;three\u0026quot;); } }  å¯èƒ½ä¸ºäº†èƒ½å¤Ÿå°†å˜é‡ç»‘å®šåˆ°ä¸€ä¸ªç±»å‹é‡Œé¢æŠŠï¼Œå½¢å¦‚ï¼š\n#[derive(Debug)] enum UsState { Alabama, Alaska, // --snip-- } enum Coin { Penny, Nickel, Dime, Quarter(UsState), } fn main() { let coin = Coin::Penny; let mut count = 0; if let Coin::Quarter(state) = coin { println!(\u0026quot;State quarter from {:?}!\u0026quot;, state); } else { count += 1; } }  æ˜¯ä¸ºäº†ç®€åŒ–matchæ“ä½œè€Œåˆ›å»ºçš„è¯­æ³•ç³–.\nå®Œ!\n","id":10,"section":"posts","summary":"Rustä¸­çš„æšä¸¾ enumæšä¸¾ç±»å‹ï¼Œä¸€ç§ç†Ÿæ‚‰çš„æ•°æ®ç»“æ„ï¼Œåœ¨Javaä¸­ä¹Ÿæœ‰å¯¹åº”çš„ç±»å‹ï¼Œå°±ä¸èµ˜è¿°äº†. fn main() { enum IpAddrKind { V4, V6, } struct IpAddr { kind: IpAddrKind, address: String, } let home = IpAddr { kind:","tags":["programing","rust"],"title":"Rust Enums And Patter Match","uri":"https://holicc.github.io/2020/07/rust-enums-and-patter-match/","year":"2020"},{"content":"é€šè¿‡ä½¿ç”¨å…³é”®structå¯ä»¥å®šä¹‰ä¸€ä¸ªç±»ï¼Œå‘¸ï¼Œæ˜¯å®šä¹‰ä¸€ä¸ªç»“æ„ä½“ã€‚\nstruct User { username: String, email: String, sign_in_count: u64, active: bool, } fn main() { let user1 = User { email: String::from(\u0026quot;someone@example.com\u0026quot;), username: String::from(\u0026quot;someusername123\u0026quot;), active: true, sign_in_count: 1, }; }  structä¸Javaä¸­çš„ç±»æ˜¯ä¸åŒçš„ä¸¤ç§æ•°æ®ç»“æ„ï¼Œå…·ä½“çš„ä½¿ç”¨æ–¹å¼ä¹Ÿæœ‰æ‰€ä¸åŒã€‚\nfn build_user(email: String, username: String) -\u0026gt; User { User { email: email, username: username, active: true, sign_in_count: 1, } }  æœ‰ä¸€ä¸ªç®—æ˜¯è¯­æ³•ç³–çš„åŠŸèƒ½å°±æ˜¯,ç»“æ„ä½“å¤ç”¨;ä½¿ç”¨..ç¬¦å·èƒ½å¤Ÿå¤ç”¨ä¸€ä¸ªå·²ç»åˆ›å»ºå¥½çš„ç»“æ„ä¸­çš„å­—æ®µ;\nstruct User { username: String, email: String, sign_in_count: u64, active: bool, } fn main() { let user1 = User { email: String::from(\u0026quot;someone@example.com\u0026quot;), username: String::from(\u0026quot;someusername123\u0026quot;), active: true, sign_in_count: 1, }; let user2 = User { email: String::from(\u0026quot;another@example.com\u0026quot;), username: String::from(\u0026quot;anotherusername567\u0026quot;), ..user1 }; }  ä¹Ÿå¯ä»¥å®šä¹‰ä¸€ç§ç±»ä¼¼Javaä¸­Recordçš„æ•°æ®ç»“æ„\nfn main() { struct Color(i32, i32, i32); struct Point(i32, i32, i32); let black = Color(0, 0, 0); let origin = Point(0, 0, 0); }  çœ‹èµ·æ¥è™½ç„¶è·ŸGolangæ²¡ä»€ä¹ˆå¤ªå¤§çš„åŒºåˆ«,ä½†æ˜¯åŠ ä¸Šäº†æ‰€æœ‰æƒä¹‹åå°±æœ‰äº†ä¸€äº›é™åˆ¶;\nstruct User { username: \u0026amp;str, email: \u0026amp;str, sign_in_count: u64, active: bool, } fn main() { let user1 = User { email: \u0026quot;someone@example.com\u0026quot;, username: \u0026quot;someusername123\u0026quot;, active: true, sign_in_count: 1, }; }  è¿™æ˜¯Rustå›¢é˜Ÿæ·±æ€ç†Ÿè™‘è¿‡åçš„è®¾è®¡,ä¸ºäº†èƒ½å¤Ÿè®©structçš„å®ä¾‹èƒ½å¤Ÿæ‹¥æœ‰æˆå‘˜å˜é‡çš„æ‰€æœ‰æƒ\n In the User struct definition in Listing 5-1, we used the owned String type rather than the \u0026amp;str string slice type. This is a deliberate choice because we want instances of this struct to own all of its data and for that data to be valid for as long as the entire struct is valid.\n ä¸æ‡‚çš„æ˜¯ä¸ºä»€ä¹ˆè¿™é‡Œusernameä½¿ç”¨äº†\u0026amp;strå°±æ²¡æœ‰äº†usernameæˆå‘˜å˜é‡çš„æ‰€æœ‰æƒ?\néš¾é“æ˜¯å› ä¸º\u0026amp;stræ˜¯ä¸€ä¸ªsliceç±»å‹? sliceå°±æ˜¯ä¸€ä¸­æ²¡æœ‰æ‰€æœ‰æƒçš„æ•°æ®ç±»å‹.\n Another data type that does not have ownership is the slice\n å¥½åƒæ˜¯è¿™æ ·çš„,å¯ä»¥çš„,Rustå¼º(å¹)!\næƒ³è¦åƒåœ¨Javaä¸­ä¸€æ ·è‡ªç”±çš„æ‰“å°å¯¹è±¡,éœ€è¦åœ¨structä¸Šè¿›è¡Œä¸€äº›ç‰¹æ®Šå¤„ç†,ç›¸å½“äºéœ€è¦å®ç°ä¸€ä¸ªtoString()æ–¹æ³•ä¸€æ ·.\n#[derive(Debug)] struct Rectangle { width: u32, height: u32, } fn main() { let rect1 = Rectangle { width: 30, height: 50, }; println!(\u0026quot;rect1 is {:?}\u0026quot;, rect1); }  ç”±äºRustæ˜¯ä¸€é—¨æ‹¥æœ‰é¢å‘å¯¹è±¡å’Œå‡½æ•°ç¼–ç¨‹çš„è¯­è¨€ï¼Œæ‰€ä»¥åœ¨Rustä¸­å¯ä»¥å¯¹structå¯¹è±¡å®šä¹‰æ‰€å±çš„æ–¹æ³• å…¶ä¸­ä½¿ç”¨äº†implå’Œselfå…³é”®å­—ï¼Œè¯­ä¹‰ä¸Šè¿˜æ˜¯èƒ½å¤Ÿç†è§£çš„ã€‚\n#[derive(Debug)] struct Rectangle { width: u32, height: u32, } impl Rectangle { fn area(\u0026amp;self) -\u0026gt; u32 { self.width * self.height } } fn main() { let rect1 = Rectangle { width: 30, height: 50, }; println!( \u0026quot;The area of the rectangle is {} square pixels.\u0026quot;, rect1.area() ); }  æœ¬æ¥ä»¥ä¸ºæŒºç®€å•çš„ï¼Œä½†æ˜¯ç»“åˆä¸Šäº†æ‰€æœ‰æƒç³»ç»Ÿä¸€åˆ‡éƒ½å˜å¾—å¤æ‚äº†ï¼›\n Weâ€™ve chosen \u0026amp;self here for the same reason we used \u0026amp;Rectangle in the function version: we donâ€™t want to take ownership, and we just want to read the data in the struct, not write to it. If we wanted to change the instance that weâ€™ve called the method on as part of what the method does, weâ€™d use \u0026amp;mut self as the first parameter. Having a method that takes ownership of the instance by using just self as the first parameter is rare; this technique is usually used when the method transforms self into something else and you want to prevent the caller from using the original instance after the transformation.\n fn area(\u0026amp;self) -\u0026gt; u32 { self.width * self.height }  è¿™ä¸ªæ–¹æ³•å§‹ç»ˆä¿æŒäº†ç±»å‹å‡½æ•°çš„æ„æ€,è¿™é‡Œçš„selfå…¶å®å°±æ˜¯å‡½æ•°ä¸­çš„Rectangleç›¸å½“äºmove ï¼ŒåŠ ä¸Š\u0026amp;åå°±æ˜¯Borrowingã€‚å½“æ–¹æ³•éœ€è¦ä¿®æ”¹structå®ä¾‹çš„ä¸­çš„å±æ€§çš„æ—¶å€™å°±éœ€è¦ä½¿ç”¨\u0026amp;mut self,å½“éœ€è¦æ‰€æœ‰æƒç§»äº¤çš„æ—¶å€™å°±ä½¿ç”¨self;\nåŸæ¥å¦‚æ­¤ï¼Œä¹Ÿæ²¡æœ‰æƒ³è±¡çš„é‚£ä¹ˆå¤æ‚ï¼ˆå¯èƒ½å§ï¼‰ã€‚\næŠŠå‡½æ•°æ”¾åˆ°Implå—ä¸­å«åšå…³è”å‡½æ•°associated functionsç›¸å½“äºJavaä¸­çš„é™æ€æ–¹æ³•,é€šè¿‡structç›´æ¥è°ƒç”¨,å°±åƒString::from()\nRustä¹Ÿå…è®¸å®šä¹‰å¯¹åŒä¸€ä¸ªstructå¤šä¸ªImplå—\n#[derive(Debug)] struct Rectangle { width: u32, height: u32, } impl Rectangle { fn area(\u0026amp;self) -\u0026gt; u32 { self.width * self.height } } impl Rectangle { fn can_hold(\u0026amp;self, other: \u0026amp;Rectangle) -\u0026gt; bool { self.width \u0026gt; other.width \u0026amp;\u0026amp; self.height \u0026gt; other.height } } fn main() { let rect1 = Rectangle { width: 30, height: 50, }; let rect2 = Rectangle { width: 10, height: 40, }; let rect3 = Rectangle { width: 60, height: 45, }; println!(\u0026quot;Can rect1 hold rect2? {}\u0026quot;, rect1.can_hold(\u0026amp;rect2)); println!(\u0026quot;Can rect1 hold rect3? {}\u0026quot;, rect1.can_hold(\u0026amp;rect3)); }  å®Œ!\n","id":11,"section":"posts","summary":"é€šè¿‡ä½¿ç”¨å…³é”®structå¯ä»¥å®šä¹‰ä¸€ä¸ªç±»ï¼Œå‘¸ï¼Œæ˜¯å®šä¹‰ä¸€ä¸ªç»“æ„ä½“ã€‚ struct User { username: String, email: String, sign_in_count: u64, active: bool, } fn main() { let user1 = User { email: String::from(\u0026quot;someone@example.com\u0026quot;), username: String::from(\u0026quot;someusername123\u0026quot;), active: true, sign_in_count: 1, }; } structä¸Ja","tags":["programing","rust"],"title":"Rust Struct","uri":"https://holicc.github.io/2020/07/rust-struct/","year":"2020"},{"content":"Rustä¸­çš„å¼•ç”¨(Reference)ä¸å€Ÿç”¨(Borrowing) åœ¨ä¸Šä¸€èŠ‚çš„æ‰€æœ‰æƒç³»ç»Ÿçš„æœ€åï¼Œå®˜æ–¹æŠ›å‡ºäº†ä¸€ä¸ªé—®é¢˜ï¼Œå°±æ˜¯åœ¨å‡½æ•°ä½¿ç”¨çš„æ—¶å€™ï¼Œå¦‚æœæŠŠå‚æ•°ä¼ è¿›å»å°±æŠŠæ‰€æœ‰æƒç§»äº¤åˆ°äº†å‡½æ•°ä¸­ï¼Œé‚£ä¹ˆåç»­åˆå¦‚ä½•ä½¿ç”¨è¿™ä¸ªç§»äº¤æ‰€æœ‰æƒåçš„å˜é‡å‘¢ï¼Ÿ\nfn main() { let s1 = String::from(\u0026quot;hello\u0026quot;); let (s2, len) = calculate_length(s1); println!(\u0026quot;The length of '{}' is {}.\u0026quot;, s2, len); } fn calculate_length(s: String) -\u0026gt; (String, usize) { let length = s.len(); // len() returns the length of a String (s, length) }  å®˜æ–¹ç»™å‡ºçš„ä»£ç å¦‚ä¸Šï¼Œä½†æ˜¯è¿™æ ·å†™å°±å¤ªç¹çäº†ã€‚\næœ¬èŠ‚å°±æ˜¯è®²å¦‚ä½•ä½¿ç”¨Referenceå’ŒBorrorwingæ¥è§£å†³è¿™ä¸ªé—®é¢˜ã€‚\nå…ˆæ¥ä¸€æ®µä»£ç èµ·æ‰‹\nfn main() { let s1 = String::from(\u0026quot;hello\u0026quot;); let len = calculate_length(\u0026amp;s1); println!(\u0026quot;The length of '{}' is {}.\u0026quot;, s1, len); } fn calculate_length(s: \u0026amp;String) -\u0026gt; usize { s.len() }  ä¸Šé¢è¿™æ®µä»£ç ï¼Œæˆ‘ç†è§£çš„æ˜¯ä¼ é€’çš„æ˜¯s1å˜é‡çš„æŒ‡é’ˆï¼Œæ‰€æœ‰s1å˜é‡çš„æ‰€æœ‰æƒæ²¡æœ‰ç§»äº¤å‡ºå»ã€‚\n\u0026amp;è¿™ä¸ªç¬¦å·ï¼Œè®°å¾—åœ¨Cè¯­è¨€ä¸­æ˜¯å–åœ°å€çš„æ„æ€ã€‚\n The \u0026amp;s1 syntax lets us create a reference that refers to the value of s1 but does not own it. Because it does not own it, the value it points to will not be dropped when the reference goes out of scope.\n åœ¨Rustä¸­è¿™æ ·ä½¿ç”¨å¼•ç”¨çš„æ–¹å¼å«åšBorrowingå€Ÿç”¨,è¿™ç§æ–¹å¼å…è®¸è·å–ä¸€ä¸ªå€¼çš„å¼•ç”¨è€Œä¸ç”¨ç§»äº¤æ‰€æœ‰æƒ,å› ä¸ºä½ å§‹ç»ˆæ˜¯ä¸œè¥¿çš„ä¸»äººï¼Œåˆ«äººåªæ˜¯å€Ÿç”¨äº†ä½ çš„ä¸œè¥¿ã€‚\n We call having references as function parameters borrowing. As in real life, if a person owns something, you can borrow it from them. When youâ€™re done, you have to give it back.\n é‚£ä¹ˆå°±æœ‰ä¸ªé—®é¢˜ï¼Œåˆ«äººå€Ÿçš„ä¸œè¥¿â€˜å¼„åäº†æ€ä¹ˆåŠï¼Ÿâ€™\nä¸€ä¸‹ä»£ç ä¸èƒ½ç¼–è¯‘é€šè¿‡æ˜¯å› ä¸ºæˆ‘ä»¬ä¸èƒ½ä¿®æ”¹åˆ«äººçš„ä¸œè¥¿ã€‚\nfn main() { let s = String::from(\u0026quot;hello\u0026quot;); change(\u0026amp;s); } fn change(some_string: \u0026amp;String) { some_string.push_str(\u0026quot;, world\u0026quot;); }  å¦‚æœå¼ºè¡Œä¿®æ”¹åˆ«äººçš„ä¸œè¥¿é‚£ä¹ˆå°±éœ€è¦è¿™æ ·å†™ï¼ˆç›¸å½“äºåœ¨ä¿®æ”¹åˆ«äººçš„ä¸œè¥¿æ—¶ï¼Œå…ˆé—®ä¸€å¥ï¼šâ€œæˆ‘å¯ä»¥ä¿®æ”¹ä½ çš„æ•°æ®å—ï¼Ÿâ€ï¼‰\nfn main() { let mut s = String::from(\u0026quot;hello\u0026quot;); change(\u0026amp;mut s); } fn change(some_string: \u0026amp;mut String) { some_string.push_str(\u0026quot;, world\u0026quot;); }  ä½†æ˜¯å‘¢ï¼Œè¿™æ ·åˆæœ‰å¾ˆå¤šçš„é™åˆ¶ï¼Œä½ ä¸èƒ½æŠŠä¸œè¥¿å€Ÿç»™å¤šä¸ªæƒ³è¦ä¿®æ”¹çš„äººã€‚\nfn main() { let mut s = String::from(\u0026quot;hello\u0026quot;); let r1 = \u0026amp;mut s; let r2 = \u0026amp;mut s; println!(\u0026quot;{}, {}\u0026quot;, r1, r2); }   Data races cause undefined behavior and can be difficult to diagnose and fix when youâ€™re trying to track them down at runtime; Rust prevents this problem from happening because it wonâ€™t even compile code with data races!\n ä¸ºä»€ä¹ˆä¸è®¸å…è®¸åŒä¸€å¼•ç”¨çš„å¤šå‡ºä¿®æ”¹ï¼Œæ˜¯ä¸ºäº†é¿å…æ•°æ®ç«äº‰å¸¦æ¥çš„å„ç§ä¸å®‰å…¨çš„è¡Œä¸ºã€‚\nä¸€ç§æŠ˜ä¸­çš„å†™æ³•æ˜¯ï¼š\nfn main() { let mut s = String::from(\u0026quot;hello\u0026quot;); { let r1 = \u0026amp;mut s; } // r1 goes out of scope here, so we can make a new reference with no problems. let r2 = \u0026amp;mut s; }  ä½†æ˜¯ä¸èƒ½é€šæ˜¯æŠŠä¸å¯å˜å¼•ç”¨å’Œå¯å˜å¼•ç”¨éƒ½å€Ÿå‡ºå»ï¼š\nfn main() { let mut s = String::from(\u0026quot;hello\u0026quot;); let r1 = \u0026amp;s; // no problem let r2 = \u0026amp;s; // no problem let r3 = \u0026amp;mut s; // BIG PROBLEM println!(\u0026quot;{}, {}, and {}\u0026quot;, r1, r2, r3); }  WTF?! æ‰“è„¸\nfn main() { let mut s = String::from(\u0026quot;hello\u0026quot;); let r1 = \u0026amp;s; // no problem let r2 = \u0026amp;s; // no problem println!(\u0026quot;{} and {}\u0026quot;, r1, r2); // r1 and r2 are no longer used after this point let r3 = \u0026amp;mut s; // no problem println!(\u0026quot;{}\u0026quot;, r3); }   Note that a referenceâ€™s scope starts from where it is introduced and continues through the last time that reference is used. For instance, this code will compile because the last usage of the immutable references occurs before the mutable reference is introduced:\n å®˜æ–¹æ–‡æ¡£å‘Šè¯‰æˆ‘ï¼Œåªè¦ä¸å¯å˜çš„å¼•ç”¨è¢«ä½¿ç”¨äº†ï¼Œé‚£ä¹ˆå°±ä¼šè¢«é‡Šæ”¾ï¼Œä»è€Œåç»­å®šä¹‰çš„å¯å˜å¼•ç”¨r3å®šä¹‰å°±æ˜¯èƒ½å¤Ÿç¼–è¯‘é€šè¿‡çš„ã€‚\nè¿™ä¸ªâ€œå¥‡æ€ªâ€çš„è®¾è®¡ï¼Œå®˜æ–¹ä¹Ÿç»™å‡ºäº†å®‰æ…°\n Even though borrowing errors may be frustrating at times, remember that itâ€™s the Rust compiler pointing out a potential bug early (at compile time rather than at runtime) and showing you exactly where the problem is. Then you donâ€™t have to track down why your data isnâ€™t what you thought it was.\n ç¼–è¯‘æ—¶æœŸå‘èƒ½å‘ç°çš„é—®é¢˜ï¼Œæ€»æ¯”è¿è¡Œæ—¶çš„å¼‚å¸¸å¥½å§ ğŸ˜‚ã€‚\nä¹‹å‰è¯´åˆ°ä¼šæŠŠâ€å€Ÿæ¥çš„ä¸œè¥¿ç©åâ€œï¼Œå°±æ˜¯ä¸€ä¸‹è¿™ç§æƒ…å†µï¼Œä¸“ä¸šæœ¯è¯­dangle æ‚¬å‚æŒ‡é’ˆ:\nfn main() { let reference_to_nothing = dangle(); } fn dangle() -\u0026gt; \u0026amp;String { // dangle returns a reference to a String let s = String::from(\u0026quot;hello\u0026quot;); // s is a new String \u0026amp;s // we return a reference to the String, s } // Here, s goes out of scope, and is dropped. Its memory goes away. // Danger!  å› ä¸ºæ˜¯å€Ÿç”¨æ¥çš„ä¸œè¥¿ï¼Œåœ¨ä½¿ç”¨å®Œåå°±ä¼šè¢«é‡Šæ”¾æ‰ï¼Œç„¶è€Œè¿™é‡ŒæŠŠä»–ä½œä¸ºè¿”å›å€¼è¿”å›å°±ä¼šé€ æˆæ‚¬å‚æŒ‡é’ˆçš„å‡ºç°ã€‚\nè§£å†³è¿™ä¸ªé—®é¢˜ä¹Ÿå¾ˆç®€å•ï¼Œåªè¦è¿”å›ä¸€ä¸ªæ–°çš„ä¸œè¥¿å°±è¡Œäº†ã€‚\nfn main() { let string = no_dangle(); } fn no_dangle() -\u0026gt; String { let s = String::from(\u0026quot;hello\u0026quot;); s }  å­¦ä¹ åˆ°ç°åœ¨ï¼Œè¿™äº›ä¸œè¥¿éƒ½è¿˜æ˜¯èƒ½å¤Ÿç†è§£çš„ï¼Œéƒ½æ˜¯ä¸ºäº†è§£å†³åƒåœ¾å›æ”¶å†…å­˜å®‰å…¨ç›¸å…³è€Œå‘æ˜çš„ç‰¹æ€§ã€‚\nå®Œ!\n","id":12,"section":"posts","summary":"Rustä¸­çš„å¼•ç”¨(Reference)ä¸å€Ÿç”¨(Borrowing) åœ¨ä¸Šä¸€èŠ‚çš„æ‰€æœ‰æƒç³»ç»Ÿçš„æœ€åï¼Œå®˜æ–¹æŠ›å‡ºäº†ä¸€ä¸ªé—®é¢˜ï¼Œå°±æ˜¯åœ¨å‡½æ•°ä½¿ç”¨çš„æ—¶å€™ï¼Œå¦‚æœ","tags":["programing","rust"],"title":"Rust Reference And Borrowing","uri":"https://holicc.github.io/2020/07/rust-references-and-borrowing/","year":"2020"},{"content":"Rustä¸­çš„æ‰€æœ‰æƒç³»ç»Ÿ(Ownership) ç›®å‰å¤§éƒ¨åˆ†çš„ç¼–ç¨‹è¯­è¨€ç®¡ç†å†…å­˜éƒ½æ˜¯ä½¿ç”¨çš„ï¼š1.è‡ªåŠ¨ç®¡ç†(åƒåœ¾å›æ”¶æœºåˆ¶ï¼ŒåƒJava) 2.æ‰‹åŠ¨ç¼–ç æ§åˆ¶å†…å­˜çš„åˆ†é…(åƒCæˆ–C++) ç„¶è€ŒRustä¸ä¸€æ ·ï¼Œå¦è¾Ÿè¹Šå¾„ï¼Œé çš„æ˜¯ç¼–è¯‘å™¨æ¥ä¿è¯å†…å­˜çš„åˆ†é…å’Œå›æ”¶ã€‚ä¹Ÿå«åšOwnership,è¿™ä¸€æ¦‚å¿µæ˜¯åœ¨Rustä¸­ç‹¬æœ‰çš„ï¼Œæ˜¯Rustç‹¬æœ‰çš„ç‰¹æ€§ä¹‹ä¸€ã€‚å¦‚ä½•çœ‹å¾…è¿™ä¸€ç‰¹æ€§ï¼Œå°±æ˜¯ä»è€…è§ä»æ™ºè€…è§æ™ºäº†ï¼Œå¯¹äºä¸€ä¸ªJavaç¨‹åºå‘˜æ¥è¯´ï¼Œè¿™ä¸€ç‰¹æ€§å½·ä½›æ²¡æœ‰é‚£ä¹ˆå¥½ï¼Œåè€Œæœ‰ç‚¹è®©äººæ¥å—ä¸äº†(å¯èƒ½æ˜¯å› ä¸ºRustæ˜¯ä¸€é—¨ç³»ç»Ÿçº§åˆ«çš„ç¼–ç¨‹è¯­è¨€ï¼Œæ¯”è¾ƒæ³¨é‡æ€§èƒ½å’Œå®‰å…¨æ€§)\n memory is managed through a system of ownership with a set of rules that the compiler checks at compile time. None of the ownership features slow down your program while itâ€™s running.\n è¦æ˜ç™½æ‰€æœ‰æƒç³»ç»Ÿï¼Œè¦å…ˆå¯¹å †æ ˆæœ‰åŸºæœ¬çš„è®¤è¯†ã€‚\n All data stored on the stack must have a known, fixed size. Data with an unknown size at compile time or a size that might change must be stored on the heap instead\n ç¼–è¯‘æœŸé—´èƒ½å¤ŸçŸ¥é“å¤§å°çš„å˜é‡æ˜¯åˆ†é…åˆ°æ ˆä¸Šï¼Œæ— æ³•ç¡®å®šå¤§å°çš„å°±æ˜¯åˆ†é…åˆ°å †ä¸Šã€‚ï¼ˆä¹Ÿä¸æ˜¯ç»å¯¹çš„ï¼‰\nè¿™ä¸ªç‚¹ä¸çŸ¥é“ï¼Œè®°å½•ä¸€ä¸‹\n When your code calls a function, the values passed into the function (including, potentially, pointers to data on the heap) and the functionâ€™s local variables get pushed onto the stack. When the function is over, those values get popped off the stack.\n å‡½æ•°ä¸­çš„å±€éƒ¨å˜é‡æ˜¯åˆ†é…åœ¨æ ˆä¸Šçš„ï¼Œæ¯å½“å‡½æ•°è°ƒç”¨å®Œæˆï¼Œå˜é‡ä¹Ÿå·²ç»è¢«å¼¹å‡ºæ ˆé¡¶äº†ã€‚\nå®˜æ–¹æ–‡æ¡£ä¹Ÿæ€»ç»“çš„å¾ˆåˆ°ä½\n Keeping track of what parts of code are using what data on the heap, minimizing the amount of duplicate data on the heap, and cleaning up unused data on the heap so you donâ€™t run out of space are all problems that ownership addresses. Once you understand ownership, you wonâ€™t need to think about the stack and the heap very often, but knowing that managing heap data is why ownership exists can help explain why it works the way it does.\n æ‰€æœ‰æƒç³»ç»Ÿä¸»è¦æ˜¯ä¸ºäº†å¸®åŠ©ä½ æ›´å¥½çš„ç®¡ç†å˜é‡åœ¨å †æ ˆä¸Šçš„åˆ†é…ã€‚ç³»ç»Ÿçº§åˆ«çš„ç¼–ç¨‹è¯­è¨€æ¯”è¾ƒåœ¨å˜é‡æ˜¯åˆ†é…åˆ°å †è¿˜æ˜¯æ ˆä¸Šï¼Œå¯¹äºä½¿ç”¨Javaçš„æˆ‘æ¥è¯´ï¼Œå¯¹ä¸è¿™ä¸ªæ¦‚å¿µæ˜¯ç›¸å½“æ¨¡ç³Šçš„ï¼Œåªæ˜¯å¤§æ¦‚çŸ¥é“Javaä¸­çš„å¯¹è±¡å¤§éƒ¨åˆ†éƒ½æ˜¯åˆ†é…åˆ°å †ä¸Šçš„ï¼Œè€Œä¸”GCä¹Ÿæ˜¯é’ˆå¯¹å †ä¸Šçš„å¯¹è±¡è¿›è¡Œçš„å›æ”¶ã€‚ ä¸ºæ­¤é¡ºä¾¿å­¦ä¹ ä¸€ä¸‹Javaæ–¹é¢çš„çŸ¥è¯†å§ã€‚\nJVMè§„èŒƒè®©æ¯ä¸ªJavaçº¿ç¨‹æ‹¥æœ‰è‡ªå·±çš„ç‹¬ç«‹çš„JVMæ ˆï¼Œä¹Ÿå°±æ˜¯Javaæ–¹æ³•çš„è°ƒç”¨æ ˆã€‚\nJVMé‡Œçš„â€œå †â€ï¼ˆheapï¼‰ç‰¹æŒ‡ç”¨äºå­˜æ”¾Javaå¯¹è±¡çš„å†…å­˜åŒºåŸŸã€‚æ‰€ä»¥æ ¹æ®è¿™ä¸ªå®šä¹‰ï¼ŒJavaå¯¹è±¡å…¨éƒ¨éƒ½åœ¨å †ä¸Š\nè¦æ³¨æ„ï¼Œè¿™ä¸ªâ€œå †â€å¹¶ä¸æ˜¯æ•°æ®ç»“æ„æ„ä¹‰ä¸Šçš„å †ï¼ˆHeap (data structure)ï¼Œä¸€ç§æœ‰åºçš„æ ‘ï¼‰ï¼Œè€Œæ˜¯åŠ¨æ€å†…å­˜åˆ†é…æ„ä¹‰ä¸Šçš„å †â€”â€”ç”¨äºç®¡ç†åŠ¨æ€ç”Ÿå‘½å‘¨æœŸçš„å†…å­˜åŒºåŸŸã€‚\nJVMçš„å †è¢«åŒä¸€ä¸ªJVMå®ä¾‹ä¸­çš„æ‰€æœ‰Javaçº¿ç¨‹å…±äº«ã€‚å®ƒé€šå¸¸ç”±æŸç§è‡ªåŠ¨å†…å­˜ç®¡ç†æœºåˆ¶æ‰€ç®¡ç†ï¼Œè¿™ç§æœºåˆ¶é€šå¸¸å«åšâ€œåƒåœ¾å›æ”¶â€ï¼ˆgarbage collectionï¼ŒGCï¼‰ã€‚JVMè§„èŒƒå¹¶ä¸å¼ºåˆ¶è¦æ±‚JVMå®ç°é‡‡ç”¨å“ªç§GCç®—æ³•ã€‚\nå¥½äº†ï¼Œå›åˆ°Rustä¸­çš„æ‰€æœ‰æƒç³»ç»Ÿã€‚\næ‰€æœ‰æƒç³»ç»Ÿéœ€è¦ç†ŸçŸ¥ä¸€ä¸‹ä¸‰æ¡è§„åˆ™ï¼š\n Each value in Rust has a variable thatâ€™s called its owner(æ¯ä¸€å˜é‡éƒ½æœ‰å…¶æ‹¥æœ‰è€…//ä¸çŸ¥é“è¿™æ ·ç¿»è¯‘å¯¹ä¸å¯¹ - -). There can only be one owner at a time.(åŒä¸€æ—¶åˆ»ä¸€ä¸ªå˜é‡åªèƒ½æœ‰ä¸€ä¸ªæ‹¥æœ‰è€…) When the owner goes out of scope, the value will be dropped.(å½“æ‹¥æœ‰è€…ä¸åœ¨ä½œç”¨åŸŸä¸­äº†ï¼Œé‚£ä¹ˆè¿™ä¸ªå€¼å°±ä¼šè¢«é‡Šæ”¾æ‰)  è§„åˆ™æ¯”æˆ‘æƒ³è±¡çš„è¦ç®€å•æ˜äº†è®¸å¤šï¼Œçœ‹ä¸Šå»å¾ˆç®€æ´ï¼Œå®é™…ä¸Šå´é¥±å«äº†å¾ˆå¤šä¿¡æ¯é‡ã€‚ã€‚ã€‚\nå…¶ä¸­æåˆ°äº†scope(ä½œç”¨åŸŸ)è¿™ä¸ªæ¦‚å¿µï¼Œæœ‰ç‚¹ç±»ä¼¼äºSpringä¸­çš„scopeçš„æ ·å­æˆ–è€…httpä¸­çš„sessionä½œç”¨åŸŸå’Œrequestä½œç”¨åŸŸã€‚\nå®˜æ–¹ç»™çš„ä¾‹å­è¿˜æ˜¯å¾ˆå®¹æ˜“ç†è§£çš„\nfn main() { { // s is not valid here, itâ€™s not yet declared let s = \u0026quot;hello\u0026quot;; // s is valid from this point forward // do stuff with s } // this scope is now over, and s is no longer valid }  æœ‰ä¸€ç‚¹ç‰¹æ®Šçš„æ˜¯Stringå’Œliteral\nåœ¨IDEAçš„æç¤ºä¸‹å‘ç°è¿™æ˜¯ä¸¤ç§ä¸åŒçš„ç±»å‹ï¼Œç„¶å„¿åœ¨Javaä¸­éƒ½æ˜¯ç»Ÿä¸€çš„String\n\nåŸå› æ˜¯å› ä¸ºliteralæ˜¯å›ºå®šé•¿åº¦çš„ä¸å¯å˜çš„ï¼Œåˆ†é…åœ¨æ ˆä¸Šçš„æ•°æ®ç»“æ„ã€‚è€ŒStringæ˜¯è·ŸJavaä¸­çš„Stringç±»å‹ä¸€æ ·æ˜¯å¯å˜çš„ã€‚\nåŒä¸ºStringç±»å‹ä½†æ˜¯æœ‰ç‚¹ä¸åŒçš„æ˜¯ã€‚\nJavaä¸­çš„Stringå¯ä»¥è¿™æ ·å†™\nclass Scratch { public static void main(String[] args) { String a = \u0026quot;a\u0026quot;; String b = a; a += \u0026quot;zxc\u0026quot;; System.out.println(a + \u0026quot; \u0026quot; + b); } }  ç„¶è€Œåœ¨Rustä¸­è¿™å´ä¸èƒ½è¿™æ ·\nfn main() { let s1 = String::from(\u0026quot;hello\u0026quot;); // let s2 = s1; ç¼–è¯‘ä¸é€šè¿‡ println!(\u0026quot;{}, world!\u0026quot;, s1); }  åŸå› æ˜¯å› ä¸ºRustä¸­æ˜¯s2å¹¶æ²¡æœ‰å¯¹s1è¿›è¡Œå€¼æ‹·è´ï¼Œä¼ é€’çš„æ˜¯s1çš„æŒ‡é’ˆã€‚æ ¹æ®å®˜æ–¹çš„è§£é‡Šï¼Œè¿™é‡Œæ¶‰åŠåˆ°äº† æµ…æ‹·è´å’Œæ·±æ‹·è´\n If youâ€™ve heard the terms shallow copy and deep copy while working with other languages, the concept of copying the pointer, length, and capacity without copying the data probably sounds like making a shallow copy. But because Rust also invalidates the first variable, instead of being called a shallow copy, itâ€™s known as a move. In this example, we would say that s1 was moved into s2.\n Rustå¹¶æ²¡æœ‰éšå¼çš„è¿›è¡Œæµ…æ‹·è´æ“ä½œã€‚è€Œæ˜¯è®©s1å¤±æ•ˆï¼Œè¿™æ ·çš„æ“ä½œå«åš moved,ç›¸å½“äºæŠŠs1ä¸Šçš„å€¼çš„æŒ‡é’ˆç§»åŠ¨åˆ°äº†s2ä¸Šè¿™æ · s1å°±å¤±æ•ˆäº†ã€‚ ä¸ºä»€ä¹ˆè¦è¿™æ ·åšå¯èƒ½æ˜¯ä¸ºäº†èƒ½å¤Ÿæ›´å¥½çš„è¿½è¸ªå†…å­˜å¹¶å›æ”¶å§ã€‚\nå¦‚æœè¦ä½¿ç”¨æ·±æ‹·è´,å°±è¦ä½¿ç”¨cloneæ–¹æ³•ã€‚è¯¥æ–¹æ³•ä¼šå¯¹å †å’Œæ ˆä¸Šçš„æ‰€æœ‰å†…å®¹è¿›è¡Œæ‹·è´ã€‚\nfn main() { let s1 = String::from(\u0026quot;hello\u0026quot;); let s2 = s1.clone(); println!(\u0026quot;s1 = {}, s2 = {}\u0026quot;, s1, s2); }  åœ¨æœ‰äº›åœ°æ–¹ï¼Œè·ŸJavaç±»ä¼¼ï¼Œå¯¹äºåŸºæœ¬çš„æ•°æ®ç±»å‹ï¼Œéƒ½ä¸éœ€è¦ä½¿ç”¨æ˜¾ç¤ºçš„ä½¿ç”¨cloneæ–¹æ³•\nfn main() { let x = 5; let y = x; println!(\u0026quot;x = {}, y = {}\u0026quot;, x, y); }  åœ¨Rustä¸­æ‰€æœ‰éƒ½éµå¾ªæ‰€æœ‰æƒç³»ç»Ÿçš„è§„åˆ™\nåœ¨å‡½æ•°ä¸­ï¼Œä¼ é€’è¿›å»çš„å‚æ•°ä¹Ÿæ˜¯æ‰€æœ‰æƒç§»äº¤çš„ä¸€ç§æ–¹å¼\nfn main() { let s = String::from(\u0026quot;hello\u0026quot;); // s comes into scope takes_ownership(s); // s's value moves into the function... // ... and so is no longer valid here let x = 5; // x comes into scope makes_copy(x); // x would move into the function, // but i32 is Copy, so itâ€™s okay to still // use x afterward } // Here, x goes out of scope, then s. But because s's value was moved, nothing // special happens. fn takes_ownership(some_string: String) { // some_string comes into scope println!(\u0026quot;{}\u0026quot;, some_string); } // Here, some_string goes out of scope and `drop` is called. The backing // memory is freed. fn makes_copy(some_integer: i32) { // some_integer comes into scope println!(\u0026quot;{}\u0026quot;, some_integer); } // Here, some_integer goes out of scope. Nothing special happens.  è¿”å›å€¼ä¸­å°±æ›´å¥½ç†è§£äº†\nfn main() { let s1 = gives_ownership(); // gives_ownership moves its return // value into s1 let s2 = String::from(\u0026quot;hello\u0026quot;); // s2 comes into scope let s3 = takes_and_gives_back(s2); // s2 is moved into // takes_and_gives_back, which also // moves its return value into s3 } // Here, s3 goes out of scope and is dropped. s2 goes out of scope but was // moved, so nothing happens. s1 goes out of scope and is dropped. fn gives_ownership() -\u0026gt; String { // gives_ownership will move its // return value into the function // that calls it let some_string = String::from(\u0026quot;hello\u0026quot;); // some_string comes into scope some_string // some_string is returned and // moves out to the calling // function } // takes_and_gives_back will take a String and return one fn takes_and_gives_back(a_string: String) -\u0026gt; String { // a_string comes into // scope a_string // a_string is returned and moves out to the calling function }  æ‰€æœ‰æƒç³»ç»Ÿå°±åƒæ˜¯ç»™æ¯ä¸€ä¸ªå˜é‡è¿›è¡Œäº†ä¸€ä¸ªè½¨è¿¹è¿½è¸ªä¸€æ ·ã€‚è¿™æ ·çš„è¯å†™ä»£ç æ„Ÿè§‰ä¼šæ›´åŠ æ¸…æ™°æ˜äº†ï¼Œä½†æ˜¯é˜…è¯»èµ·æ¥å¯èƒ½æœ‰ç‚¹éš¾å—å§ï¼Ÿ\næ€»ä½“æ¥è¯´è¿˜æ˜¯ä¸é”™çš„è®¾è®¡ã€‚\nå®Œï¼\nå‚è€ƒ Javaè™šæ‹Ÿæœºçš„å †ã€æ ˆã€å †æ ˆå¦‚ä½•å»ç†è§£ï¼Ÿ RednaxelaFXå¤§ä½¬è§£ç­”\n","id":13,"section":"posts","summary":"Rustä¸­çš„æ‰€æœ‰æƒç³»ç»Ÿ(Ownership) ç›®å‰å¤§éƒ¨åˆ†çš„ç¼–ç¨‹è¯­è¨€ç®¡ç†å†…å­˜éƒ½æ˜¯ä½¿ç”¨çš„ï¼š1.è‡ªåŠ¨ç®¡ç†(åƒåœ¾å›æ”¶æœºåˆ¶ï¼ŒåƒJava) 2.æ‰‹åŠ¨ç¼–ç æ§åˆ¶","tags":["programing","rust"],"title":"Rust Function","uri":"https://holicc.github.io/2020/07/rust-ownership/","year":"2020"},{"content":"Rustä¸­çš„æ•°æ®ç±»å‹ Rustæ˜¯ä¸€é—¨é™æ€ç±»å‹çš„è¯­è¨€(è·ŸJavaä¸€æ ·)ï¼Œæ¯ä¸€ä¸ªå€¼éƒ½æœ‰å…¶å¯¹åº”çš„æ•°æ®ç±»å‹(Every value in Rust is of a certain data type)\nNumber Types Rustä½œä¸ºä¸€é—¨é¢å‘åº•å±‚çš„ç¼–ç¨‹è¯­è¨€ï¼Œåœ¨æ•°æ®ç±»å‹ä¸Šæ‹¥æœ‰äº†æ›´å¤šçš„ç±»å‹ï¼Œä¾‹å¦‚intç±»å‹åœ¨Javaä¸­åªæœ‰ä¸€ç§è¡¨è±¡å½¢å¼ï¼ŒåŠè¡¨è¾¾32ä½çš„æ•´å½¢ï¼›ç„¶è€Œåœ¨Rustä¸­åˆ†çš„å°±ç‰¹åˆ«ç»†äº†ã€‚ åœ¨Rustä¸­æ•´å‹åˆ†ä¸º Signedå’ŒUnsignedåˆ†åˆ«å¯¹åº”8ï¼Œ16ï¼Œ32ï¼Œ64ï¼Œ128ä½; é‚£ä¹ˆä»€ä¹ˆæ˜¯ Signedæœ‰ç¬¦å·å’Œ Unsigned æ— ç¬¦å·å‘¢ï¼Ÿ\n æœ‰ç¬¦å·ï¼š0111 1111 = 26+25+24+23+22+21+2^0=127;èŒƒå›´æ˜¯ -128 ~ 127\næ— ç¬¦å·ï¼š1111 1111 = 27+26+25+24+23+22+21+20=255ï¼›èŒƒå›´æ˜¯ 0 ~ 255\n é™¤äº†è¿™äº›ï¼ŒåŸºæœ¬çš„è¿ç®—ç¬¦éƒ½æ˜¯ç›¸åŒçš„ï¼Œè¿˜æœ‰åŒ…æ‹¬ float ä¹Ÿæ˜¯æœ‰32ä½å’Œ84ä½çš„,charç±»å‹æ˜¯æ˜¯4å­—èŠ‚å­çš„,é€šç”¨çš„ bool ç±»å‹ã€‚\nç›¸æ¯”Javaè€Œè¨€Rustå¤šäº†ä¸€äº›å¤åˆç±»å‹çš„æ•°æ®ç»“æ„ï¼Œä¾‹å¦‚ï¼š Tupleå…ƒç»„ç±»å‹ï¼Œå…ƒç»„æ˜¯å›ºå®šå¤§å°çš„ï¼Œä¸€æ—¦å®šä¹‰å®Œæˆå°±ä¸èƒ½æ”¹å˜å¤§å°ã€‚ å¯ä»¥å®šä¹‰ä¸åŒç±»å‹çš„å…ƒç»„\nfn main() { let tup: (i32, f64, u8) = (500, 6.4, 1); }  å…¶ä¸­è¿˜åŒ…å«ç›¸åº”çš„è§£åŒ…ã€æ¨¡å¼åŒ¹é…æ“ä½œã€‚\nfn main() { let tup = (500, 6.4, 1); let (x, y, z) = tup; println!(\u0026quot;The value of y is: {}\u0026quot;, y); }  è·å–Tupleä¸­çš„å…ƒç´ ç›´æ¥ä½¿ç”¨ä¸‹æ ‡å°±è¡Œäº†\nfn main() { let x: (i32, f64, u8) = (500, 6.4, 1); let five_hundred = x.0; let six_point_four = x.1; let one = x.2; }  æ¥ä¸‹æ¥æ˜¯ Array ä¹Ÿå’Œå¤§éƒ¨åˆ†ç¼–ç¨‹è¯­è¨€ç›¸åŒï¼Œåªæ˜¯å®šä¹‰çš„æ—¶å€™æœ‰ç‚¹å¥‡æ€ª,ç±»å‹å’Œå¤§å°ä½¿ç”¨åˆ†å·éš”å¼€çš„\nlet a: [i32; 5] = [1, 2, 3, 4, 5];  æˆ–è€…ä½¿ç”¨ä¸€ä¸ªè¯­æ³•ç³–çš„æ–¹å¼å®šä¹‰\nlet a = [3; 5]; // [3, 3, 3, 3, 3]  ä¹Ÿæ˜¯ä¸€äº›åŸºæœ¬çš„æ•°æ®ç±»å‹ï¼Œæ²¡å•¥å¤ªç‰¹åˆ«çš„ä¸œè¥¿ã€‚\nå®Œï¼\n","id":14,"section":"posts","summary":"Rustä¸­çš„æ•°æ®ç±»å‹ Rustæ˜¯ä¸€é—¨é™æ€ç±»å‹çš„è¯­è¨€(è·ŸJavaä¸€æ ·)ï¼Œæ¯ä¸€ä¸ªå€¼éƒ½æœ‰å…¶å¯¹åº”çš„æ•°æ®ç±»å‹(Every value in Rust is of a certain data type) Number Types Rustä½œ","tags":["programing","rust"],"title":"Rust Data Types","uri":"https://holicc.github.io/2020/07/rust-data-types/","year":"2020"},{"content":"Rustä¸­çš„å‡½æ•° Rustæ˜¯æ”¯æŒå‡½æ•°ç¼–ç¨‹çš„ï¼Œä¸åƒJavaå®Œå…¨æ˜¯ä½¿ç”¨é¢å‘å¯¹è±¡çš„ç¼–ç¨‹è¯­è¨€ï¼Œè™½ç„¶å¯ä»¥ä½¿ç”¨Functionç­‰ï¼Œä½†æ˜¯è¿˜æ˜¯æœ‰äº›å·®è·çš„ã€‚\nRustä¸­å®šä¹‰å‡½æ•°çš„å…³é”®çœŸæ˜¯çš„è¶…çº§ç®€çŸ­ï¼Œå¹¶ä¸”æå€¡ä½¿ç”¨è›‡å½¢å‘½åæ³•ï¼ˆè¿™ä¸ªæŒºå¥½çš„ï¼‰\nfn main() { another_function(5); } fn another_function(x: i32) { println!(\u0026quot;The value of x is: {}\u0026quot;, x); }  ç¥å¥‡çš„æ˜¯ä½ è¿˜å¯ä»¥è¿™æ ·å†™\nfn main() { let x = (let y = 6); }  ä½†æ˜¯è¿™æ ·å†™ä¸èƒ½ç¼–è¯‘é€šè¿‡ï¼Œå®˜æ–¹æ˜¯è¿™æ ·è§£é‡Šçš„\n Statements do not return values. Therefore, you canâ€™t assign a let statement to another variable, as the following code tries to do; youâ€™ll get an error\n æ—¢ç„¶letè¯­å¥æ˜¯ä¸€ä¸ªä¸ä¼šæœ‰è¿”å›å€¼çš„è¯­å¥é‚£ä¹ˆå¦‚æœåœ¨è¡¨è¾¾å¼ä¸­æ˜ç¡®äº†è¿”å›å€¼çš„è¯å°±å¯ä»¥äº†å§\nfn main() { let x = 5; let y = { let x = 3; x + 1 }; println!(\u0026quot;The value of y is: {}\u0026quot;, y); }  è¿™æ ·çœ‹æ¥å°±æœ‰ç‚¹å‡½æ•°å¼ç¼–ç¨‹çš„å‘³é“äº†\nåœ¨è¿”å›å€¼çš„åœ°æ–¹å¯èƒ½æœ‰ç‚¹å¥‡æ€ª,;æ˜¯è¢«çœç•¥æ‰äº†ã€‚å¯èƒ½å¯¹äºJavaç¨‹åºå‘˜çš„æˆ‘æ¥è¯´æœ‰ç‚¹ä¸ä¹ æƒ¯è¿™æ ·çš„æ“ä½œã€‚\nå®˜æ–¹æ–‡æ¡£ä¸¾å‡ºäº†ä¸€ä¸ªåˆ—å­æ¥è¯´æ˜;çš„ä½œç”¨\nfn main() { let x = plus_one(5); println!(\u0026quot;The value of x is: {}\u0026quot;, x); } fn plus_one(x: i32) -\u0026gt; i32 { x + 1 } // è¿™æ ·å†™ä¼šä¾¿å®œä¸é€šè¿‡çš„ // fn plus_one(x: i32) -\u0026gt; i32 { // x + 1; // }  å®˜æ–¹ç»™å‡ºçš„è§£é‡Šå¦‚ä¸‹ï¼š\n The main error message, â€œmismatched types,â€ reveals the core issue with this code. The definition of the function plus_one says that it will return an i32, but statements donâ€™t evaluate to a value, which is expressed by (), an empty tuple. Therefore, nothing is returned, which contradicts the function definition and results in an error. In this output, Rust provides a message to possibly help rectify this issue: it suggests removing the semicolon, which would fix the error.\n ä¸Šäº†åˆ†å·è¡¨ç¤ºè¿™æ˜¯ä¸€ä¸ª statements ï¼Œè¿”å›å€¼ä¸ºä¸€ä¸ªç©ºçš„å…ƒç»„åŠä¸ºç©ºï¼Œæ‰€ä»¥å’Œå‡½æ•°å®šä¹‰çš„è¿”å›i32ç±»å‹ä¸ç¬¦åˆï¼Œæ‰€ä»¥ç¼–è¯‘ä¸é€šè¿‡ã€‚\nå—¯â€¦â€¦ å¥‡æ€ª\nå®Œï¼\n","id":15,"section":"posts","summary":"Rustä¸­çš„å‡½æ•° Rustæ˜¯æ”¯æŒå‡½æ•°ç¼–ç¨‹çš„ï¼Œä¸åƒJavaå®Œå…¨æ˜¯ä½¿ç”¨é¢å‘å¯¹è±¡çš„ç¼–ç¨‹è¯­è¨€ï¼Œè™½ç„¶å¯ä»¥ä½¿ç”¨Functionç­‰ï¼Œä½†æ˜¯è¿˜æ˜¯æœ‰äº›å·®è·çš„ã€‚ Ru","tags":["programing","rust"],"title":"Rust Function","uri":"https://holicc.github.io/2020/07/rust-function/","year":"2020"},{"content":"Rustä¸­çš„å˜é‡ä¸å¸¸é‡çš„å®šä¹‰ Rustä¸­å®šä¹‰å˜é‡ä½¿ç”¨çš„å…³é”®å­—æ˜¯ let å…³é”®å­—ï¼Œè¯¥å…³é”®å­—å®šä¹‰çš„å˜é‡æ˜¯ä¸å¯å˜çš„;æƒ³è¦å®šä¹‰ä¸€ä¸ªå¯å˜çš„å˜é‡éœ€è¦å†ä½¿ç”¨ä¸€ä¸ªå…³é”® let mutå¯¹å˜é‡è¿›è¡Œå®šä¹‰;\nfn main() { let mut x = 5; println!(\u0026quot;The value of x is: {}\u0026quot;, x); x = 6; println!(\u0026quot;The value of x is: {}\u0026quot;, x); }  ä¸ºä»€ä¹ˆè¿™æ ·è®¾è®¡å®˜æ–¹ç»™å‡ºäº†è§£é‡Š:\n There are multiple trade-offs to consider in addition to the prevention of bugs. For example, in cases where youâ€™re using large data structures, mutating an instance in place may be faster than copying and returning newly allocated instances. With smaller data structures, creating new instances and writing in a more functional programming style may be easier to think through, so lower performance might be a worthwhile penalty for gaining that clarity.\n å¤§è‡´æ˜¯è¯´è¿™æ˜¯ä¸€ç§æŠ˜ä¸­çš„è®¾è®¡ï¼Œä¸ºäº†èƒ½å¤Ÿåœ¨æ“çºµå¤§çš„æ•°æ®ç»“æ„ï¼ˆç±»å‹Javaä¸­çš„å¯¹è±¡ï¼‰æ—¶ï¼Œé¿å…ä½¿ç”¨æ‹·è´åˆ›å»ºä¸€ä¸ªæ–°çš„å®ä¾‹ï¼Œè€Œæ˜¯ç›´æ¥æ“ä½œå…¶å¼•ç”¨å¯¹å…¶è¿›è¡Œä¿®æ”¹ï¼›ç›¸ååœ¨æ“ä½œå°çš„å¯¹è±¡æ—¶æ‹·è´åˆ›å»ºä¸€ä¸ªæ–°çš„å¯¹è±¡æ›´åŠ ç¬¦åˆå‡½æ•°å¼ç¼–ç¨‹çš„é£æ ¼æ›´å®¹æ˜“ç†è§£ï¼Œå½“ç„¶ä¹Ÿä¼šæ¶ˆè€—ä¸€ç‚¹æ€§èƒ½ï¼›\n*è¿™æ ·è¯´æ˜¯ä¸æ˜¯æ„å‘³ç€ letçš„ä½¿ç”¨æ˜¯è¿›è¡Œå€¼çš„æ‹·è´ï¼Œlet mutåªæ˜¯ä¼ é€’çš„å¼•ç”¨ï¼Ÿ*\nä¸è¿‡è¿™æ ·è®¾è®¡å¯¹äºJavaç¨‹åºå‘˜æ¥è¯´ä¹Ÿæ˜¯èƒ½å¤Ÿç†è§£çš„ã€‚\nå®šä¹‰å¸¸é‡ä½¿ç”¨çš„æ˜¯å…³é”®å­— constï¼Œå¯ä»¥åœ¨ä»»ä½•åœ°æ–¹å®šä¹‰å¸¸é‡,ä½†æ˜¯éœ€è¦æ³¨æ„çš„æ˜¯å®šä¹‰å¸¸é‡çš„æ—¶å€™è¦æŠŠç±»å‹è¡¥å……ä¸Šå»;\nconst A :u8 = 1; fn main() { const C:u16=33; let x = 5; println!(\u0026quot;x has the value {}\u0026quot;, x); }  Rustå˜é‡é®è”½(Shadowing) è¿™æ˜¯ç®—æ˜¯ä¸€ä¸ªæœ‰æ„æ€çš„ç‰¹æ€§å§ã€‚é€šè¿‡å®šä¹‰åŒåçš„å˜é‡æ¥è¿›è¡Œå˜é‡çš„é®è”½;\nfn main() { let x = 5; let x = x + 1; let x = x * 2; println!(\u0026quot;The value of x is: {}\u0026quot;, x); }  å’‹ä¸€çœ‹è¿™ä¸å°±æ˜¯å®šä¹‰ä¸€ä¸ªå˜é‡ç„¶åå¯ä»¥ä¿®æ”¹å®ƒçš„å€¼å˜›ã€‚Javaä¸­éƒ½æœ‰è¿™æ ·çš„,æ¢ä¸ªåå­—å°±å˜æˆ Shadowing äº†ã€‚ - -| é«˜çº§ã€‚ã€‚\npublic static void main(String[] args) { int x = 5; x = x + 1; x = x * 2; System.out.println(x); }  æˆ–è€…ç›¸å½“äº\nfn main() { let mut x = 5; x = x + 1; x = x * 2; println!(\u0026quot;The value of x is: {}\u0026quot;, x); }  å¯¹äºä»¥ä¸Šçš„ä¸¤ç§æ–¹å¼ï¼Œå®˜æ–¹ç»™å‡ºäº†ä¸¤ä¸ªè§£é‡Š:\n Shadowing is different from marking a variable as mut, because weâ€™ll get a compile-time error if we accidentally try to reassign to this variable without using the let keyword. By using let, we can perform a few transformations on a value but have the variable be immutable after those transformations have been completed.\n ç¬¬ä¸€ä¸ªè§£é‡Šå¯ä»¥ç†è§£ä¸ºï¼šå¦‚æœæˆ‘ä»¬ä¸ä½¿ç”¨letå…³é”®æ¥è¿›è¡Œé®è”½ï¼Œé‚£ä¹ˆæ„å‘³ç€letå®šä¹‰çš„å˜é‡æ˜¯å¯å˜çš„ã€‚è¿™ä¼šå¯¼è‡´ç¼–è¯‘å‡ºé”™ï¼Œä¹Ÿä¼šç»™letå…³é”®å­—å¸¦æ¥æ­§ä¹‰ï¼ˆæœ¬èº«ä»£è¡¨çš„æ˜¯ä¸å¯å˜çš„æ„æ€ï¼‰ï¼Œè¿™ä¸ªè§£é‡Šå‹‰å¼ºå¯ä»¥ç†è§£å§ã€‚\n The other difference between mut and shadowing is that because weâ€™re effectively creating a new variable when we use the let keyword again, we can change the type of the value but reuse the same name. For example, say our program asks a user to show how many spaces they want between some text by inputting space characters, but we really want to store that input as a number:\n ç¬¬äºŒä¸ªè§£é‡Šå°±å¾ˆå¥½ç†è§£äº†ï¼Œåªç”¨çœ‹ä¸€ä¸‹å®˜æ–¹çš„åˆ—å­å°±èƒ½æ˜ç™½äº†ã€‚\nfn main() { let spaces = \u0026quot; \u0026quot;; let spaces = spaces.len(); }  å®Œï¼\n","id":16,"section":"posts","summary":"Rustä¸­çš„å˜é‡ä¸å¸¸é‡çš„å®šä¹‰ Rustä¸­å®šä¹‰å˜é‡ä½¿ç”¨çš„å…³é”®å­—æ˜¯ let å…³é”®å­—ï¼Œè¯¥å…³é”®å­—å®šä¹‰çš„å˜é‡æ˜¯ä¸å¯å˜çš„;æƒ³è¦å®šä¹‰ä¸€ä¸ªå¯å˜çš„å˜é‡éœ€è¦å†ä½¿ç”¨ä¸€ä¸ªå…³é”®","tags":["programing","rust"],"title":"Rust Variables","uri":"https://holicc.github.io/2020/07/rust-variable/","year":"2020"},{"content":"å®‰è£…Rust ç›´æ¥åˆ°Rustå®˜æ–¹ç½‘ç«™ æ‰¾åˆ°é€‚åˆè‡ªå·±ç³»ç»Ÿçš„å®‰è£…åŒ…exeæ–‡ä»¶ä¸‹è½½è¿›è¡Œå®‰è£…å°±è¡Œäº†\n\nå®˜æ–¹æä¾›win32ä½å’Œ64ä½çš„å®‰è£…ç‰ˆæœ¬ï¼Œä¸è¿‡ä¸€èˆ¬éƒ½æ˜¯64ä½çš„ã€‚è¿˜æä¾›äº†WSLçš„å®‰è£…ç‰ˆæœ¬ã€‚\nå¦‚æœå®‰è£…rustå¾ˆæ…¢ï¼Œä½¿ç”¨é•œåƒï¼š\n $ENV:RUSTUP_DIST_SERVER=â€˜https://mirrors.ustc.edu.cn/rust-staticâ€˜\n$ENV:RUSTUP_UPDATE_ROOT=â€˜https://mirrors.ustc.edu.cn/rust-static/rustupâ€˜\n ç„¶ååˆ°å¾®è½¯çš„å®˜ç½‘ä¸‹è½½ æ‰¾åˆ°Visual Studio 2019 å·¥å…· ä¸‹è½½å¥½ä¹‹åå°±å¯ä»¥è¿›è¡Œå®‰è£…äº†ã€‚\nå‹¾é€‰åŸºæœ¬çš„C++æ„å»ºç¯å¢ƒ\n\nå†é€‰æ‹©è¯­è¨€åŒ…\n\næœ€åé…ç½®IDEæ’ä»¶ï¼Œæœ¬äººä½¿ç”¨çš„æ˜¯IDEA(ä¹Ÿå¯ä»¥ç”¨Clion)ä½œä¸ºIDEã€‚ç›´æ¥åˆ°å®˜ç½‘æ‰¾åˆ°Rustå¯¹åº”çš„æ’ä»¶RUST-FOR-IDEA\n(ç§»åŠ¨ç½‘çœŸæ˜¯å¤ªåƒåœ¾äº†ï¼Œæ…¢çš„è¦æ­») \nå®‰è£…å®Œä¹‹åé‡å¯IDEAï¼Œåˆ›å»ºé¡¹ç›®çš„æ—¶å€™å°±èƒ½çœ‹åˆ°Rusté¡¹ç›®çš„é€‰é¡¹äº†ã€‚\nç„¶åé…ç½®ä¸€ä¸‹æº(ç±»ä¼¼Mavençš„é˜¿é‡Œæºä¸€æ ·) æ¸…åæº\nå®Œï¼\n","id":17,"section":"posts","summary":"å®‰è£…Rust ç›´æ¥åˆ°Rustå®˜æ–¹ç½‘ç«™ æ‰¾åˆ°é€‚åˆè‡ªå·±ç³»ç»Ÿçš„å®‰è£…åŒ…exeæ–‡ä»¶ä¸‹è½½è¿›è¡Œå®‰è£…å°±è¡Œäº† å®˜æ–¹æä¾›win32ä½å’Œ64ä½çš„å®‰è£…ç‰ˆæœ¬ï¼Œä¸è¿‡ä¸€èˆ¬éƒ½æ˜¯6","tags":["programing","rust"],"title":"Install Rust On Win10","uri":"https://holicc.github.io/2020/07/install-rust-win10/","year":"2020"},{"content":"ç´¢å¼•æ˜¯ä»€ä¹ˆ ç´¢å¼•ï¼ˆåœ¨MySQLä¸­ä¹Ÿç§°ä¸ºâ€œé”®ï¼ˆkeyï¼‰â€ï¼‰ï¼Œç”¨äºå­˜å‚¨å¼•æ“å¿«é€Ÿæ‰¾åˆ°è®°å½•çš„ä¸€ç§æ•°æ®ç»“æ„ã€‚è¿™æ˜¯ç´¢å¼•çš„åŸºç¡€åŠŸèƒ½ã€‚ ç´¢å¼•å¯ä»¥åŒ…å«ä¸€ä¸ªåˆ—æˆ–å¤šä¸ªåˆ—ï¼Œå½“ç´¢å¼•åŒ…å«å¤šä¸ªåˆ—çš„æ—¶å€™ï¼Œé‚£ä¹ˆåˆ—çš„é¡ºåºä¹Ÿååˆ†é‡è¦ï¼Œå› ä¸ºMySQLåªèƒ½ä½¿ç”¨æœ€å·¦å‰ç¼€åˆ—ã€‚\nç´¢å¼•çš„ç›®çš„  ç´¢å¼•å¤§å¤§å‡å°‘äº†æœåŠ¡å™¨æ‰«æçš„æ•°æ®é‡ å¸®åŠ©æœåŠ¡å™¨é¿å…æ’åºå’Œä¸´æ—¶è¡¨ ç´¢å¼•å¯ä»¥å°†éšæœºI/Oå˜ä¸ºé¡ºåºI/O  ç´¢å¼•çš„ç§ç±» åœ¨MySQLä¸­ï¼Œç´¢å¼•æ˜¯ç”±å­˜å‚¨å¼•æ“å®ç°çš„è€Œä¸æ˜¯ç”±æœåŠ¡å±‚å®ç°çš„ï¼Œæ‰€ä»¥å¹¶æ²¡æœ‰åŒä¸€çš„æ ‡å‡†ï¼šä¸åŒå­˜å‚¨å¼•æ“çš„ç´¢å¼•å·¥ä½œæ–¹å¼å¹¶ä¸ä¸€æ ·ï¼Œä¹Ÿä¸æ˜¯æ‰€æœ‰çš„å­˜å‚¨å¼•æ“éƒ½æ”¯æŒæ‰€æœ‰ç±»å‹çš„ç´¢å¼•ã€‚å³æ—¶å¤šä¸ªå­˜å‚¨å¼•æ“æ”¯æŒåŒç§ç´¢å¼•ï¼Œå…¶åº•å±‚å®ç°ä¹Ÿå¯èƒ½ä¸åŒã€‚\nB-Treeç´¢å¼• B-Treeæ˜¯ä¸ºç£ç›˜ç­‰å¤–å­˜å‚¨è®¾å¤‡è®¾è®¡çš„ä¸€ç§å¹³è¡¡æŸ¥æ‰¾æ ‘ã€‚å› æ­¤åœ¨è®²B-Treeä¹‹å‰å…ˆäº†è§£ä¸‹ç£ç›˜çš„ç›¸å…³çŸ¥è¯†ã€‚\nç³»ç»Ÿä»ç£ç›˜è¯»å–æ•°æ®åˆ°å†…å­˜æ—¶æ˜¯ä»¥ç£ç›˜å—ï¼ˆblockï¼‰ä¸ºåŸºæœ¬å•ä½çš„ï¼Œä½äºåŒä¸€ä¸ªç£ç›˜å—ä¸­çš„æ•°æ®ä¼šè¢«ä¸€æ¬¡æ€§è¯»å–å‡ºæ¥ï¼Œè€Œä¸æ˜¯éœ€è¦ä»€ä¹ˆå–ä»€ä¹ˆã€‚\nInnoDBå­˜å‚¨å¼•æ“ä¸­æœ‰ é¡µï¼ˆPageï¼‰ çš„æ¦‚å¿µï¼Œé¡µæ˜¯å…¶ç£ç›˜ç®¡ç†çš„æœ€å°å•ä½ã€‚InnoDBå­˜å‚¨å¼•æ“ä¸­é»˜è®¤æ¯ä¸ªé¡µçš„å¤§å°ä¸º16KBï¼Œå¯é€šè¿‡å‚æ•°innodb_page_sizeå°†é¡µçš„å¤§å°è®¾ç½®ä¸º4Kã€8Kã€16Kï¼Œåœ¨MySQLä¸­å¯é€šè¿‡å¦‚ä¸‹å‘½ä»¤æŸ¥çœ‹é¡µçš„å¤§å°ï¼š\n show variables like 'innodb_page_size';\n è€Œç³»ç»Ÿä¸€ä¸ªç£ç›˜å—çš„å­˜å‚¨ç©ºé—´å¾€å¾€æ²¡æœ‰è¿™ä¹ˆå¤§ï¼Œå› æ­¤InnoDBæ¯æ¬¡ç”³è¯·ç£ç›˜ç©ºé—´æ—¶éƒ½ä¼šæ˜¯è‹¥å¹²åœ°å€è¿ç»­ç£ç›˜å—æ¥è¾¾åˆ°é¡µçš„å¤§å°16KBã€‚InnoDBåœ¨æŠŠç£ç›˜æ•°æ®è¯»å…¥åˆ°ç£ç›˜æ—¶ä¼šä»¥é¡µä¸ºåŸºæœ¬å•ä½ï¼Œåœ¨æŸ¥è¯¢æ•°æ®æ—¶å¦‚æœä¸€ä¸ªé¡µä¸­çš„æ¯æ¡æ•°æ®éƒ½èƒ½æœ‰åŠ©äºå®šä½æ•°æ®è®°å½•çš„ä½ç½®ï¼Œè¿™å°†ä¼šå‡å°‘ç£ç›˜I/Oæ¬¡æ•°ï¼Œæé«˜æŸ¥è¯¢æ•ˆç‡ã€‚\nB-Treeç»“æ„çš„æ•°æ®å¯ä»¥è®©ç³»ç»Ÿé«˜æ•ˆçš„æ‰¾åˆ°æ•°æ®æ‰€åœ¨çš„ç£ç›˜å—ã€‚ä¸ºäº†æè¿°B-Treeï¼Œé¦–å…ˆå®šä¹‰ä¸€æ¡è®°å½•ä¸ºä¸€ä¸ªäºŒå…ƒç»„[key, data] ï¼Œkeyä¸ºè®°å½•çš„é”®å€¼ï¼Œå¯¹åº”è¡¨ä¸­çš„ä¸»é”®å€¼ï¼Œdataä¸ºä¸€è¡Œè®°å½•ä¸­é™¤ä¸»é”®å¤–çš„æ•°æ®ã€‚å¯¹äºä¸åŒçš„è®°å½•ï¼Œkeyå€¼äº’ä¸ç›¸åŒã€‚\n\næ¯ä¸ªèŠ‚ç‚¹å ç”¨ä¸€ä¸ªç›˜å—çš„ç£ç›˜ç©ºé—´ï¼Œä¸€ä¸ªèŠ‚ç‚¹ä¸Šæœ‰ä¸¤ä¸ªå‡åºæ’åºçš„å…³é”®å­—å’Œä¸‰ä¸ªæŒ‡å‘å­æ ‘æ ¹èŠ‚ç‚¹çš„æŒ‡é’ˆï¼ŒæŒ‡é’ˆå­˜å‚¨çš„æ˜¯å­èŠ‚ç‚¹æ‰€åœ¨ç£ç›˜å—çš„åœ°å€ã€‚ä¸¤ä¸ªå…³é”®è¯åˆ’åˆ†æˆçš„ä¸‰ä¸ªèŒƒå›´åŸŸå¯¹åº”ä¸‰ä¸ªæŒ‡é’ˆæŒ‡å‘çš„å­æ ‘çš„æ•°æ®çš„èŒƒå›´åŸŸã€‚ä»¥æ ¹èŠ‚ç‚¹ä¸ºä¾‹ï¼Œå…³é”®å­—ä¸º17å’Œ35ï¼ŒP1æŒ‡é’ˆæŒ‡å‘çš„å­æ ‘çš„æ•°æ®èŒƒå›´ä¸ºå°äº17ï¼ŒP2æŒ‡é’ˆæŒ‡å‘çš„å­æ ‘çš„æ•°æ®èŒƒå›´ä¸º17~35ï¼ŒP3æŒ‡é’ˆæŒ‡å‘çš„å­æ ‘çš„æ•°æ®èŒƒå›´ä¸ºå¤§äº35ã€‚\nB+Treeç´¢å¼• ä»B-Treeç»“æ„å›¾ä¸­å¯ä»¥çœ‹åˆ°æ¯ä¸ªèŠ‚ç‚¹ä¸­ä¸ä»…åŒ…å«æ•°æ®çš„keyå€¼ï¼Œè¿˜æœ‰dataå€¼ã€‚è€Œæ¯ä¸€ä¸ªé¡µçš„å­˜å‚¨ç©ºé—´æ˜¯æœ‰é™çš„ï¼Œå¦‚æœdataæ•°æ®è¾ƒå¤§æ—¶å°†ä¼šå¯¼è‡´æ¯ä¸ªèŠ‚ç‚¹ï¼ˆå³ä¸€ä¸ªé¡µï¼‰èƒ½å­˜å‚¨çš„keyçš„æ•°é‡å¾ˆå°ï¼Œå½“å­˜å‚¨çš„æ•°æ®é‡å¾ˆå¤§æ—¶åŒæ ·ä¼šå¯¼è‡´B-Treeçš„æ·±åº¦è¾ƒå¤§ï¼Œå¢å¤§æŸ¥è¯¢æ—¶çš„ç£ç›˜I/Oæ¬¡æ•°ï¼Œè¿›è€Œå½±å“æŸ¥è¯¢æ•ˆç‡ã€‚åœ¨B+Treeä¸­ï¼Œæ‰€æœ‰æ•°æ®è®°å½•èŠ‚ç‚¹éƒ½æ˜¯æŒ‰ç…§é”®å€¼å¤§å°é¡ºåºå­˜æ”¾åœ¨åŒä¸€å±‚çš„å¶å­èŠ‚ç‚¹ä¸Šï¼Œè€Œéå¶å­èŠ‚ç‚¹ä¸Šåªå­˜å‚¨keyå€¼ä¿¡æ¯ï¼Œè¿™æ ·å¯ä»¥å¤§å¤§åŠ å¤§æ¯ä¸ªèŠ‚ç‚¹å­˜å‚¨çš„keyå€¼æ•°é‡ï¼Œé™ä½B+Treeçš„é«˜åº¦ã€‚\nç”±äºB+Treeçš„éå¶å­èŠ‚ç‚¹åªå­˜å‚¨é”®å€¼ä¿¡æ¯ï¼Œå‡è®¾æ¯ä¸ªç£ç›˜å—èƒ½å­˜å‚¨4ä¸ªé”®å€¼åŠæŒ‡é’ˆä¿¡æ¯ï¼Œåˆ™å˜æˆB+Treeåå…¶ç»“æ„å¦‚ä¸‹å›¾æ‰€ç¤ºï¼š\n\né€‚ç”¨æ¡ä»¶ï¼š\n å…¨å€¼åŒ¹é… åŒ¹é…æœ€å·¦å‰ç¼€ åŒ¹é…èŒƒå›´å€¼ ç²¾ç¡®åŒ¹é…æŸä¸€åˆ—å¹¶èŒƒå›´åŒ¹é…å¦ä¸€åˆ— å€¼è®¿é—®ç´¢å¼•çš„æŸ¥è¯¢  é™åˆ¶ï¼š\n å¦‚æœä¸æ˜¯æŒ‰ç…§ç´¢å¼•çš„æœ€å·¦åˆ—å¼€å§‹æŸ¥æ‰¾ï¼Œåˆ™æ— æ³•ä½¿ç”¨ç´¢å¼• ä¸èƒ½è·³è¿‡ç´¢å¼•ä¸­çš„åˆ— å¦‚æœæŸ¥è¯¢ä¸­æœ‰æŸä¸ªåˆ—çš„èŒƒå›´æŸ¥è¯¢ï¼Œåˆ™å…¶å³è¾¹æ‰€æœ‰åˆ—éƒ½æ— æ³•ä½¿ç”¨ç´¢å¼•ä¼˜åŒ–æŸ¥æ‰¾  Hashç´¢å¼• å“ˆå¸Œç´¢å¼•ï¼ˆhash indexï¼‰åŸºäºå“ˆå¸Œè¡¨å®ç°ï¼Œåªæœ‰ç²¾ç¡®åŒ¹é…ç´¢å¼•æ‰€æœ‰åˆ—çš„æŸ¥è¯¢æ‰æœ‰æ•ˆï¼Œå¯¹äºæ¯ä¸€è¡Œæ•°æ®ï¼Œå­˜å‚¨å¼•æ“éƒ½ä¼šå¯¹æ‰€æœ‰çš„ç´¢å¼•åˆ—è®¡ç®—ä¸€ä¸ªå“ˆå¸Œå€¼ï¼Œå“ˆå¸Œå€¼æ˜¯ä¸€ä¸ªè¾ƒå°çš„å€¼ï¼Œå¹¶ä¸åŒçš„é”®å€¼çš„è¡Œè®¡ç®—çš„å“ˆå¸Œå€¼ä¹Ÿä¸ä¸€æ ·ã€‚å“ˆå¸Œç´¢å¼•å°†æ‰€æœ‰çš„å“ˆå¸Œå€¼å­˜å‚¨åœ¨ç´¢å¼•ä¸­ï¼ŒåŒæ—¶åœ¨å“ˆå¸Œè¡¨ä¸­ä¿å­˜æŒ‡å‘æ¯ä¸ªæ•°æ®è¡Œçš„æŒ‡é’ˆã€‚\né™åˆ¶ï¼š\n å“ˆå¸Œç´¢å¼•åªåŒ…å«å“ˆå¸Œå€¼å’Œè¡ŒæŒ‡é’ˆï¼Œä¸å­˜å‚¨å­—æ®µå€¼ï¼Œæ‰€ä»¥ä¸èƒ½ä½¿ç”¨ç´¢å¼•ä¸­çš„å­—æ®µé¿å…è¯»å–è¡Œ å“ˆå¸Œç´¢å¼•æ•°æ®æ— æ³•ç”¨äºæ’åº ä¸æ”¯æŒç´¢å¼•åˆ—åŒ¹é…æŸ¥æ‰¾ï¼Œä¾‹å¦‚ï¼Œåœ¨æ•°æ®åˆ—ï¼ˆAï¼ŒBï¼‰ä¸Šå»ºç«‹çš„ç´¢å¼•ï¼Œå¦‚æœæŸ¥è¯¢åªç”¨åˆ°åˆ—Aåˆ—åˆ™æ— æ³•ä½¿ç”¨è¯¥ç´¢å¼• å“ˆå¸Œç´¢å¼•åªæ”¯æŒç­‰å€¼æ¯”è¾ƒæŸ¥è¯¢ å“ˆå¸Œå†²çªå¤ªå¤šä¼šå¯¼è‡´æ€§èƒ½å¾ˆä½  InnoDBä¸­æœ‰ä¸€ä¸ªç‰¹æ®Šçš„åŠŸèƒ½å«åšâ€œè‡ªé€‚åº”ç´¢å¼•â€InnoDBä¼šæ³¨æ„åˆ°ä½¿ç”¨éå¸¸é¢‘ç¹çš„ç´¢å¼•å€¼ï¼Œä¼šåœ¨å†…å­˜ä¸­åŸºäºB-Treeç´¢å¼•ä¹‹ä¸Šå†åˆ›å»ºä¸€ä¸ªå“ˆå¸Œç´¢å¼•ã€‚\nå¦‚ä½•æ­£ç¡®çš„ä½¿ç”¨ç´¢å¼• ç‹¬ç«‹çš„åˆ— â€œç‹¬ç«‹çš„åˆ—â€æ˜¯æŒ‡ç´¢å¼•åˆ—ä¸èƒ½æ˜¯è¡¨è¾¾å¼çš„ä¸€éƒ¨åˆ†ï¼Œä¹Ÿä¸èƒ½æ˜¯å‡½æ•°çš„å‚æ•°ã€‚\nä¾‹å¦‚ï¼š\n mysql\u0026gt; SELECT actor_id from actors where actor_id +1 =5 ;\n è¿™ä¸ªä¾‹å­å°±æ— æ³•ä½¿ç”¨ç´¢å¼•åˆ— actor_id ã€‚æ‰€ä»¥åœ¨ä½¿ç”¨WHEREæ¡ä»¶çš„æ—¶å€™ï¼Œå§‹ç»ˆå°†ç´¢å¼•åˆ—å•ç‹¬æ”¾åœ¨æ¯”è¾ƒç¬¦å·çš„ä¸€ä¾§ï¼Œä¹Ÿä¸èƒ½å¯¹ç´¢å¼•åˆ—ä½¿ç”¨å‡½æ•°ã€‚\nå‰ç¼€ç´¢å¼•å’Œç´¢å¼•é€‰æ‹©æ€§ ç”±äºéœ€è¦ç´¢å¼•åˆ—æ˜¯ä¸€ä¸ªå¾ˆé•¿çš„å­—ç¬¦ä¸²ï¼Œè¿™æ ·ä¼šå¯¼è‡´ç´¢å¼•è¾¹çš„æ…¢ä¸”å¤§ã€‚è¿™æ—¶å¯ä»¥é€šè¿‡ä½¿ç”¨å‰ç¼€ç´¢å¼•æ¥è§£å†³ï¼Œè¿™æ ·å¯ä»¥å¤§å¤§èŠ‚çº¦ç´¢å¼•ç©ºé—´ï¼Œä»è€Œæé«˜ç´¢å¼•æ•ˆç‡ã€‚ä½†æ˜¯è¿™æ ·ä¼šé™ä½ç´¢å¼•çš„é€‰æ‹©æ€§ã€‚\n é€‰æ‹©æ€§=è¡¥å……åº¦çš„ç´¢å¼•å€¼(åŸºæ•°)/æ•°æ®è¡¨çš„è®°å½•æ—¶æ€»æ•°\n ç´¢å¼•çš„é€‰æ‹©æ€§è¶Šé«˜åˆ™æŸ¥è¯¢æ•ˆç‡è¶Šé«˜ï¼Œå”¯ä¸€ç´¢å¼•çš„é€‰æ‹©æ€§æ˜¯1ï¼Œè¿™æ—¶æœ€å¥½çš„ç´¢å¼•é€‰æ‹©æ€§ï¼Œæ€§èƒ½ä¹Ÿæ˜¯æœ€å¥½çš„ã€‚\nå¤šåˆ—ç´¢å¼• åœ¨å¤šä¸ªåˆ—ä¸Šå»ºç«‹ç‹¬ç«‹çš„å•åˆ—ç´¢å¼•å¤§éƒ¨åˆ†æƒ…å†µä¸‹å¹¶ä¸èƒ½æé«˜MySQLçš„æŸ¥è¯¢æ€§èƒ½ã€‚æ–°ç‰ˆæœ¬çš„MySQLä¸­å¼•å…¥äº†ä¸€ç§å«â€œç´¢å¼•åˆå¹¶â€çš„ç­–ç•¥\nèšç°‡ç´¢å¼• èšæ—ç´¢å¼•å¹¶ä¸æ˜¯ä¸€ç§å•ç‹¬çš„ç´¢å¼•ç±»å‹ï¼Œè€Œæ˜¯ä¸€ç§æ•°æ®å­˜å‚¨æ–¹å¼ã€‚InnoDBèšæ—ç´¢å¼•å®é™…ä¸Šåœ¨åŒä¸€ä¸ªç»“æ„ä¸­ä¿å­˜äº†B-Treeç´¢å¼•å’Œæ•°æ®è¡Œ\nèšç°‡ç´¢å¼•å°±æ˜¯æŒ‰ç…§æ¯å¼ è¡¨çš„ä¸»é”®æ„é€ ä¸€é¢—B+æ ‘ï¼ŒåŒæ—¶å¶å­èŠ‚ç‚¹ä¸­å­˜æ”¾çš„å°±æ˜¯æ•´å¼ è¡¨çš„è¡Œè®°å½•æ•°æ®ï¼Œä¹Ÿå°†èšé›†ç´¢å¼•çš„å¶å­èŠ‚ç‚¹ç§°ä¸ºæ•°æ®é¡µã€‚è¿™ä¸ªç‰¹æ€§å†³å®šäº†ç´¢å¼•ç»„ç»‡è¡¨ä¸­æ•°æ®ä¹Ÿæ˜¯ç´¢å¼•çš„ä¸€éƒ¨åˆ†ï¼Œæ¯å¼ è¡¨åªèƒ½æ‹¥æœ‰ä¸€ä¸ªèšç°‡ç´¢å¼•ã€‚\nèšç°‡ç´¢å¼•çš„æ¯ä¸€ä¸ªå¶èŠ‚ç‚¹éƒ½åŒ…å«äº†ä¸»é”®å€¼ã€ äº‹åŠ¡IDã€ ç”¨äºäº‹åŠ¡å’ŒMVCCçš„å›æ»šæŒ‡é’ˆã€ä»¥åŠå‰©ä½™çš„åˆ—\n\nInnodbé€šè¿‡ä¸»é”®èšé›†æ•°æ®ï¼Œå¦‚æœæ²¡æœ‰å®šä¹‰ä¸»é”®ï¼Œinnodbä¼šé€‰æ‹©éç©ºçš„å”¯ä¸€ç´¢å¼•ä»£æ›¿ã€‚å¦‚æœæ²¡æœ‰è¿™æ ·çš„ç´¢å¼•ï¼Œinnodbä¼šéšå¼çš„å®šä¹‰ä¸€ä¸ªä¸»é”®æ¥ä½œä¸ºèšç°‡ç´¢å¼•ã€‚\nèšç°‡ç´¢å¼•çš„ä¼˜ç¼ºç‚¹\n ä¼˜ç‚¹ï¼š  æ•°æ®è®¿é—®æ›´å¿«ï¼Œå› ä¸ºèšç°‡ç´¢å¼•å°†ç´¢å¼•å’Œæ•°æ®ä¿å­˜åœ¨åŒä¸€ä¸ªB+æ ‘ä¸­ï¼Œå› æ­¤ä»èšç°‡ç´¢å¼•ä¸­è·å–æ•°æ®æ¯”éèšç°‡ç´¢å¼•æ›´å¿« èšç°‡ç´¢å¼•å¯¹äºä¸»é”®çš„æ’åºæŸ¥æ‰¾å’ŒèŒƒå›´æŸ¥æ‰¾é€Ÿåº¦éå¸¸å¿« ä½¿ç”¨ è¦†ç›–ç´¢å¼• æ‰«æçš„æŸ¥è¯¢å¯ä»¥ç›´æ¥ä½¿ç”¨é¡µèŠ‚ç‚¹ä¸­çš„ä¸»é”®å€¼  ç¼ºç‚¹ï¼š  æ’å…¥é€Ÿåº¦ä¸¥é‡ä¾èµ–äºæ’å…¥é¡ºåºï¼ŒæŒ‰ç…§ä¸»é”®çš„é¡ºåºæ’å…¥æ˜¯æœ€å¿«çš„æ–¹å¼ï¼Œå¦åˆ™å°†ä¼šå‡ºç°é¡µåˆ†è£‚ï¼Œä¸¥é‡å½±å“æ€§èƒ½(ä¾‹å¦‚ï¼šä½¿ç”¨UUIDä½œä¸ºç´¢å¼•ï¼Œå®ƒä¼šä½¿æ’å…¥è¾¹çš„å®Œå…¨éšæœºå°±ä¼šé€ æˆé¡µåˆ†è£‚å’Œäº§ç”Ÿéšæœºç¢ç‰‡)ã€‚å› æ­¤ï¼Œå¯¹äºInnoDBè¡¨ï¼Œæˆ‘ä»¬ä¸€èˆ¬éƒ½ä¼šå®šä¹‰ä¸€ä¸ªè‡ªå¢çš„IDåˆ—ä¸ºä¸»é”® æ›´æ–°ä¸»é”®çš„ä»£ä»·å¾ˆé«˜ï¼Œå› ä¸ºå°†ä¼šå¯¼è‡´è¢«æ›´æ–°çš„è¡Œç§»åŠ¨ã€‚å› æ­¤ï¼Œå¯¹äºInnoDBè¡¨ï¼Œæˆ‘ä»¬ä¸€èˆ¬å®šä¹‰ä¸»é”®ä¸ºä¸å¯æ›´æ–°ã€‚ äºŒçº§ç´¢å¼•è®¿é—®éœ€è¦ä¸¤æ¬¡ç´¢å¼•æŸ¥æ‰¾ï¼Œç¬¬ä¸€æ¬¡æ‰¾åˆ°ä¸»é”®å€¼ï¼Œç¬¬äºŒæ¬¡æ ¹æ®ä¸»é”®å€¼æ‰¾åˆ°è¡Œæ•°æ®ã€‚ èšç°‡ç´¢å¼•å¯èƒ½å¯¼è‡´å…¨è¡¨æ‰«æå˜æ…¢ï¼Œå°¤å…¶æ˜¯è¡Œæ¯”è¾ƒç¨€ç–ï¼Œæˆ–è€…ç”±äº é¡µåˆ†è£‚ å¯¼è‡´æ•°æ®å­˜å‚¨ä¸è¿ç»­çš„æ—¶å€™   è¾…åŠ©ç´¢å¼•ï¼ˆéèšç°‡ç´¢å¼•ï¼‰ åœ¨èšç°‡ç´¢å¼•ä¹‹ä¸Šåˆ›å»ºçš„ç´¢å¼•ç§°ä¹‹ä¸ºè¾…åŠ©ç´¢å¼•ï¼Œè¾…åŠ©ç´¢å¼•è®¿é—®æ•°æ®æ€»æ˜¯éœ€è¦äºŒæ¬¡æŸ¥æ‰¾ã€‚è¾…åŠ©ç´¢å¼•å¶å­èŠ‚ç‚¹å­˜å‚¨çš„ä¸å†æ˜¯è¡Œçš„ç‰©ç†ä½ç½®ï¼Œè€Œæ˜¯ä¸»é”®å€¼ã€‚é€šè¿‡è¾…åŠ©ç´¢å¼•é¦–å…ˆæ‰¾åˆ°çš„æ˜¯ä¸»é”®å€¼ï¼Œå†é€šè¿‡ä¸»é”®å€¼æ‰¾åˆ°æ•°æ®è¡Œçš„æ•°æ®é¡µï¼Œå†é€šè¿‡æ•°æ®é¡µä¸­çš„Page Directoryæ‰¾åˆ°æ•°æ®è¡Œã€‚\nInnodbè¾…åŠ©ç´¢å¼•çš„å¶å­èŠ‚ç‚¹å¹¶ä¸åŒ…å«è¡Œè®°å½•çš„å…¨éƒ¨æ•°æ®ï¼Œå¶å­èŠ‚ç‚¹é™¤äº†åŒ…å«é”®å€¼å¤–ï¼Œè¿˜åŒ…å«äº†ç›¸åº”è¡Œæ•°æ®çš„èšç°‡ç´¢å¼•é”®ã€‚è¿™æ ·çš„ç­–ç•¥å‡å°‘äº†å½“å‡ºç°è¡Œç§»åŠ¨æˆ–è€…æ•°æ®é¡µåˆ†è£‚æ—¶äºŒçº§ç´¢å¼•çš„ç»´æŠ¤å·¥ä½œã€‚ä½¿ç”¨ä¸»é”®å½“ä½œæŒ‡é’ˆä¼šè®©äºŒçº§ç´¢å¼•å ç”¨æ›´å¤šçš„ç©ºé—´ï¼Œæ¢æ¥çš„å¥½å¤„æ˜¯ï¼ŒInnoDBåœ¨ç§»åŠ¨è¡Œæ—¶æ— é¡»æ›´æ–°äºŒçº§ç´¢å¼•ä¸­çš„è¿™ä¸ªâ€œæŒ‡é’ˆâ€\nè¾…åŠ©ç´¢å¼•çš„å­˜åœ¨ä¸å½±å“æ•°æ®åœ¨èšç°‡ç´¢å¼•ä¸­çš„ç»„ç»‡ï¼Œæ‰€ä»¥ä¸€å¼ è¡¨å¯ä»¥æœ‰å¤šä¸ªè¾…åŠ©ç´¢å¼•ã€‚åœ¨innodbä¸­æœ‰æ—¶ä¹Ÿç§°è¾…åŠ©ç´¢å¼•ä¸ºäºŒçº§ç´¢å¼•ã€‚\n\nä¸MyISAMå¼•æ“ä¸­ç´¢å¼•çš„åŒºåˆ«å¦‚ä¸‹å›¾ï¼š\n\nè¦†ç›–ç´¢å¼• å¦‚æœä¸€ä¸ªç´¢å¼•åŒ…å«ï¼ˆæˆ–è€…è¯´æ˜¯è¦†ç›–ï¼‰æ‰€æœ‰éœ€è¦æŸ¥è¯¢çš„å­—æ®µçš„å€¼ï¼Œæˆ‘ä»¬å°±ç§°ä¹‹ä¸ºâ€œè¦†ç›–ç´¢å¼•â€ï¼Œè¦†ç›–ç´¢å¼•çš„ä¼˜ç‚¹æœ¬è´¨ä¸Šå°±ä¸€æ¡ï¼šè¦†ç›–ç´¢å¼•èƒ½å¤Ÿé¿å… *å›è¡¨*ï¼›\nä¸æ˜¯æ‰€æœ‰ç±»å‹çš„ç´¢å¼•éƒ½å¯ä»¥ç§°ä¸ºè¦†ç›–æ‰€æœ‰ã€‚è¦†ç›–æ‰€æœ‰å¿…é¡»è¦å­˜å‚¨ç´¢å¼•åˆ—çš„å€¼ï¼Œè€Œå“ˆå¸Œç´¢å¼•ã€ç©ºé—´ç´¢å¼•å’Œå…¨æ–‡ç´¢å¼•ç­‰éƒ½ä¸å­˜å‚¨ç´¢å¼•åˆ—çš„å€¼ï¼Œæ‰€ä»¥MySQLåªèƒ½ä½¿ç”¨B-Treeç´¢å¼•åšè¦†ç›–ç´¢å¼•ã€‚\nå½“å‘èµ·ä¸€ä¸ªè¢«ç´¢å¼•è¦†ç›–çš„æŸ¥è¯¢ï¼ˆä¹Ÿå«åšç´¢å¼•è¦†ç›–æŸ¥è¯¢ï¼‰æ—¶ï¼Œåœ¨EXPLAINçš„Extraåˆ—å¯ä»¥çœ‹åˆ°â€œUsing indexâ€çš„ä¿¡æ¯\nMySQLæŸ¥è¯¢ä¼˜åŒ–å™¨ä¼šåœ¨æ‰§è¡ŒæŸ¥è¯¢å‰åˆ¤æ–­æ˜¯å¦æœ‰ä¸€ä¸ªç´¢å¼•èƒ½å¤Ÿè¿›è¡Œè¦†ç›–\nå‚è€ƒ  èšç°‡ç´¢å¼•å’Œéèšç°‡ç´¢å¼•(é€šä¿—æ˜“æ‡‚ è¨€ç®€æ„èµ…) Mysql ç´¢å¼•  ","id":18,"section":"posts","summary":"ç´¢å¼•æ˜¯ä»€ä¹ˆ ç´¢å¼•ï¼ˆåœ¨MySQLä¸­ä¹Ÿç§°ä¸ºâ€œé”®ï¼ˆkeyï¼‰â€ï¼‰ï¼Œç”¨äºå­˜å‚¨å¼•æ“å¿«é€Ÿæ‰¾åˆ°è®°å½•çš„ä¸€ç§æ•°æ®ç»“æ„ã€‚è¿™æ˜¯ç´¢å¼•çš„åŸºç¡€åŠŸèƒ½ã€‚ ç´¢å¼•å¯ä»¥åŒ…å«ä¸€ä¸ªåˆ—æˆ–å¤šä¸ª","tags":["index","mysql"],"title":"MySQL ç´¢å¼•","uri":"https://holicc.github.io/2020/03/about-mysql-index/","year":"2020"},{"content":"TCPæ˜¯ä»€ä¹ˆ ? ä¼ è¾“æ§åˆ¶åè®®ï¼ˆTCPï¼‰æ˜¯äº’è”ç½‘åè®®ç»„ä¸­é‡è¦çš„ç»„æˆéƒ¨åˆ†ä¹‹ä¸€ã€‚TCPçš„å®ç°ä¹‹åˆæ˜¯ä¸ºäº†è¡¥å……äº’è”ç½‘åè®®ï¼ˆIPï¼‰ã€‚å› æ­¤ï¼Œè¿™ä¸€å¯¹ç»„åˆç»å¸¸è¢«ç§°ä¸ºTCP/IPã€‚TCPåè®®çš„ç‰¹ç‚¹ï¼šå¯é æ€§ã€é¡ºåºæ€§ã€é”™è¯¯æ£€æŸ¥ã€æ•°æ®æµä¼ è¾“ã€‚å¤§éƒ¨åˆ†å¸¸è§çš„åº”ç”¨éƒ½æ˜¯ä½¿ç”¨çš„æ˜¯TCPåè®®ï¼Œä¾‹å¦‚ï¼šWorld Wide Webã€Emailã€æ–‡ä»¶ä¼ è¾“.TCPæ˜¯é¢å‘è¿æ¥çš„ï¼Œè¿™å°±éœ€è¦å®¢æˆ·ç«¯ä¸»åŠ¨ä¸æœåŠ¡ç«¯å»ºç«‹èµ·è¿æ¥ä¹‹åæ‰èƒ½å¼€å§‹ä¼ è¾“æ•°æ®ã€‚å¦‚æœåº”ç”¨ä¸éœ€è¦å¯é çš„æ•°æ®æµä¼ è¾“æœåŠ¡å¯èƒ½UPDåè®®æ˜¯ä¸ªæ›´å¥½çš„é€‰æ‹©ã€‚\nä¸ºä»€ä¹ˆéœ€è¦TCP ? TCPæ˜¯ä¸ªé‡è¦çš„åè®®æ˜¯å› ä¸ºå®ƒåœ¨äº’è”ç½‘çš„åŸºç¡€ä¸Šå»ºç«‹äº†ä¸€å¥—è§„åˆ™ä¸æ ‡å‡†åŒ–çš„ä¿¡æ¯æ•°æ®ä¼ è¾“æœºåˆ¶ã€‚TCPè®©äº’è”ç½‘ä¹‹é—´çš„æ•°æ®ä¼ è¾“èƒ½å¤Ÿæ— è§†å„ç§æ¡ä»¶çš„é™åˆ¶ï¼ˆä¸ç®¡æ˜¯åœ°åŒºé™åˆ¶ã€è½¯ä»¶æˆ–ç¡¬ä»¶çš„é™åˆ¶ï¼‰ï¼Œå¹¶ä¸”å®ƒæ˜¯çµæ´»çš„å¯æ‹“å±•çš„ï¼ˆæ¯”å¦‚TCP/IPã€å¢åŠ SSLç­‰ï¼‰ï¼Œå¹¶ä¸”å®ƒæ˜¯å¼€æºçš„ä¸æ˜¯ç§äººæ‰€æœ‰ã€‚\nå¦‚ä½•ä¿è¯ä¼ è¾“çš„å¯é æ€§? TCP segment structure TCPæŠ¥æ–‡æ®µåˆ†ä¸ºä¸¤æ®µï¼šæŠ¥å¤´ã€æ•°æ®æ®µã€‚æŠ¥å¤´åŒ…å«10ä¸ªå­—æ®µå’Œä¸€ä¸ªå¯é€‰çš„æ‹“å±•å­—æ®µã€‚æ•°æ®æ®µç´§è·Ÿåœ¨ æŠ¥å¤´åé¢ï¼Œé‡Œé¢è£…çš„éƒ½æ˜¯åº”ç”¨ä¼ è¾“çš„æ•°æ®ã€‚æ•°æ®çš„å¤§å°ï¼ˆlengthï¼‰ä¸åŒ…æ‹¬åœ¨ æŠ¥å¤´ä¸­ï¼›ä½†æ˜¯å¯ä»¥é€šè¿‡IPæ•°æ®æŠ¥çš„æŠ¥å¤´ä¸­æŒ‡å®šçš„é•¿åº¦å‡å»TCPæŠ¥å¤´çš„é•¿åº¦å°±å¾—åˆ°äº†æ•°æ®æ®µçš„å¤§å°äº†ã€‚\n\næºç«¯å£(16 bits) \u0026amp; ç›®çš„ç«¯å£(16 bits) æœ¬æœºç«¯å£å’Œç›®çš„åœ°ç«¯å£\nåºåˆ—å·(32 bits) åºåˆ—å·å°±æ˜¯ç”¨æ¥æ ‡è®°æ¯ä¸€ä¸ªè¯·æ±‚çš„ï¼Œç›¸å½“äºè¯·æ±‚çš„IDã€‚\n å¦‚æœå«æœ‰åŒæ­¥æ ‡è¯†ï¼ˆSYNï¼‰ï¼Œåˆ™æ­¤ä¸ºæœ€åˆçš„åºåˆ—å·ï¼›ç¬¬ä¸€ä¸ªæ•°æ®æ¯”ç‰¹çš„åºåˆ—ç ä¸ºæœ¬åºåˆ—å·åŠ ä¸€ å¦‚æœæ²¡æœ‰åŒæ­¥æ ‡è¯†ï¼ˆSYNï¼‰ï¼Œåˆ™æ­¤ä¸ºç¬¬ä¸€ä¸ªæ•°æ®æ¯”ç‰¹çš„åºåˆ—ç   ç¡®è®¤å· (32 bits) ACKå¦‚æœè¢«å¯ç”¨äº†ï¼Œé‚£ä¹ˆè¡¨ç¤ºæ”¶åˆ°ä¿¡æ¯ï¼Œå¹¶ä¸”ACK=ï¼ˆå‘é€è€…çš„åºåˆ—å·+1ï¼‰ç”¨äºéªŒè¯ã€‚\nè¿æ¥å»ºç«‹ TCPè¿æ¥çš„å»ºç«‹éœ€è¦è¿›è¡Œä¸‰æ¬¡æ¡æ‰‹ã€‚åœ¨å®¢æˆ·ç«¯å°è¯•è¿æ¥æœåŠ¡ç«¯ä¹‹å‰ï¼ŒæœåŠ¡ç«¯éœ€è¦ç»‘å®šä¸€ä¸ªç«¯å£å¹¶ç›‘å¬å®ƒï¼ˆpassive openï¼‰ï¼Œä¹‹åå®¢æˆ·ç«¯ä¼šä¸»åŠ¨å‘æœåŠ¡ç«¯å‘é€å»ºç«‹è¿æ¥è¯·æ±‚ï¼Œå¹¶è¿›è¡Œ ä¸‰æ¬¡æ¡æ‰‹ å»ºç«‹è¿æ¥ã€‚\n1.å®¢æˆ·ç«¯å‘æœåŠ¡ç«¯å‘èµ·ä¸€ä¸ª SYNè¯·æ±‚ï¼Œå¹¶å°†ç”Ÿæˆä¸€ä¸ªéšæœºçš„åºåˆ—å·Aã€‚\n2.ä½œä¸ºå“åº”ï¼ŒæœåŠ¡ç«¯å›å¤å¸¦æœ‰SYN-ACKæ ‡ç¤ºçš„åº”ç­”ã€‚å…¶ä¸­ACK=A+1ï¼Œå¹¶åŒæ—¶ç”Ÿæˆä¸€ä¸ªéšæœºåºåˆ—å·Bã€‚\n3.æœ€åï¼Œå®¢æˆ·ç«¯æ”¶åˆ°æœåŠ¡ç«¯çš„ACKåº”ç­”ä¹‹åã€‚å®¢æˆ·ç«¯åˆä¼šç»™æœåŠ¡ç«¯ä¸€ä¸ªACKåº”ç­”å¹¶ä¸”åºåˆ—å·ä¹Ÿä¼šåŠ ä¸€ä¹ŸA+1ï¼Œç„¶åACKçš„åºåˆ—å·ä¹ŸåŠ ä¸€B+1\nåˆ°è¿™æ—¶å€™ï¼Œå®¢æˆ·ç«¯å’ŒæœåŠ¡ç«¯éƒ½æ”¶åˆ°äº†ç¡®è®¤è¿æ¥çš„æ¶ˆæ¯ã€‚æ­¥éª¤1ã€2å»ºç«‹ä¸€ä¸ªæ–¹å‘çš„è¿æ¥å‚æ•°(åºåˆ—å·)å¹¶ç¡®è®¤ã€‚æ­¥éª¤2ã€3å»ºç«‹å¦ä¸€ä¸ªæ–¹å‘çš„è¿æ¥å‚æ•°(åºåˆ—å·)å¹¶ç¡®è®¤ã€‚æœ‰äº†è¿™äº›ï¼Œå°±å¯ä»¥å»ºç«‹å…¨åŒå·¥é€šä¿¡ã€‚\n\nTCP è¿æ¥ä½¿ç”¨ä¸‰æ¬¡æ¡æ‰‹çš„é¦–è¦åŸå› ï¼šä¸ºäº† é˜»æ­¢å†å²çš„é‡å¤è¿æ¥åˆå§‹åŒ–é€ æˆçš„æ··ä¹±é—®é¢˜ã€‚å¦‚æœé€šä¿¡åŒæ–¹çš„é€šä¿¡æ¬¡æ•°åªæœ‰ä¸¤æ¬¡ï¼Œé‚£ä¹ˆå‘é€æ–¹ä¸€æ—¦å‘å‡ºå»ºç«‹è¿æ¥çš„è¯·æ±‚ä¹‹åå®ƒå°±æ²¡æœ‰åŠæ³•æ’¤å›è¿™ä¸€æ¬¡è¯·æ±‚ï¼Œå¦‚æœåœ¨ç½‘ç»œçŠ¶å†µå¤æ‚æˆ–è€…è¾ƒå·®çš„ç½‘ç»œä¸­ï¼Œå‘é€æ–¹è¿ç»­å‘é€å¤šæ¬¡å»ºç«‹è¿æ¥çš„è¯·æ±‚ï¼Œå¦‚æœ TCP å»ºç«‹è¿æ¥åªèƒ½é€šä¿¡ä¸¤æ¬¡ï¼Œé‚£ä¹ˆæ¥æ”¶æ–¹åªèƒ½é€‰æ‹©æ¥å—æˆ–è€…æ‹’ç»å‘é€æ–¹å‘èµ·çš„è¯·æ±‚ï¼Œå®ƒå¹¶ä¸æ¸…æ¥šè¿™ä¸€æ¬¡è¯·æ±‚æ˜¯ä¸æ˜¯ç”±äºç½‘ç»œæ‹¥å µè€Œæ—©æ—©è¿‡æœŸçš„è¿æ¥ã€‚\næ‰€ä»¥ï¼ŒTCP é€‰æ‹©ä½¿ç”¨ä¸‰æ¬¡æ¡æ‰‹æ¥å»ºç«‹è¿æ¥å¹¶åœ¨è¿æ¥å¼•å…¥äº† RST è¿™ä¸€æ§åˆ¶æ¶ˆæ¯ï¼Œæ¥æ”¶æ–¹å½“æ”¶åˆ°è¯·æ±‚æ—¶ä¼šå°†å‘é€æ–¹å‘æ¥çš„ SEQ+1 å‘é€ç»™å¯¹æ–¹ï¼Œè¿™æ—¶ç”±å‘é€æ–¹æ¥åˆ¤æ–­å½“å‰è¿æ¥æ˜¯å¦æ˜¯å†å²è¿æ¥ï¼š\nå¦‚æœå½“å‰è¿æ¥æ˜¯å†å²è¿æ¥ï¼Œå³ SEQ è¿‡æœŸæˆ–è€…è¶…æ—¶ï¼Œé‚£ä¹ˆå‘é€æ–¹å°±ä¼šç›´æ¥å‘é€ RST æ§åˆ¶æ¶ˆæ¯ä¸­æ­¢è¿™ä¸€æ¬¡è¿æ¥ï¼› å¦‚æœå½“å‰è¿æ¥ä¸æ˜¯å†å²è¿æ¥ï¼Œé‚£ä¹ˆå‘é€æ–¹å°±ä¼šå‘é€ ACK æ§åˆ¶æ¶ˆæ¯ï¼Œé€šä¿¡åŒæ–¹å°±ä¼šæˆåŠŸå»ºç«‹è¿æ¥ï¼› ä½¿ç”¨ä¸‰æ¬¡æ¡æ‰‹å’Œ RST æ§åˆ¶æ¶ˆæ¯å°†æ˜¯å¦å»ºç«‹è¿æ¥çš„æœ€ç»ˆæ§åˆ¶æƒäº¤ç»™äº†å‘é€æ–¹ï¼Œå› ä¸ºåªæœ‰å‘é€æ–¹æœ‰è¶³å¤Ÿçš„ä¸Šä¸‹æ–‡æ¥åˆ¤æ–­å½“å‰è¿æ¥æ˜¯å¦æ˜¯é”™è¯¯çš„æˆ–è€…è¿‡æœŸçš„ï¼Œè¿™ä¹Ÿæ˜¯ TCP ä½¿ç”¨ä¸‰æ¬¡æ¡æ‰‹å»ºç«‹è¿æ¥çš„æœ€ä¸»è¦åŸå› ã€‚\nè¿æ¥ç»ˆæ­¢ TCPè¿æ¥çš„å…³é—­éœ€è¦è¿›è¡Œ å››æ¬¡æŒ¥æ‰‹ï¼Œä¸¤è¾¹éƒ½éœ€è¦å…³é—­è¿æ¥ï¼Œæ•´ä¸ªTCPè¿æ¥æ‰ç®—å®Œæ•´çš„å…³é—­ã€‚å¸Œæœ›å…³é—­è¿æ¥ï¼Œå°±ä¼šä¼ é€ FIN åŒ…å¹¶åŒ…å«ä¹‹å‰çš„ACKåŒ…ã€‚æ‰€ä»¥å…³é—­è¿æ¥éœ€è¦ ä¸€ç»„ FIN å’Œ ACKã€‚å½“ä¸€è¾¹çš„å‘é€äº†ç¬¬ä¸€ä¸ª FINå’Œæœ€åçš„ ACKï¼Œä¼šè¿›å…¥ä¸€ä¸ªç­‰å¾…è¶…æ—¶çŠ¶æ€ TIME_WATI ä¹‹é“æ•´ä¸ªè¿æ¥å…³é—­ï¼Œåœ¨æ•´ä¸ªè¿æ¥å…³é—­ä¹‹å‰TCPå ç”¨çš„ç«¯å£ä¸èƒ½è¢«å…¶ä»–æ–°è¿æ¥æ‰€ä½¿ç”¨ï¼›è¿™é˜²æ­¢äº†ç”±äºå»¶è¿Ÿå‘åŒ…å¸¦æ¥çš„æ··ä¹±é—®é¢˜ã€‚\n\nå¯¹äºå¤æ‚çš„ç½‘ç»œçŠ¶æ€ï¼ŒTCP çš„å®ç°æå‡ºäº†å¤šç§åº”å¯¹æªæ–½ï¼Œ TIME_WAIT çŠ¶æ€çš„æå‡ºå°±æ˜¯ä¸ºäº†åº”å¯¹å…¶ä¸­ä¸€ç§å¼‚å¸¸çŠ¶å†µã€‚åœ¨ TIME_WAIT é˜¶æ®µï¼Œä¸»åŠ¨ç«¯ç­‰å¾… 2*MSLï¼ˆæœ€å¤§åˆ†æ®µå¯¿å‘½ï¼šè¡¨ç¤ºä¸€ä¸ª TCP åˆ†æ®µå¯ä»¥å­˜åœ¨äºäº’è”ç½‘ç³»ç»Ÿä¸­çš„æœ€å¤§æ—¶é—´ï¼Œç”± TCP çš„å®ç°ï¼Œè¶…å‡ºè¿™ä¸ªå¯¿å‘½çš„åˆ†ç‰‡éƒ½ä¼šè¢«ä¸¢å¼ƒï¼‰ æ—¶é—´ï¼Œ MSL å»ºè®®ä¸º 2 åˆ†é’Ÿã€‚\nå¦‚æœæ²¡æœ‰ TIME_WAIT çŠ¶æ€ï¼ŒClient ä¸å†ä¿å­˜è¿™ä¸ªè¿æ¥çš„ä¿¡æ¯ï¼Œæ”¶åˆ°ä¸€ä¸ªä¸å­˜åœ¨çš„è¿æ¥çš„åŒ…ï¼ŒClient ä¼šå“åº” RST åŒ…ï¼Œå¯¼è‡´ Server ç«¯å¼‚å¸¸å“åº”ã€‚æ­¤æ—¶ï¼Œ TIME_WAIT æ˜¯ä¸ºäº† ä¿è¯å…¨åŒå·¥çš„ TCP è¿æ¥æ­£å¸¸ç»ˆæ­¢ã€‚\nå¦‚æœåŒæ–¹æŒ¥æ‰‹ä¹‹åï¼Œä¸€ä¸ª ç½‘ç»œå››å…ƒç»„ï¼ˆsrc/dst ip/portï¼‰è¢«å›æ”¶ï¼Œè€Œæ­¤æ—¶ç½‘ç»œä¸­è¿˜æœ‰ä¸€ä¸ªè¿Ÿåˆ°çš„æ•°æ®åŒ…æ²¡æœ‰è¢« Server æ¥æ”¶ï¼ŒClient åº”ç”¨ç¨‹åºåˆç«‹åˆ»ä½¿ç”¨äº†åŒæ ·çš„å››å…ƒç»„å†åˆ›å»ºäº†ä¸€ä¸ªæ–°çš„è¿æ¥åï¼Œè¿™ä¸ªè¿Ÿåˆ°çš„æ•°æ®åŒ…æ‰åˆ°è¾¾ Serverï¼Œé‚£ä¹ˆè¿™ä¸ªæ•°æ®åŒ…å°±ä¼šè®© Server ä»¥ä¸ºæ˜¯ Client åˆšå‘è¿‡æ¥çš„ã€‚æ­¤æ—¶ï¼Œ TIME_WAIT çš„å­˜åœ¨æ˜¯ä¸ºäº† ä¿è¯ç½‘ç»œä¸­è¿·å¤±çš„æ•°æ®åŒ…æ­£å¸¸è¿‡æœŸã€‚\nè¿æ¥å¯ä»¥å¤„äºåŠå¼€çŠ¶æ€ï¼Œæ„æ€å°±æ˜¯TCPçš„æœ‰ä¸€æ–¹è¿æ¥å·²ç»å…³é—­äº†ï¼Œå¦ä¸€æ–¹è¿˜æ²¡æœ‰å…³é—­ã€‚\n\næ•°æ®ä¼ è¾“ å¯é æ€§ä¼ è¾“ TCPä½¿ç”¨ åºåˆ—å·æ ‡è®°æ¯ä¸€ä»½æ•°æ®ï¼Œé€šè¿‡ä½¿ç”¨åºå·å’Œç¡®è®¤å·ï¼ŒTCP å±‚å¯ä»¥æŠŠæ”¶åˆ°çš„æŠ¥æ–‡æ®µä¸­çš„å­—èŠ‚æŒ‰æ­£ç¡®çš„é¡ºåºäº¤ä»˜ç»™åº”ç”¨å±‚ï¼ŒTCP åè®®ä½¿ç”¨åºå·æ ‡è¯†æ¯ç«¯å‘å‡ºçš„å­—èŠ‚çš„é¡ºåºï¼Œä»è€Œå¦ä¸€ç«¯æ¥æ”¶æ•°æ®æ—¶å¯ä»¥é‡å»ºé¡ºåºï¼Œæ— æƒ§ä¼ è¾“æ—¶çš„åŒ…çš„ä¹±åºäº¤ä»˜æˆ–ä¸¢åŒ…ã€‚åœ¨å‘é€ç¬¬ä¸€ä¸ªåŒ…æ—¶ï¼ˆSYNåŒ…ï¼‰ï¼Œé€‰æ‹©ä¸€ä¸ª éšæœºæ•° ä½œä¸ºåºå·çš„åˆå€¼ï¼Œä»¥å…‹åˆ¶ TCP åºå·é¢„æµ‹æ”»å‡»ã€‚\nå‘é€ç¡®è®¤åŒ…ï¼ˆAcksï¼‰ï¼Œæºå¸¦äº†æ¥æ”¶åˆ°çš„å¯¹æ–¹å‘æ¥çš„å­—èŠ‚æµçš„ç¼–å·ï¼Œç§°ä¸ºç¡®è®¤å·ï¼Œä»¥å‘Šè¯‰å¯¹æ–¹ å·²ç»æˆåŠŸæ¥æ”¶çš„æ•°æ®æµçš„å­—èŠ‚ä½ç½®ã€‚Ackå¹¶ä¸æ„å‘³ç€æ•°æ®å·²ç»äº¤ä»˜äº†ä¸Šå±‚åº”ç”¨ç¨‹åºã€‚å¯\né æ€§é€šè¿‡å‘é€æ–¹æ£€æµ‹åˆ°ä¸¢å¤±çš„ä¼ è¾“æ•°æ®å¹¶é‡ä¼ è¿™äº›æ•°æ®ã€‚åŒ…æ‹¬ è¶…æ—¶é‡ä¼ ï¼ˆRetransmission timeoutï¼ŒRTOï¼‰ä¸ é‡å¤ç´¯è®¡ç¡®è®¤ ï¼ˆduplicate cumulative acknowledgementsï¼ŒDupAcksï¼‰ã€‚\né‡å¤ç´¯è®¡ç¡®è®¤é‡ä¼  å¦‚æœä¸€ä¸ªåŒ…ï¼ˆä¸å¦¨è®¾å®ƒçš„åºå·æ˜¯ 100 ï¼Œå³è¯¥åŒ…å§‹äºç¬¬ 100 å­—èŠ‚ï¼‰ä¸¢å¤±ï¼Œæ¥æ”¶æ–¹å°±ä¸èƒ½ç¡®è®¤è¿™ä¸ªåŒ…åŠå…¶ä»¥åçš„åŒ…ï¼Œå› ä¸ºé‡‡ç”¨äº† ç´¯è®¡ACK ã€‚æ¥æ”¶æ–¹åœ¨æ”¶åˆ° 100 ä»¥åçš„åŒ…æ—¶ï¼Œå‘å‡ºå¯¹åŒ…å«ç¬¬ 99 å­—èŠ‚çš„åŒ…çš„ç¡®è®¤ã€‚è¿™ç§é‡å¤ç¡®è®¤æ˜¯åŒ…ä¸¢å¤±çš„ä¿¡å·ã€‚å‘é€æ–¹å¦‚æœæ”¶åˆ° 3 æ¬¡å¯¹åŒä¸€ä¸ªåŒ…çš„ç¡®è®¤ï¼Œå°±é‡ä¼ æœ€åä¸€ä¸ªæœªè¢«ç¡®è®¤çš„åŒ…ã€‚é˜ˆå€¼è®¾ä¸º 3 è¢«è¯å®å¯ä»¥å‡å°‘ä¹±åºåŒ…å¯¼è‡´çš„æ— ä½œç”¨çš„é‡ä¼ ï¼ˆspurious retransmissionï¼‰ç°è±¡ã€‚é€‰æ‹©æ€§ç¡®è®¤ï¼ˆSACKï¼‰çš„ä½¿ç”¨èƒ½æ˜ç¡®åé¦ˆå“ªä¸ªåŒ…æ”¶åˆ°äº†ï¼Œæå¤§æ”¹å–„äº†TCPé‡ä¼ å¿…è¦çš„åŒ…çš„èƒ½åŠ›ã€‚\nè¶…æ—¶é‡ä¼  å‘é€æ–¹ä½¿ç”¨ä¸€ä¸ªä¿å®ˆä¼°è®¡çš„æ—¶é—´ä½œä¸ºæ”¶åˆ°æ•°æ®åŒ…çš„ç¡®è®¤çš„è¶…æ—¶ä¸Šé™ã€‚å¦‚æœè¶…è¿‡è¿™ä¸ªä¸Šé™ä»æœªæ”¶åˆ°ç¡®è®¤åŒ…ï¼Œå‘é€æ–¹å°†é‡ä¼ è¿™ä¸ªæ•°æ®åŒ…ã€‚æ¯å½“å‘é€æ–¹æ”¶åˆ°ç¡®è®¤åŒ…åï¼Œä¼šé‡ç½®è¿™ä¸ªé‡ä¼ å®šæ—¶å™¨ã€‚å…¸å‹åœ°ï¼Œå®šæ—¶å™¨çš„å€¼è®¾å®šä¸º \\({\\displaystyle {\\text{smoothed RTT}}+\\max(G,4\\times {\\text{RTT variation}})}\\) æ˜¯æ—¶é’Ÿç²’åº¦ã€‚è¿›ä¸€æ­¥ï¼Œå¦‚æœé‡ä¼ å®šæ—¶å™¨è¢«è§¦å‘ï¼Œä»ç„¶æ²¡æœ‰æ”¶åˆ°ç¡®è®¤åŒ…ï¼Œå®šæ—¶å™¨çš„å€¼å°†è¢«è®¾ä¸ºå‰æ¬¡å€¼çš„äºŒå€ï¼ˆç›´åˆ°ç‰¹å®šé˜ˆå€¼ï¼‰ã€‚è¿™å¯å¯¹æŠ— ä¸­é—´äººæ”»å‡»æ–¹å¼çš„æ‹’ç»æœåŠ¡æ”»å‡»ï¼Œè¿™ç§æ”»å‡»æ„šå¼„å‘é€è€…é‡ä¼ å¾ˆå¤šæ¬¡å¯¼è‡´æ¥å—è€…è¢«å‹å®ã€‚\næµé‡æ§åˆ¶ æµé‡æ§åˆ¶ç”¨æ¥é¿å…ä¸»æœºåˆ†ç»„å‘é€å¾—è¿‡å¿«è€Œä½¿æ¥æ”¶æ–¹æ¥ä¸åŠå®Œå…¨æ”¶ä¸‹ï¼Œä¸€èˆ¬ç”±æ¥æ”¶æ–¹é€šå‘Šç»™å‘é€æ–¹è¿›è¡Œè°ƒæ§ï¼Œè¿™é‡Œçš„çª—å£è¢«ç§°ä¸º æ¥æ”¶é€šçŸ¥çª—å£ï¼ˆReceiver's Advertised Windowï¼‰ã€‚\næµé‡æ§åˆ¶é€šè¿‡ æ»‘åŠ¨çª—å£æœºåˆ¶ æ¥å®ç°ï¼š æŠ¥æ–‡å‘é€æ–¹ åœ¨ WIN åŸŸæŒ‡å‡ºè¿˜å¯æ¥æ”¶çš„å­—èŠ‚æ•°é‡ï¼ˆrwndï¼‰ã€‚æŠ¥æ–‡æ¥æ”¶æ–¹åœ¨æ²¡æœ‰æ–°çš„ç¡®è®¤åŒ…çš„æƒ…å†µä¸‹è‡³å¤šå‘é€ WIN å…è®¸çš„å­—èŠ‚æ•°é‡ã€‚åœ¨æ•°æ®ä¼ è¾“è¿‡ç¨‹ä¸­ï¼ŒæŠ¥æ–‡å‘é€æ–¹å¯ä¿®æ”¹ WIN çš„å€¼ã€‚\næ‹¥å¡æ§åˆ¶ TCP æ‹¥å¡æ§åˆ¶ç®—æ³•æ˜¯äº’è”ç½‘ä¸Šä¸»è¦çš„æ‹¥å¡æ§åˆ¶æªæ–½ï¼Œå®ƒä½¿ç”¨ä¸€å¥—åŸºäº çº¿å¢—ç§¯å‡ï¼ˆAdditive increase/multiplicative decreaseï¼ŒAIMDï¼‰çš„ç½‘ç»œæ‹¥å¡æ§åˆ¶æ–¹æ³•æ¥æ§åˆ¶æ‹¥å¡ï¼Œé˜²æ­¢è¿‡å¤šçš„æ•°æ®æ³¨å…¥åˆ°ç½‘ç»œä¸­ï¼Œè¿™æ ·å¯ä»¥ä½¿ç½‘ç»œä¸­çš„è·¯ç”±å™¨æˆ–é“¾è·¯ä¸è‡´è¿‡è½½ã€‚\né™¤äº† æ‹¥å¡çª—å£å¤§å°ï¼ˆcwndï¼‰ ä¹‹å¤–ï¼ŒTCP è¿æ¥çš„åŒæ–¹éƒ½æœ‰ æ¥æ”¶çª—å£å¤§å°ï¼ˆrwndï¼‰ã€‚å®¢æˆ·ç«¯èƒ½å¤ŸåŒæ—¶ä¼ è¾“çš„æœ€å¤§æ•°æ®æ®µçš„æ•°é‡æ˜¯æ¥æ”¶çª—å£å¤§å°å’Œæ‹¥å¡çª—å£å¤§å°çš„æœ€å°å€¼ï¼Œå³ min(rwnd, cwnd)min(rwnd,cwnd) ã€‚\nTCP åè®®ä½¿ç”¨æ…¢å¯åŠ¨é˜ˆå€¼ï¼ˆSlow start threshold, ssthreshï¼‰æ¥å†³å®šä½¿ç”¨æ…¢å¯åŠ¨æˆ–è€…æ‹¥å¡é¿å…ç®—æ³•ï¼š\nå½“æ‹¥å¡çª—å£å¤§å°å°äºæ…¢å¯åŠ¨é˜ˆå€¼æ—¶ï¼Œä½¿ç”¨æ…¢å¯åŠ¨ï¼› å½“æ‹¥å¡çª—å£å¤§å°å¤§äºæ…¢å¯åŠ¨é˜ˆå€¼æ—¶ï¼Œä½¿ç”¨æ‹¥å¡é¿å…ç®—æ³•ï¼› å½“æ‹¥å¡çª—å£å¤§å°ç­‰äºæ…¢å¯åŠ¨é˜ˆå€¼æ—¶ï¼Œä½¿ç”¨æ…¢å¯åŠ¨æˆ–è€…æ‹¥å¡é¿å…ç®—æ³•ï¼›\næ…¢å¼€å§‹å’Œæ‹¥å¡é¿å… å®¢æˆ·ç«¯ç»´æŒä¸€ä¸ª æ‹¥å¡çª—å£ cwnd çš„çŠ¶æ€å˜é‡ï¼Œåˆå§‹å€¼ä¸€èˆ¬ä¸º 2\\times MSS2Ã—MSS ã€‚\n æ…¢å¼€å§‹ï¼šç”±å°åˆ°å¤§çš„æŒ‡æ•°å¢å¤§æ‹¥å¡çª—å£ã€‚é¦–å…ˆå°† cwnd è®¾ç½®ä¸ºä¸€ä¸ªæœ€å¤§æŠ¥æ–‡æ®µ MMS ï¼Œåœ¨æ”¶åˆ°ä¸€ä¸ªå¯¹æ–°çš„æŠ¥æ–‡æ®µçš„ç¡®è®¤åï¼ŒæŠŠæ‹¥å¡çª—å£å¢åŠ ä¸€ä¸ª MMS ã€‚\n æ‹¥å¡é¿å…ï¼šå½“æ…¢å¼€å§‹åˆ°é˜ˆå€¼ï¼ˆssthreshï¼‰åï¼Œä½¿ç”¨æ‹¥å¡é¿å…ç®—æ³•ï¼ˆ cwnd æ¯æ¬¡åŠ 1 ï¼‰ã€‚å½“å‘é€æ–¹å‘é€çš„æ•°æ®åŒ…ä¸¢åŒ…æ—¶ï¼Œå°† ssthresh ç½®ä¸º cwnd çš„ä¸€åŠï¼Œå°† cwnd ç½®ä¸º1ï¼Œå†æ¬¡æ‰§è¡Œæ…¢å¼€å§‹ã€‚\n  å¿«é‡ä¼ å’Œå¿«æ¢å¤ å¿«é€Ÿé‡ä¼ å’Œæ¢å¤ï¼ˆfast retransmit and recoveryï¼ŒFRRï¼‰ æ˜¯ä¸€ç§æ‹¥å¡æ§åˆ¶ç®—æ³•ï¼Œå®ƒèƒ½å¿«é€Ÿæ¢å¤ä¸¢å¤±çš„æ•°æ®åŒ…ã€‚æ²¡æœ‰ FRRï¼Œå¦‚æœæ•°æ®åŒ…ä¸¢å¤±äº†ï¼ŒTCP å°†ä¼šä½¿ç”¨å®šæ—¶å™¨æ¥è¦æ±‚ä¼ è¾“æš‚åœã€‚åœ¨æš‚åœçš„è¿™æ®µæ—¶é—´å†…ï¼Œæ²¡æœ‰æ–°çš„æˆ–å¤åˆ¶çš„æ•°æ®åŒ…è¢«å‘é€ã€‚æœ‰äº†FRRï¼Œå¦‚æœæ¥æ”¶æœºæ¥æ”¶åˆ°ä¸€ä¸ªä¸æŒ‰é¡ºåºçš„æ•°æ®æ®µï¼Œå®ƒä¼šç«‹å³ç»™å®¢æˆ·ç«¯å‘é€ä¸€ä¸ªé‡å¤ç¡®è®¤ã€‚å¦‚æœå®¢æˆ·ç«¯æ¥æ”¶åˆ°ä¸‰ä¸ªé‡å¤ç¡®è®¤ï¼Œå®ƒä¼šè®¤å®šæ•°æ®æ®µä¸¢å¤±ï¼Œå¹¶ç«‹å³é‡ä¼ è¿™äº›ä¸¢å¤±çš„æ•°æ®æ®µã€‚\næœ‰äº† FRRï¼Œå°±ä¸ä¼šå› ä¸ºé‡ä¼ æ—¶è¦æ±‚çš„æš‚åœè¢«è€½è¯¯ã€‚å½“æœ‰å•ç‹¬çš„æ•°æ®åŒ…ä¸¢å¤±æ—¶ï¼Œå¿«é€Ÿé‡ä¼ å’Œæ¢å¤ï¼ˆFRRï¼‰èƒ½æœ€æœ‰æ•ˆåœ°å·¥ä½œã€‚å½“æœ‰å¤šä¸ªæ•°æ®ä¿¡æ¯åŒ…åœ¨æŸä¸€æ®µå¾ˆçŸ­çš„æ—¶é—´å†…ä¸¢å¤±æ—¶ï¼Œå®ƒåˆ™ä¸èƒ½å¾ˆæœ‰æ•ˆåœ°å·¥ä½œã€‚\nBBR BBRï¼ˆBottleneck Bandwidth and Round-trip propagation timeï¼‰æ˜¯ Google ç ”å‘çš„æ–°çš„æ‹¥å¡æ§åˆ¶ç®—æ³•ã€‚è‡ªä» 20 ä¸–çºª 80å¹´ä»£åï¼Œ TCP ä¸­çš„æ‹¥å¡æ§åˆ¶ç®—æ³•éƒ½ä½¿ç”¨çš„æ˜¯ åŸºäºä¸¢åŒ…çš„æ‹¥å¡æ§åˆ¶ï¼ˆæ‹¥å¡é¿å…ï¼‰ï¼Œåœ¨ä¹‹å‰çš„ç½‘ç»œå¸¦å®½ã€è·¯ç”±å™¨ Buffer çš„æƒ…å†µä¸‹ï¼Œè¯¥ç®—æ³•æ•ˆæœè‰¯å¥½ã€‚\nä½†æ˜¯åœ¨å½“å‰çš„ç½‘ç»œæ¡ä»¶ä¸‹ï¼ŒåŸºäºä¸¢åŒ…çš„æ‹¥å¡æ§åˆ¶ç®—æ³•åˆ™ä¼šå¯¼è‡´ TCP æ€§èƒ½é—®é¢˜ï¼š\nåœ¨å° Buffer è·¯ç”±å™¨ç¯å¢ƒä¸‹ï¼Œä¸¢åŒ…å‘ç”Ÿåœ¨æ‹¥å¡ä¹‹å‰ã€‚åœ¨é«˜é€Ÿï¼Œé•¿é€”é“¾è·¯ä¸­ï¼ŒåŸºäºä¸¢åŒ…çš„æ‹¥å¡æ§åˆ¶ä¼šå¯¼è‡´ååé‡è¿‡ä½ï¼Œå› ä¸ºå®ƒååº”è¿‡åº¦ï¼Œå³ä½¿ä¸¢åŒ…æ˜¯ç”±ç¬æ—¶æµé‡çªå‘å¼•èµ·çš„ï¼Œä¹Ÿä¼šå› ä¸¢åŒ…è€Œå°†å‘é€é€Ÿç‡å‡åŠï¼ˆå³ä½¿é“¾è·¯å¤§éƒ¨åˆ†å¤„äºç©ºé—²çŠ¶æ€ï¼Œè¿™ç§ä¸¢åŒ…ä¹Ÿå¯èƒ½éå¸¸é¢‘ç¹ï¼‰ åœ¨å¤§ Buffer è·¯ç”±å™¨ç¯å¢ƒä¸‹ï¼Œæ‹¥å¡å‘ç”Ÿåœ¨ä¸¢åŒ…ä¹‹å‰ã€‚åœ¨äº’è”ç½‘çš„è¾¹ç¼˜ï¼ŒåŸºäºä¸¢åŒ…çš„æ‹¥å¡æ§åˆ¶é€šè¿‡åå¤å¡«å……å¤§é‡çš„ç¼“å­˜ï¼Œä»è€Œå¯¼è‡´äº†è‡­åæ˜­è‘—çš„ bufferbloat é—®é¢˜ã€‚ bufferbloat é—®é¢˜ï¼šç”±äºè·¯ç”±å™¨çš„å¤§ç¼“å­˜ï¼Œå‡å°‘é“¾è·¯ä¸¢åŒ…ã€‚å†åŠ ä¸Šç½‘ç»œä¸­ TCP å¤§é‡ä½¿ç”¨åŸºäºä¸¢åŒ…çš„æ‹¥å¡æ§åˆ¶ç®—æ³•ï¼ˆä¸¢åŒ…æ‰è§¦å‘é€Ÿåº¦ä¸‹è°ƒï¼Œä½†æ˜¯è¦ä¸¢åŒ…ï¼Œç¼“å­˜å°±å¾—å…ˆè¢«å¡«æ»¡ï¼Œç¼“å­˜éƒ½å¡«æ»¡ï¼Œå»¶è¿Ÿæ›´é«˜ï¼‰\nBBR ç®—æ³•ä½¿ç”¨æœ€å¤§å¸¦å®½å’Œå¾€è¿”æ—¶é—´æ¥å»ºç«‹ç½‘ç»œçš„æ˜¾å¼æ¨¡å‹ã€‚æ¯æ¬¡å¯¹åŒ…ä¼ é€’è¿›è¡Œç´¯ç§¯æˆ–é€‰æ‹©æ€§ç¡®è®¤ï¼Œéƒ½ä¼šç”Ÿæˆä¸€ä¸ªé€Ÿç‡æ ·æœ¬ï¼Œè¯¥é€Ÿç‡é‡‡æ ·è®°å½•åœ¨æ•°æ®åŒ…ä¼ è¾“ä¸è¯¥åŒ…ç¡®è®¤ä¹‹é—´çš„æ—¶é—´é—´éš”å†…ä¼ é€’çš„æ•°æ®é‡ï¼Œä»è€Œä½¿æ‹¥å¡æ§åˆ¶ç®—æ³•èƒ½å¤Ÿæä¾›æ›´é«˜çš„ååé‡å’Œæ›´ä½çš„å»¶è¿Ÿã€‚\næœ€å¤§åˆ†æ®µå¤§å° æœ€å¤§åˆ†æ®µå¤§å° (MSS) æ˜¯åœ¨å•ä¸ªåˆ†æ®µä¸­ TCP æ„¿æ„æ¥å—çš„æ•°æ®çš„å­—èŠ‚æ•°æœ€å¤§å€¼ã€‚MSSåº”å½“è¶³å¤Ÿå°ä»¥é¿å…IPåˆ†ç‰‡ï¼Œå®ƒä¼šå¯¼è‡´ä¸¢åŒ…æˆ–è¿‡å¤šçš„é‡ä¼ ã€‚\nåœ¨ TCP è¿æ¥åˆ›å»ºæ—¶ï¼ŒåŒç«¯åœ¨ SYN æŠ¥æ–‡ä¸­ç”¨ MSS é€‰é¡¹å®£å¸ƒå„è‡ªçš„ MSS ï¼Œè¿™æ˜¯ä»åŒç«¯å„è‡ªç›´æ¥ç›¸è¿çš„æ•°æ®é“¾è·¯å±‚çš„æœ€å¤§ä¼ è¾“å•å…ƒ(MTU)çš„å°ºå¯¸å‡å»å›ºå®šçš„ IP é¦–éƒ¨å’Œ TCP é¦–éƒ¨é•¿åº¦ã€‚ä»¥å¤ªç½‘MTUä¸º 1500 å­—èŠ‚ï¼Œ MSSå€¼å¯è¾¾ 1460 å­—èŠ‚ã€‚ä½¿ç”¨ IEEE 802.3 çš„ MTU ä¸º 1492 å­—èŠ‚ï¼ŒMSS å¯è¾¾ 1452 å­—èŠ‚ã€‚\nå¦‚æœç›®çš„IPåœ°å€ä¸ºâ€œéæœ¬åœ°çš„â€ï¼ŒMSSé€šå¸¸çš„é»˜è®¤å€¼ä¸º 536ï¼ˆè¿™ä¸ªé»˜è®¤å€¼å…è®¸ 20 å­—èŠ‚çš„ IP é¦–éƒ¨å’Œ 20 å­—èŠ‚çš„ TCP é¦–éƒ¨ä»¥é€‚åˆ 576å­—èŠ‚ IP æ•°æ®æŠ¥ï¼‰ã€‚æ­¤å¤–ï¼Œå‘é€æ–¹å¯ç”¨ä¼ è¾“è·¯å¾„ MTU å‘ç°ï¼ˆRFC 1191ï¼‰æ¨å¯¼å‡ºä»å‘é€æ–¹åˆ°æ¥æ”¶æ–¹çš„ç½‘ç»œè·¯å¾„ä¸Šçš„æœ€å° MTUï¼Œä»¥æ­¤åŠ¨æ€è°ƒæ•´ MSS ä»¥é¿å…ç½‘ç»œ IP åˆ†ç‰‡ã€‚\nMSS å‘å¸ƒä¹Ÿè¢«ç§°ä½œâ€œMSSåå•†â€ï¼ˆMSS negotiationï¼‰ã€‚ä¸¥æ ¼è®²ï¼Œè¿™å¹¶éæ˜¯åå•†å‡ºæ¥ä¸€ä¸ªç»Ÿä¸€çš„MSSå€¼ï¼ŒTCP å…è®¸è¿æ¥ä¸¤ç«¯ä½¿ç”¨å„è‡ªä¸åŒçš„MSSå€¼ã€‚ä¾‹å¦‚ï¼Œè¿™ä¼šå‘ç”Ÿåœ¨å‚ä¸ TCP è¿æ¥çš„ä¸€å°è®¾å¤‡ä½¿ç”¨éå¸¸å°‘çš„å†…å­˜å¤„ç†åˆ°æ¥çš„ TCP åˆ†ç»„ã€‚\né€‰æ‹©ç¡®è®¤ æœ€åˆé‡‡å–ç´¯è®¡ç¡®è®¤çš„ TCP åè®®åœ¨ä¸¢åŒ…æ—¶æ•ˆç‡å¾ˆä½ã€‚ä¾‹å¦‚ï¼Œå‡è®¾é€šè¿‡10ä¸ªåˆ†ç»„å‘å‡ºäº†1ä¸‡ä¸ªå­—èŠ‚çš„æ•°æ®ã€‚å¦‚æœç¬¬ä¸€ä¸ªåˆ†ç»„ä¸¢å¤±ï¼Œåœ¨çº¯ç²¹çš„ç´¯è®¡ç¡®è®¤åè®®ä¸‹ï¼Œæ¥æ”¶æ–¹ä¸èƒ½è¯´å®ƒæˆåŠŸæ”¶åˆ°äº† 1,000 åˆ° 9,999 å­—èŠ‚ï¼Œä½†æœªæ”¶åˆ°åŒ…å« 0 åˆ° 999 å­—èŠ‚çš„ç¬¬ä¸€ä¸ªåˆ†ç»„ã€‚å› è€Œï¼Œå‘é€æ–¹å¯èƒ½å¿…é¡»é‡ä¼ æ‰€æœ‰1ä¸‡ä¸ªå­—èŠ‚ã€‚\nä¸ºæ­¤ï¼ŒTCPé‡‡å–äº† é€‰æ‹©ç¡®è®¤ï¼ˆselective acknowledgmentï¼ŒSACKï¼‰ é€‰é¡¹ã€‚RFC 2018 å¯¹æ­¤å®šä¹‰ä¸º å…è®¸æ¥æ”¶æ–¹ç¡®è®¤å®ƒæˆåŠŸæ”¶åˆ°çš„åˆ†ç»„çš„ä¸è¿ç»­çš„å—ï¼Œä»¥åŠåŸºç¡€ TCP ç¡®è®¤çš„æˆåŠŸæ”¶åˆ°æœ€åè¿ç»­å­—èŠ‚åºå·ã€‚è¿™ç§ç¡®è®¤å¯ä»¥æŒ‡å‡º SACK blockï¼ŒåŒ…å«äº†å·²ç»æˆåŠŸæ”¶åˆ°çš„è¿ç»­èŒƒå›´çš„å¼€å§‹ä¸ç»“æŸå­—èŠ‚åºå·ã€‚åœ¨ä¸Šè¿°ä¾‹å­ä¸­ï¼Œæ¥æ”¶æ–¹å¯ä»¥å‘å‡º SACK æŒ‡å‡ºåºå· 1000 åˆ° 9999 ï¼Œå‘é€æ–¹å› æ­¤çŸ¥é“åªéœ€é‡å‘ç¬¬ä¸€ä¸ªåˆ†ç»„(å­—èŠ‚ 0 åˆ° 999)ã€‚\nTCP å‘é€æ–¹ä¼šæŠŠä¹±åºæ”¶åŒ…å½“ä½œä¸¢åŒ…ï¼Œå› æ­¤ä¼šé‡ä¼ ä¹±åºæ”¶åˆ°çš„åŒ…ï¼Œå¯¼è‡´è¿æ¥çš„æ€§èƒ½ä¸‹é™ã€‚é‡å¤SACKé€‰é¡¹ï¼ˆduplicate-SACK optionï¼‰æ˜¯å®šä¹‰åœ¨RFC 2883ä¸­çš„SACKçš„ä¸€é¡¹æ‰©å±•ï¼Œå¯è§£å†³è¿™ä¸€é—®é¢˜ã€‚æ¥æ”¶æ–¹å‘å‡º D-SACK æŒ‡å‡ºæ²¡æœ‰ä¸¢åŒ…ï¼Œæ¥æ”¶æ–¹æ¢å¤åˆ°é«˜ä¼ è¾“ç‡ã€‚ D-SACK ä½¿ç”¨äº† SACK çš„ç¬¬ä¸€ä¸ªæ®µæ¥åšæ ‡å¿—ï¼š\n  å¦‚æœ SACK çš„ç¬¬ä¸€ä¸ªæ®µçš„èŒƒå›´è¢« ACK æ‰€è¦†ç›–ï¼Œé‚£ä¹ˆå°±æ˜¯ D-SACK; å¦‚æœ SACK çš„ç¬¬ä¸€ä¸ªæ®µçš„èŒƒå›´è¢« SACK çš„ç¬¬äºŒä¸ªæ®µè¦†ç›–ï¼Œé‚£ä¹ˆå°±æ˜¯ D-SACK D-SACKæ—¨åœ¨å‘Šè¯‰å‘é€ç«¯ï¼šæ”¶åˆ°äº†é‡å¤çš„æ•°æ®ï¼Œæ•°æ®åŒ…æ²¡æœ‰ä¸¢ï¼Œä¸¢çš„æ˜¯ACKåŒ…ï¼›   SACK é€‰é¡¹å¹¶ä¸æ˜¯å¼ºåˆ¶çš„ã€‚ä»…å½“åŒç«¯éƒ½æ”¯æŒæ—¶æ‰ä¼šè¢«ä½¿ç”¨ã€‚ TCP è¿æ¥åˆ›å»ºæ—¶ä¼šåœ¨ TCP å¤´ä¸­åå•† SACK ç»†èŠ‚ã€‚åœ¨ Linuxä¸‹ï¼Œå¯ä»¥é€šè¿‡ tcp_sack å‚æ•°æ‰“å¼€ SACK åŠŸèƒ½ï¼ˆLinux 2.4åé»˜è®¤æ‰“å¼€ï¼‰ã€‚Linuxä¸‹çš„ tcp_dsack å‚æ•°ç”¨äºå¼€å¯D-SACKåŠŸèƒ½ï¼ˆLinux 2.4åé»˜è®¤æ‰“å¼€ï¼‰ã€‚é€‰æ‹©ç¡®è®¤ä¹Ÿç”¨äºæµæ§åˆ¶ä¼ è¾“åè®® (SCTP)ã€‚\nå‚è€ƒ  TCP TCP Protocol From Wikipedia Why TCP is important ã€ŠTCP IP è¯¦è§£ ç¬¬å››ç‰ˆã€‹  ","id":19,"section":"posts","summary":"TCPæ˜¯ä»€ä¹ˆ ? ä¼ è¾“æ§åˆ¶åè®®ï¼ˆTCPï¼‰æ˜¯äº’è”ç½‘åè®®ç»„ä¸­é‡è¦çš„ç»„æˆéƒ¨åˆ†ä¹‹ä¸€ã€‚TCPçš„å®ç°ä¹‹åˆæ˜¯ä¸ºäº†è¡¥å……äº’è”ç½‘åè®®ï¼ˆIPï¼‰ã€‚å› æ­¤ï¼Œè¿™ä¸€å¯¹ç»„åˆç»å¸¸è¢«","tags":["networking","tcp"],"title":"About TCP Protocol","uri":"https://holicc.github.io/2020/03/about-tcp-protocol/","year":"2020"}],"tags":[{"title":"index","uri":"https://holicc.github.io/tags/index/"},{"title":"mysql","uri":"https://holicc.github.io/tags/mysql/"},{"title":"networking","uri":"https://holicc.github.io/tags/networking/"},{"title":"powershell","uri":"https://holicc.github.io/tags/powershell/"},{"title":"programing","uri":"https://holicc.github.io/tags/programing/"},{"title":"rocketMQ","uri":"https://holicc.github.io/tags/rocketmq/"},{"title":"rust","uri":"https://holicc.github.io/tags/rust/"},{"title":"tcp","uri":"https://holicc.github.io/tags/tcp/"}]}