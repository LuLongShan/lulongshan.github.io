{"categories":[{"title":"mysql","uri":"https://holicc.github.io/categories/mysql/"},{"title":"programing","uri":"https://holicc.github.io/categories/programing/"},{"title":"protocol","uri":"https://holicc.github.io/categories/protocol/"},{"title":"rocketMQ","uri":"https://holicc.github.io/categories/rocketmq/"},{"title":"windows","uri":"https://holicc.github.io/categories/windows/"}],"posts":[{"content":"Receiver Type Choosing whether to use a value or pointer receiver on methods can be difficult, especially to new Go programmers. If in doubt, use a pointer, but there are times when a value receiver makes sense, usually for reasons of efficiency, such as for small unchanging structs or values of basic type. Some useful guidelines:\n If the receiver is a map, func or chan, don't use a pointer to them. If the receiver is a slice and the method doesn't reslice or reallocate the slice, don't use a pointer to it. If the method needs to mutate the receiver, the receiver must be a pointer. If the receiver is a struct that contains a sync.Mutex or similar synchronizing field, the receiver must be a pointer to avoid copying. If the receiver is a large struct or array, a pointer receiver is more efficient. How large is large? Assume it's equivalent to passing all its elements as arguments to the method. If that feels too large, it's also too large for the receiver. Can function or methods, either concurrently or when called from this method, be mutating the receiver? A value type creates a copy of the receiver when the method is invoked, so outside updates will not be applied to this receiver. If changes must be visible in the original receiver, the receiver must be a pointer. If the receiver is a struct, array or slice and any of its elements is a pointer to something that might be mutating, prefer a pointer receiver, as it will make the intention more clear to the reader. If the receiver is a small array or struct that is naturally a value type (for instance, something like the time.Time type), with no mutable fields and no pointers, or is just a simple basic type such as int or string, a value receiver makes sense. A value receiver can reduce the amount of garbage that can be generated; if a value is passed to a value method, an on-stack copy can be used instead of allocating on the heap. (The compiler tries to be smart about avoiding this allocation, but it can't always succeed.) Don't choose a value receiver type for this reason without profiling first. Finally, when in doubt, use a pointer receiver.  type User struct { Name string Age int } func NewUser(name string, age int) *User { return \u0026amp;User{ Name: name, Age: age, } }  Return a pointer rather than a struct to void data copy !\n","id":0,"section":"posts","summary":"Receiver Type Choosing whether to use a value or pointer receiver on methods can be difficult, especially to new Go programmers. If in doubt, use a pointer, but there are times when a value receiver makes sense, usually for reasons of efficiency, such as for small unchanging structs or values of basic type. Some useful guidelines:\n If the receiver is a map, func or chan, don't use a pointer to them.","tags":["programing"],"title":"Go Code Style","uri":"https://holicc.github.io/2020/08/go-code-style/","year":"2020"},{"content":"Rust Concurrency Rust中的线程（Thread）使用的是1:1 model而不是像Golang中的goroutine使用的是M:N model；\n因为Rust是一门更接近底层的编程语言，使用M:N模型需要更大的运行时开销来支持。\n The green-threading M:N model requires a larger language runtime to manage threads. As such, the Rust standard library only provides an implementation of 1:1 threading. Because Rust is such a low-level language, there are crates that implement M:N threading if you would rather trade overhead for aspects such as more control over which threads run when and lower costs of context switching, for example.\n 线程的创建\nuse std::thread; use std::time::Duration; fn main() { thread::spawn(|| { for i in 1..10 { println!(\u0026quot;hi number {} from the spawned thread!\u0026quot;, i); thread::sleep(Duration::from_millis(1)); } }); for i in 1..5 { println!(\u0026quot;hi number {} from the main thread!\u0026quot;, i); thread::sleep(Duration::from_millis(1)); } }  是个线程就有join方法\nuse std::thread; use std::time::Duration; fn main() { let handle = thread::spawn(|| { for i in 1..10 { println!(\u0026quot;hi number {} from the spawned thread!\u0026quot;, i); thread::sleep(Duration::from_millis(1)); } }); handle.join().unwrap(); for i in 1..5 { println!(\u0026quot;hi number {} from the main thread!\u0026quot;, i); thread::sleep(Duration::from_millis(1)); } }  Rust的线程通信借鉴了Go使用了channel.\n One increasingly popular approach to ensuring safe concurrency is message passing, where threads or actors communicate by sending each other messages containing data. Here’s the idea in a slogan from the Go language documentation: “Do not communicate by sharing memory; instead, share memory by communicating.”\n 使用mpsc::channel函数来创建channel,其中mpsc表示多个生产者一个消费者（multiple producer, single consumer），只要消费者接收到了一个生产者的消息就会中断整个channel。\nuse std::sync::mpsc::channel; use std:🧵:spawn; fn main() { let (tx, rx) = channel(); spawn(move || { tx.send(String::from(\u0026quot;hello\u0026quot;)).unwrap(); }); let received = rx.recv().unwrap(); println!(\u0026quot;Got: {}\u0026quot;, received); }  为了能够有多个生产者，需要clone一下tx\nuse std::rc::Rc; use std::sync::mpsc; use std:🧵:{sleep, spawn}; use std::time::Duration; fn main() { let (tx, rx) = mpsc::channel(); let tx1 = tx.clone(); spawn(move || { tx.send(\u0026quot;one\u0026quot;).unwrap(); sleep(Duration::from_millis(1000)); }); spawn(move || { tx1.send(\u0026quot;two\u0026quot;).unwrap(); sleep(Duration::from_millis(1000)); }); for received in rx { println!(\u0026quot;Got: {}\u0026quot;, received); } }  rx中的recv方法会阻塞当前线程直到接收到消息。如果不想阻塞可以使用try_recv方法，该方法会立即返回。\n使用互斥锁解决并发数据访问问题。\nuse std::sync::Mutex; fn main() { let m = Mutex::new(5); { let mut num = m.lock().unwrap(); *num = 6; } println!(\u0026quot;m = {:?}\u0026quot;, m); }  正确使用锁的姿势\nuse std::sync::{Arc, Mutex}; use std::thread; fn main() { let counter = Arc::new(Mutex::new(0)); let mut handles = vec![]; for _ in 0..10 { let counter = Arc::clone(\u0026amp;counter); let handle = thread::spawn(move || { let mut num = counter.lock().unwrap(); *num += 1; }); handles.push(handle); } for handle in handles { handle.join().unwrap(); } println!(\u0026quot;Result: {}\u0026quot;, *counter.lock().unwrap()); }  内容有点少啊.\n完！\n","id":1,"section":"posts","summary":"Rust Concurrency Rust中的线程（Thread）使用的是1:1 model而不是像Golang中的goroutine使用的是M:N model； 因为Rust","tags":["programing","rust"],"title":"Rust Concurrency","uri":"https://holicc.github.io/2020/08/rust-concurrency/","year":"2020"},{"content":"Rust Unsafe 使用unsafe的五种特性：\n Dereference a raw pointer Call an unsafe function or method Access or modify a mutable static variable Implement an unsafe trait Access fields of unions  Dereferencing a Raw Pointer 定义 raw pointer\nfn main() { let mut num = 5; let r1 = \u0026amp;num as *const i32; let r2 = \u0026amp;mut num as *mut i32; }  释放\nfn main() { let mut num = 5; let r1 = \u0026amp;num as *const i32; let r2 = \u0026amp;mut num as *mut i32; unsafe { println!(\u0026quot;r1 is: {}\u0026quot;, *r1); println!(\u0026quot;r2 is: {}\u0026quot;, *r2); } }  Calling an Unsafe Function or Method use std::slice; fn split_at_mut(slice: \u0026amp;mut [i32], mid: usize) -\u0026gt; (\u0026amp;mut [i32], \u0026amp;mut [i32]) { let len = slice.len(); let ptr = slice.as_mut_ptr(); assert!(mid \u0026lt;= len); unsafe { ( slice::from_raw_parts_mut(ptr, mid), slice::from_raw_parts_mut(ptr.add(mid), len - mid), ) } } fn main() { let mut vector = vec![1, 2, 3, 4, 5, 6]; let (left, right) = split_at_mut(\u0026amp;mut vector, 3); }  FFI（Foreign Function Interface）特性\nextern \u0026quot;C\u0026quot; { fn abs(input: i32) -\u0026gt; i32; } fn main() { unsafe { println!(\u0026quot;Absolute value of -3 according to C: {}\u0026quot;, abs(-3)); } }  Accessing or Modifying a Mutable Static Variable 修改静态变量\nstatic mut COUNTER: u32 = 0; fn add_to_count(inc: u32) { unsafe { COUNTER += inc; } } fn main() { add_to_count(3); unsafe { println!(\u0026quot;COUNTER: {}\u0026quot;, COUNTER); } }  Advanced Traits 类型参数（特质中定义类型别名）\nstruct Counter { count: u32, } impl Counter { fn new() -\u0026gt; Counter { Counter { count: 0 } } } impl Iterator for Counter { type Item = u32; fn next(\u0026amp;mut self) -\u0026gt; Option\u0026lt;Self::Item\u0026gt; { // --snip-- if self.count \u0026lt; 5 { self.count += 1; Some(self.count) } else { None } } }  没看懂，（与泛型的区别） - -|\n The difference is that when using generics, as in Listing 19-13, we must annotate the types in each implementation; because we can also implement Iterator for Counter or any other type, we could have multiple implementations of Iterator for Counter. In other words, when a trait has a generic parameter, it can be implemented for a type multiple times, changing the concrete types of the generic type parameters each time. When we use the next method on Counter, we would have to provide type annotations to indicate which implementation of Iterator we want to use. With associated types, we don’t need to annotate types because we can’t implement a trait on a type multiple times. In Listing 19-12 with the definition that uses associated types, we can only choose what the type of Item will be once, because there can only be one impl Iterator for Counter. We don’t have to specify that we want an iterator of u32 values everywhere that we call next on Counter.\n 操作符重载\nuse std::ops::Add; #[derive(Debug, PartialEq)] struct Point { x: i32, y: i32, } impl Add for Point { type Output = Point; fn add(self, other: Point) -\u0026gt; Point { Point { x: self.x + other.x, y: self.y + other.y, } } } fn main() { assert_eq!( Point { x: 1, y: 0 } + Point { x: 2, y: 3 }, Point { x: 3, y: 3 } ); }  泛型参数的默认值\n#![allow(unused_variables)] fn main() { trait Add\u0026lt;RHS=Self\u0026gt; { type Output; fn add(self, rhs: RHS) -\u0026gt; Self::Output; } }  同名方法\ntrait Pilot { fn fly(\u0026amp;self); } trait Wizard { fn fly(\u0026amp;self); } struct Human; impl Pilot for Human { fn fly(\u0026amp;self) { println!(\u0026quot;This is your captain speaking.\u0026quot;); } } impl Wizard for Human { fn fly(\u0026amp;self) { println!(\u0026quot;Up!\u0026quot;); } } impl Human { fn fly(\u0026amp;self) { println!(\u0026quot;*waving arms furiously*\u0026quot;); } } fn main() { let person = Human; //will call Human's fly method directly person.fly(); }  调用同名方法\ntrait Pilot { fn fly(\u0026amp;self); } trait Wizard { fn fly(\u0026amp;self); } struct Human; impl Pilot for Human { fn fly(\u0026amp;self) { println!(\u0026quot;This is your captain speaking.\u0026quot;); } } impl Wizard for Human { fn fly(\u0026amp;self) { println!(\u0026quot;Up!\u0026quot;); } } impl Human { fn fly(\u0026amp;self) { println!(\u0026quot;*waving arms furiously*\u0026quot;); } } fn main() { let person = Human; Pilot::fly(\u0026amp;person); Wizard::fly(\u0026amp;person); person.fly(); }  全限定名调用 格式：\u0026lt;Type as Trait\u0026gt;::function(receiver_if_method, next_arg, ...);\ntrait Animal { fn baby_name() -\u0026gt; String; } struct Dog; impl Dog { fn baby_name() -\u0026gt; String { String::from(\u0026quot;Spot\u0026quot;) } } impl Animal for Dog { fn baby_name() -\u0026gt; String { String::from(\u0026quot;puppy\u0026quot;) } } fn main() { println!(\u0026quot;A baby dog is called a {}\u0026quot;, Dog::baby_name()); // println!(\u0026quot;A baby dog is called a {}\u0026quot;, Animal::baby_name()); not work rust doesn't known which implement is println!(\u0026quot;A baby dog is called a {}\u0026quot;, \u0026lt;Dog as Animal\u0026gt;::baby_name()); }  Advanced Types 类型别名\nfn main() { type Thunk = Box\u0026lt;dyn Fn() + Send + 'static\u0026gt;; let f: Thunk = Box::new(|| println!(\u0026quot;hi\u0026quot;)); fn takes_long_type(f: Thunk) { // --snip-- } fn returns_long_type() -\u0026gt; Thunk { // --snip-- Box::new(|| ()) } }  还支持泛型\nuse std::fmt; type Result\u0026lt;T\u0026gt; = std::result::Result\u0026lt;T, std::io::Error\u0026gt;; pub trait Write { fn write(\u0026amp;mut self, buf: \u0026amp;[u8]) -\u0026gt; Result\u0026lt;usize\u0026gt;; fn flush(\u0026amp;mut self) -\u0026gt; Result\u0026lt;()\u0026gt;; fn write_all(\u0026amp;mut self, buf: \u0026amp;[u8]) -\u0026gt; Result\u0026lt;()\u0026gt;; fn write_fmt(\u0026amp;mut self, fmt: fmt::Arguments) -\u0026gt; Result\u0026lt;()\u0026gt;; } fn main() {}  如何返回闭包函数？ Box Everything\n#![allow(unused_variables)] fn main() { fn returns_closure() -\u0026gt; Box\u0026lt;dyn Fn(i32) -\u0026gt; i32\u0026gt; { Box::new(|x| x + 1) } }  Macros 使用macro_rules!定义宏\n规则如下：\n Custom #[derive] macros that specify code added with the derive attribute used on structs and enums Attribute-like macros that define custom attributes usable on any item Function-like macros that look like function calls but operate on the tokens specified as their argument  宏的作用：\n macros are a way of writing code that writes other code, which is known as metaprogramming\n #![allow(unused_variables)] fn main() { #[macro_export] macro_rules! vec { ( $( $x:expr ),* ) =\u0026gt; { { let mut temp_vec = Vec::new(); $( temp_vec.push($x); )* temp_vec } }; } }  #[macro_export]用来供外部使用定义的宏\n宏写起来就像是再写AST和正则表达式，$n:expr用来匹配任意表达式 $(,)?相当于匹配逗号是否出现；\nprocedural macros过程宏(太复杂以后遇到了在研究)\nuse proc_macro; #[some_attribute] pub fn some_name(input: TokenStream) -\u0026gt; TokenStream { }  Rust版注解\nuse proc_macro::TokenStream; #[route(GET,\u0026quot;/\u0026quot;)] fn index(){} fn main() { index(); } #[proc_macro_attribute] fn route(attr:TokenStream,item:TokenStream)-\u0026gt;TokenStream{ }  完!\n","id":2,"section":"posts","summary":"Rust Unsafe 使用unsafe的五种特性： Dereference a raw pointer Call an unsafe function or method Access or modify a mutable static variable Implement an unsafe trait Access fields of unions Dereferencing a Raw Pointer 定义 raw pointer fn main() { let mut num = 5; let r1 = \u0026amp;num as *const i32; let r2 = \u0026amp;mut num as","tags":["programing","rust"],"title":"Rust Features","uri":"https://holicc.github.io/2020/08/rust-features/","year":"2020"},{"content":"Unix时间戳：\nGet-Date -UFormat %s  查看文件（类似cat的功能）\ntype $file  创建文件：\nNew-Item [path]  使用记事本打开文件\nStart-Process notepad $file  打开文件夹\nii .  或者\nInvoke-Item .  ","id":3,"section":"posts","summary":"Unix时间戳： Get-Date -UFormat %s 查看文件（类似cat的功能） type $file 创建文件： New-Item [path] 使用记事本打开文件 Start-Process notepad $file 打开文件夹 ii . 或者 Invoke-Item .","tags":["powershell"],"title":"Powershell Notes","uri":"https://holicc.github.io/2020/08/powershell-notes/","year":"2020"},{"content":"Rust Smart Pointer (智能指针) 普通指针（Reference）: \u0026amp; 使用这个定义的，只是指向了对应的内存地址，并没有其他的功能；\n智能指针（Smart Pointer）就是能够拥有多个owner并且在没有owner时自动清理回收。（GC？！），并且提供了一些其他功能；\n This pointer enables you to have multiple owners of data by keeping track of the number of owners and, when no owners remain, cleaning up the data.\n Rust中普通的指针只是一个借用，然而智能指针是拥有\n In Rust, which uses the concept of ownership and borrowing, an additional difference between references and smart pointers is that references are pointers that only borrow data; in contrast, in many cases, smart pointers own the data they point to.\n 指针指针是一种实现了Deref和Drop接口的结构体\nbox是Rust中常用的智能指针，它会将存储的数据放在堆中而不是栈上。该指针也不会影响性能，只是没有额外的功能罢了。\n When you have a type whose size can’t be known at compile time and you want to use a value of that type in a context that requires an exact size When you have a large amount of data and you want to transfer ownership but ensure the data won’t be copied when you do so When you want to own a value and you care only that it’s a type that implements a particular trait rather than being of a specific type  fn main() { let b = Box::new(5); println!(\u0026quot;b = {}\u0026quot;, b); }  使用Deref来控制解引用的过程\nuse std::ops::Deref; impl\u0026lt;T\u0026gt; Deref for MyBox\u0026lt;T\u0026gt; { type Target = T; fn deref(\u0026amp;self) -\u0026gt; \u0026amp;T { \u0026amp;self.0 } } struct MyBox\u0026lt;T\u0026gt;(T); impl\u0026lt;T\u0026gt; MyBox\u0026lt;T\u0026gt; { fn new(x: T) -\u0026gt; MyBox\u0026lt;T\u0026gt; { MyBox(x) } } fn main() { let x = 5; let y = MyBox::new(x); assert_eq!(5, x); assert_eq!(5, *y); }  当一个变量的值将要离开作用域的时候，可以使用Drop特质来提前感知这一操作并做出相应的处理。例如：Box就是使用来Drop来释放它所持有的指针的。\nstruct CustomSmartPointer { data: String, } impl Drop for CustomSmartPointer { fn drop(\u0026amp;mut self) { println!(\u0026quot;Dropping CustomSmartPointer with data `{}`!\u0026quot;, self.data); } } fn main() { let c = CustomSmartPointer { data: String::from(\u0026quot;my stuff\u0026quot;), }; let d = CustomSmartPointer { data: String::from(\u0026quot;other stuff\u0026quot;), }; println!(\u0026quot;CustomSmartPointers created.\u0026quot;); }  Drop特质相当与告诉编译器，在特定的地方自动插入代码使其调用drop方法，好让变量自动释放。\n该特质的drop方法不支持手动调用，该方法必须由编译器来自动调用，如果手动调用该方法会编译不通过的 （explicit destructor calls not allowed）。\n原因很简单，Rust并不会智能到见到到了手动调用drop就会不执行已经插入的自动drop方法，所以会造成两次释放同一个变量\n Rust doesn’t let us call drop explicitly because Rust would still automatically call drop on the value at the end of main. This would be a double free error because Rust would be trying to clean up the same value twice.\n 当然有些情况我们是想要提前释放资源，这种情况就需要使用标准库中std::mem::drop的drop函数\nstruct CustomSmartPointer { data: String, } impl Drop for CustomSmartPointer { fn drop(\u0026amp;mut self) { println!(\u0026quot;Dropping CustomSmartPointer with data `{}`!\u0026quot;, self.data); } } fn main() { let c = CustomSmartPointer { data: String::from(\u0026quot;some data\u0026quot;), }; println!(\u0026quot;CustomSmartPointer created.\u0026quot;); drop(c); println!(\u0026quot;CustomSmartPointer dropped before the end of main.\u0026quot;); }  Rc\u0026lt;T\u0026gt;（全称：reference counting）是一个可以让变量拥有多个owner的指针。\n官方举了个例子，生动形象的理解Rc\u0026lt;T\u0026gt;\n Imagine Rc as a TV in a family room. When one person enters to watch TV, they turn it on. Others can come into the room and watch the TV. When the last person leaves the room, they turn off the TV because it’s no longer being used. If someone turns off the TV while others are still watching it, there would be uproar from the remaining TV watchers!\n enum List { Cons(i32, Rc\u0026lt;List\u0026gt;), Nil, } use crate::List::{Cons, Nil}; use std::rc::Rc; fn main() { let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil))))); let b = Cons(3, Rc::clone(\u0026amp;a)); let c = Cons(4, Rc::clone(\u0026amp;a)); }  Rc::clone使用的是浅拷贝，这里每次拷贝了之后会使a引用计数加一。也可以使用a.clone()，如何使用clone取决于使用场景。\n We could have called a.clone() rather than Rc::clone(\u0026amp;a), but Rust’s convention is to use Rc::clone in this case. The implementation of Rc::clone doesn’t make a deep copy of all the data like most types’ implementations of clone do. The call to Rc::clone only increments the reference count, which doesn’t take much time. Deep copies of data can take a lot of time. By using Rc::clone for reference counting, we can visually distinguish between the deep-copy kinds of clones and the kinds of clones that increase the reference count. When looking for performance problems in the code, we only need to consider the deep-copy clones and can disregard calls to Rc::clone.\n 可以使用Rc::strong_count(\u0026amp;a)查看当前变量有多少个引用。\nRefCell\u0026lt;T\u0026gt; (不知名指针)用于打破Rust规则的指针。因为有时Rust编译器不能正确的分析出代码的Ownership就会拒绝编译，但是编写代码者能够保证这段代码是符合Rust规则的，所以这个时候就可以使用这个指针来使编译通过，并且在运行时来进行Ownership的检查工作，如果发现规则被打破，就会panic。\n The advantage of checking the borrowing rules at runtime instead is that certain memory-safe scenarios are then allowed, whereas they are disallowed by the compile-time checks. Static analysis, like the Rust compiler, is inherently conservative. Some properties of code are impossible to detect by analyzing the code: the most famous example is the Halting Problem, which is beyond the scope of this book but is an interesting topic to research.\nBecause some analysis is impossible, if the Rust compiler can’t be sure the code complies with the ownership rules, it might reject a correct program; in this way, it’s conservative. If Rust accepted an incorrect program, users wouldn’t be able to trust in the guarantees Rust makes. However, if Rust rejects a correct program, the programmer will be inconvenienced, but nothing catastrophic can occur. The RefCell type is useful when you’re sure your code follows the borrowing rules but the compiler is unable to understand and guarantee that.\n Rc\u0026lt;T\u0026gt;, RefCell\u0026lt;T\u0026gt;这两个指针都只能在单线程的环境下使用。\nBox\u0026lt;T\u0026gt;, Rc\u0026lt;T\u0026gt;, RefCell\u0026lt;T\u0026gt;三者的区别\n Rc\u0026lt;T\u0026gt;允许一个变量有多个拥有者，其他两个只能有一个。 Box\u0026lt;T\u0026gt;支持编译期的可变的和不可变的借用检查；Rc\u0026lt;T\u0026gt;支持编译期的不可变的借用检查；RefCell\u0026lt;T\u0026gt;支持运行时的可变的和不可变的借用检查； Refcell\u0026lt;T\u0026gt;可以改变一个不可变的变量（Because RefCell allows mutable borrows checked at runtime, you can mutate the value inside the RefCell even when the RefCell is immutable.）  突变模式？！\n Mutating the value inside an immutable value is the interior mutability pattern.\n #[derive(Debug)] enum List { Cons(Rc\u0026lt;RefCell\u0026lt;i32\u0026gt;\u0026gt;, Rc\u0026lt;List\u0026gt;), Nil, } use crate::List::{Cons, Nil}; use std::cell::RefCell; use std::rc::Rc; fn main() { let value = Rc::new(RefCell::new(5)); let a = Rc::new(Cons(Rc::clone(\u0026amp;value), Rc::new(Nil))); let b = Cons(Rc::new(RefCell::new(6)), Rc::clone(\u0026amp;a)); let c = Cons(Rc::new(RefCell::new(10)), Rc::clone(\u0026amp;a)); *value.borrow_mut() += 10; println!(\u0026quot;a after = {:?}\u0026quot;, a); println!(\u0026quot;b after = {:?}\u0026quot;, b); println!(\u0026quot;c after = {:?}\u0026quot;, c); }  循环依赖可能会造成内存泄漏的问题，因为使用了Rc\u0026lt;T\u0026gt;如果相互依赖那么引用数就永远不会为0。（Java中的GC也有这个问题，用可达性分析解决的）\nuse crate::List::{Cons, Nil}; use std::cell::RefCell; use std::rc::Rc; #[derive(Debug)] enum List { Cons(i32, RefCell\u0026lt;Rc\u0026lt;List\u0026gt;\u0026gt;), Nil, } impl List { fn tail(\u0026amp;self) -\u0026gt; Option\u0026lt;\u0026amp;RefCell\u0026lt;Rc\u0026lt;List\u0026gt;\u0026gt;\u0026gt; { match self { Cons(_, item) =\u0026gt; Some(item), Nil =\u0026gt; None, } } } fn main() { let a = Rc::new(Cons(5, RefCell::new(Rc::new(Nil)))); println!(\u0026quot;a initial rc count = {}\u0026quot;, Rc::strong_count(\u0026amp;a)); println!(\u0026quot;a next item = {:?}\u0026quot;, a.tail()); let b = Rc::new(Cons(10, RefCell::new(Rc::clone(\u0026amp;a)))); println!(\u0026quot;a rc count after b creation = {}\u0026quot;, Rc::strong_count(\u0026amp;a)); println!(\u0026quot;b initial rc count = {}\u0026quot;, Rc::strong_count(\u0026amp;b)); println!(\u0026quot;b next item = {:?}\u0026quot;, b.tail()); if let Some(link) = a.tail() { *link.borrow_mut() = Rc::clone(\u0026amp;b); } println!(\u0026quot;b rc count after changing a = {}\u0026quot;, Rc::strong_count(\u0026amp;b)); println!(\u0026quot;a rc count after changing a = {}\u0026quot;, Rc::strong_count(\u0026amp;a)); // Uncomment the next line to see that we have a cycle; // it will overflow the stack // println!(\u0026quot;a next item = {:?}\u0026quot;, a.tail()); }  Rust无法处理循环依赖导致的内存泄露问题，因为这都是写代码自己的写的问题，换成其他语言也会出现这样的问题。\n但Rust也不是任人自生自灭，如何防止循环引用的形成，Rust中引入了弱引用的概念（Java中的虚引用），使用Rc\u0026lt;T\u0026gt;中的Rc::downgrade会增加weak_count的数量，然而回收的时候不管week_count是否是0都会回收释放资源，只要strong_count为0时。\n为了能够从新获取弱引用，可以使用upgrade方法对其进行升级，返回的是一个Option\u0026lt;Rc\u0026lt;T\u0026gt;\u0026gt;\nuse std::cell::RefCell; use std::rc::{Rc, Weak}; #[derive(Debug)] struct Node { value: i32, parent: RefCell\u0026lt;Weak\u0026lt;Node\u0026gt;\u0026gt;, children: RefCell\u0026lt;Vec\u0026lt;Rc\u0026lt;Node\u0026gt;\u0026gt;\u0026gt;, } fn main() { let leaf = Rc::new(Node { value: 3, parent: RefCell::new(Weak::new()), children: RefCell::new(vec![]), }); println!(\u0026quot;leaf parent = {:?}\u0026quot;, leaf.parent.borrow().upgrade()); let branch = Rc::new(Node { value: 5, parent: RefCell::new(Weak::new()), children: RefCell::new(vec![Rc::clone(\u0026amp;leaf)]), }); *leaf.parent.borrow_mut() = Rc::downgrade(\u0026amp;branch); println!(\u0026quot;leaf parent = {:?}\u0026quot;, leaf.parent.borrow().upgrade()); }  智能指针，有点复杂...\n完！\n","id":4,"section":"posts","summary":"Rust Smart Pointer (智能指针) 普通指针（Reference）: \u0026amp; 使用这个定义的，只是指向了对应的内存地址，并没有其他的功能； 智能指针（Smart Poin","tags":["programing","rust"],"title":"Rust Smart Pointer","uri":"https://holicc.github.io/2020/08/rust-smart-pointer/","year":"2020"},{"content":"Rust单元测试 在Rust中使用测试，相当于在Java中使用@Test注解一样\n#[cfg(test)] mod tests { #[test] fn it_works() { assert_eq!(2 + 2, 4); } }  其中#[test]就相当于一个注解表示这个函数是一个测试函数，使用assert_eq!来进行期望判断。\n然后使用cargo test就可以运行单元测试了\nRust的测试还自带性能测试只不过需要使用尝鲜版\n除此之外Rust也带有assert功能，其实Java中也有，只不过用的人太少了，都用的junit的assert\nJava中的assert\nclass Scratch { public static void main(String[] args) { assert \u0026quot;hello\u0026quot;.equals(args[0]); } }  Rust中的assert\n#[derive(Debug)] struct Rectangle { width: u32, height: u32, } impl Rectangle { fn can_hold(\u0026amp;self, other: \u0026amp;Rectangle) -\u0026gt; bool { self.width \u0026gt; other.width \u0026amp;\u0026amp; self.height \u0026gt; other.height } } #[cfg(test)] mod tests { use super::*; #[test] fn larger_can_hold_smaller() { let larger = Rectangle { width: 8, height: 7, }; let smaller = Rectangle { width: 5, height: 1, }; assert!(larger.can_hold(\u0026amp;smaller)); } }  两个都是判断一个boolean值，true就相安无事，false就无法通过测试\n由于Rust中使用的是宏提供的功能相对多一点：assert_eq! 和 assert_ne!\n还支持自定义错误信息\npub fn greeting(name: \u0026amp;str) -\u0026gt; String { format!(\u0026quot;Hello {}!\u0026quot;, name) } #[cfg(test)] mod tests { use super::*; #[test] fn greeting_contains_name() { let result = greeting(\u0026quot;Carol\u0026quot;); assert!(result.contains(\u0026quot;Carol\u0026quot;)); } }  对错误异常进行测试\npub struct Guess { value: i32, } impl Guess { pub fn new(value: i32) -\u0026gt; Guess { if value \u0026lt; 1 || value \u0026gt; 100 { panic!(\u0026quot;Guess value must be between 1 and 100, got {}.\u0026quot;, value); } Guess { value } } } #[cfg(test)] mod tests { use super::*; #[test] #[should_panic] fn greater_than_100() { Guess::new(200); } }  还支持使用Result\u0026lt;T,E\u0026gt;类型作为返回值来编写单元测试\n#![allow(unused_variables)] fn main() { #[cfg(test)] mod tests { #[test] fn it_works() -\u0026gt; Result\u0026lt;(), String\u0026gt; { if 2 + 2 == 4 { Ok(()) } else { Err(String::from(\u0026quot;two plus two does not equal four\u0026quot;)) } } } }  但是这样写了就不能使用#[should_panic] 了.\n再来说说cargo test命令，这个命令特别强大，能支持的东西很多；\n例如你可以让测试并行执行或者串行，Rust默认使用的是并行执行单元测试的。\n可以通过参数设置让单元测试并行或串行\n$ cargo test -- --test-threads=1  Showing Function Output人性化的设计，在单元测试中的打印信息println!，只有在单元测试不通过的情况下才会打印在终端上；\n如果想不管是否通过都打印信息使用参数\n$ cargo test -- --show-output  也可以通过指定测试的名称来运行单个单元测试或者多个单元测试\n#![allow(unused_variables)] fn main() { pub fn add_two(a: i32) -\u0026gt; i32 { a + 2 } #[cfg(test)] mod tests { use super::*; #[test] fn add_two_and_two() { assert_eq!(4, add_two(2)); } #[test] fn add_three_and_two() { assert_eq!(5, add_two(3)); } #[test] fn one_hundred() { assert_eq!(102, add_two(100)); } } }  以上的单元测试可以通过在命令cargo test one_two 来只运行 add_two_and_two这个单元测试，也可以通过 命令 cargo test add来运行以add开头的单元测试\n对于忽视的单元测试直接在单元测试上加上#[ignore]注解就行了\n如果要执行之前忽视的单元测试只需要使用命令\n$ cargo test -- --ignored  Rust可以测试private的函数！！！赞\npub fn add_two(a: i32) -\u0026gt; i32 { internal_adder(a, 2) } fn internal_adder(a: i32, b: i32) -\u0026gt; i32 { a + b } #[cfg(test)] mod tests { use super::*; #[test] fn internal() { assert_eq!(4, internal_adder(2, 2)); } }  完!\n","id":5,"section":"posts","summary":"Rust单元测试 在Rust中使用测试，相当于在Java中使用@Test注解一样 #[cfg(test)] mod tests { #[test] fn it_works() { assert_eq!(2 + 2, 4); } } 其中#[test]就相当于一个注解","tags":["programing","rust"],"title":"Rust Testing","uri":"https://holicc.github.io/2020/07/rust-testing/","year":"2020"},{"content":"Rust中的错误处理 Rust中没有Exception这个概念，而是把错误分为了两种，一种是可恢复的错误，一种是不可恢复的错误\n对于可恢复的错误使用Result\u0026lt;T,E\u0026gt;类型来封装，不可恢复的错误类型使用panic!来定义；\n对于不可恢复的panic!错误，Rust有两种处理情况， 一种是清理程序运行时产生的‘垃圾数据’（这种方法需要花费一些时间还会导致打包的应用变大）， 一种是什么都不做，让操作系统来处理（这种方法会马上退出，并且打包出来的包会很小）\n可以在Cargo.toml文件中定义[profile]来决定使用哪一种方式：\n[profile.release] panic = 'abort'  有时候panic!打印的报错信息并不是那么的清晰明了，不像Java中的打印信息一样；为了能够看到更多的错误栈信息，可以通过设置一个参数来打印错误栈\n run with RUST_BACKTRACE=1 environment variable to display a backtrace.\n 对于可恢复的错误类型使用Result\u0026lt;T,E\u0026gt;封装的\n#![allow(unused_variables)] fn main() { enum Result\u0026lt;T, E\u0026gt; { Ok(T), Err(E), } }  Rust中的错误处理再配合上模式匹配真的还挺好用的，类似与Java中的try-catch但是更加强大\nuse std::fs::File; use std::io::ErrorKind; fn main() { let f = File::open(\u0026quot;hello.txt\u0026quot;); let f = match f { Ok(file) =\u0026gt; file, Err(error) =\u0026gt; match error.kind() { ErrorKind::NotFound =\u0026gt; match File::create(\u0026quot;hello.txt\u0026quot;) { Ok(fc) =\u0026gt; fc, Err(e) =\u0026gt; panic!(\u0026quot;Problem creating the file: {:?}\u0026quot;, e), }, other_error =\u0026gt; { panic!(\u0026quot;Problem opening the file: {:?}\u0026quot;, other_error) } }, }; }  可以使用类似lamda表达式的东西，可以写的更加简洁\nuse std::fs::File; use std::io::ErrorKind; fn main() { let f = File::open(\u0026quot;hello.txt\u0026quot;).unwrap_or_else(|error| { if error.kind() == ErrorKind::NotFound { File::create(\u0026quot;hello.txt\u0026quot;).unwrap_or_else(|error| { panic!(\u0026quot;Problem creating the file: {:?}\u0026quot;, error); }) } else { panic!(\u0026quot;Problem opening the file: {:?}\u0026quot;, error); } }); }  Resulst\u0026lt;T,E\u0026gt;类型有很多的API类型Java的Stream和Optional一样；\nOptional.orElseThrow()  use std::fs::File; fn main() { let f = File::open(\u0026quot;hello.txt\u0026quot;).unwrap(); }  Optional.orElseThrow(()-\u0026gt;new Exception(\u0026quot;Failed to open hello.txt\u0026quot;))  use std::fs::File; fn main() { let f = File::open(\u0026quot;hello.txt\u0026quot;).expect(\u0026quot;Failed to open hello.txt\u0026quot;); }  #![allow(unused_variables)] fn main() { use std::fs::File; use std::io; use std::io::Read; fn read_username_from_file() -\u0026gt; Result\u0026lt;String, io::Error\u0026gt; { let f = File::open(\u0026quot;hello.txt\u0026quot;); let mut f = match f { Ok(file) =\u0026gt; file, Err(e) =\u0026gt; return Err(e), }; let mut s = String::new(); match f.read_to_string(\u0026amp;mut s) { Ok(_) =\u0026gt; Ok(s), Err(e) =\u0026gt; Err(e), } } }  上述的代码可以使用语法糖?操作符来简化\n#![allow(unused_variables)] fn main() { use std::fs::File; use std::io; use std::io::Read; fn read_username_from_file() -\u0026gt; Result\u0026lt;String, io::Error\u0026gt; { let mut f = File::open(\u0026quot;hello.txt\u0026quot;)?; let mut s = String::new(); f.read_to_string(\u0026amp;mut s)?; Ok(s) } }  还可以更简化一点\n#![allow(unused_variables)] fn main() { use std::fs::File; use std::io; use std::io::Read; fn read_username_from_file() -\u0026gt; Result\u0026lt;String, io::Error\u0026gt; { let mut s = String::new(); File::open(\u0026quot;hello.txt\u0026quot;)?.read_to_string(\u0026amp;mut s)?; Ok(s) } }  然后更简单\nuse std::fs; fn main() { let s = fs::read_to_string(\u0026quot;C:\\\\Users\\\\Joe\\\\IdeaProjects\\\\rust-test\\\\src\\\\main.rs\u0026quot;).unwrap(); println!(\u0026quot;{}\u0026quot;,s) }  ?操作符只被允许是用来函数中返回值类型是Result或者Option或者实现了 std::ops::Try 的类型。\n错误处理看起来挺棒的。\n完！\n","id":6,"section":"posts","summary":"Rust中的错误处理 Rust中没有Exception这个概念，而是把错误分为了两种，一种是可恢复的错误，一种是不可恢复的错误 对于可恢复的错误","tags":["programing","rust"],"title":"Rust Error","uri":"https://holicc.github.io/2020/07/rust-error/","year":"2020"},{"content":"Rust中的集合类型 Rust的标准库中提供了常用的集合类型：Vect(相当于Java中的List)，Map(相当于Java中的Map)，在使用这些集合的过程中需要注意的是 Ownership和let \u0026amp; let mut的一些注意事项\n使用Vect直接使用函数创建或者使用宏\nlet v: Vec\u0026lt;i32\u0026gt; = Vec::new(); //let c = Vec![1,2,3,4];  可以看到Vec是一个支持泛型的集合类型，在创建的时候需要指定其内部元素的具体类型；\n使用mut定义Vector就可以对它进行修改\nlet mut v = Vec::new(); v.push(5); v.push(6); v.push(7); v.push(8);  当然了根据任何变量都有其作用域（Scope）如果不在作用域中了就会被释放掉，并且Vector中的元素也会相应的被释放掉\n{ let v = vec![1, 2, 3, 4]; // do stuff with v } // \u0026lt;- v goes out of scope and is freed here  rust中访问Vector元素有两种方法一种是使用下标访问一种是使用get方法：\nfn main() { let v = vec![1, 2, 3, 4, 5]; let third: \u0026amp;i32 = \u0026amp;v[2]; println!(\u0026quot;The third element is {}\u0026quot;, third); match v.get(2) { Some(third) =\u0026gt; println!(\u0026quot;The third element is {}\u0026quot;, third), None =\u0026gt; println!(\u0026quot;There is no third element.\u0026quot;), } }  区别在于get方法是空安全的，返回的是一个Option\u0026lt;\u0026amp;T\u0026gt;类型，就是说如果get的一个不存在vector中的元素只会返回一个Option\u0026lt;None\u0026gt;,而使用\n\u0026amp;[]下标访问会panic，因为你访问了一个不存在的元素；\nfn main() { let mut v = vec![1, 2, 3, 4, 5]; let first = \u0026amp;v[0]; v.push(6); println!(\u0026quot;The first element is: {}\u0026quot;, first); }  为什么以上代码无法编译通过，可以说是充满了Rust的哲学😂\n This error is due to the way vectors work: adding a new element onto the end of the vector might require allocating new memory and copying the old elements to the new space, if there isn’t enough room to put all the elements next to each other where the vector currently is. In that case, the reference to the first element would be pointing to deallocated memory. The borrowing rules prevent programs from ending up in that situation.\n 官方解释说这跟Vector的实现机制有关，在往Vector中添加新的元素的时候可能会因为原始空间不够容纳这么多元素而导致将原来的元素都拷贝到一个新的地方，从而改变了内部元素的指针，如果这时有一个外部借用的指针还停留在原始的未知就会造成内存访问不正确的问题。\n迭代方式\nfn main() { let v = vec![100, 32, 57]; for i in \u0026amp;v { println!(\u0026quot;{}\u0026quot;, i); } for i in \u0026amp;mut v { *i += 50; //* 表示解引用 } }  官方文档也讲了一些Vector的一些技巧\nfn main() { enum SpreadsheetCell { Int(i32), Float(f64), Text(String), } let row = vec![ SpreadsheetCell::Int(3), SpreadsheetCell::Text(String::from(\u0026quot;blue\u0026quot;)), SpreadsheetCell::Float(10.12), ]; }  在Rust中String也使用集合类型实现的，底层就是一个bytes集合，所以官方也放到了这一章节来讲。\nfn main() { let mut s = String::from(\u0026quot;foo\u0026quot;); s.push_str(\u0026quot;bar\u0026quot;); }  对于如何在String中使用+，这也是一门学问\n This isn’t the exact signature that’s in the standard library: in the standard library, add is defined using generics. Here, we’re looking at the signature of add with concrete types substituted for the generic ones, which is what happens when we call this method with String values. We’ll discuss generics in Chapter 10. This signature gives us the clues we need to understand the tricky bits of the + operator.\nFirst, s2 has an \u0026amp;, meaning that we’re adding a reference of the second string to the first string because of the s parameter in the add function: we can only add a \u0026amp;str to a String; we can’t add two String values together. But wait—the type of \u0026amp;s2 is \u0026amp;String, not \u0026amp;str, as specified in the second parameter to add. So why does Listing 8-18 compile?\nThe reason we’re able to use \u0026amp;s2 in the call to add is that the compiler can coerce the \u0026amp;String argument into a \u0026amp;str. When we call the add method, Rust uses a deref coercion, which here turns \u0026amp;s2 into \u0026amp;s2[..]. We’ll discuss deref coercion in more depth in Chapter 15. Because add does not take ownership of the s parameter, s2 will still be a valid String after this operation.\nSecond, we can see in the signature that add takes ownership of self, because self does not have an \u0026amp;. This means s1 in Listing 8-18 will be moved into the add call and no longer be valid after that. So although let s3 = s1 + \u0002 looks like it will copy both strings and create a new one, this statement actually takes ownership of s1, appends a copy of the contents of s2, and then returns ownership of the result. In other words, it looks like it’s making a lot of copies but isn’t; the implementation is more efficient than copying.\n 官方用了很长一段来说明如何对String类型来使用+号，总结一下就是+其实是就是String的add方法\n看一下方法签名\nfn add(self, s: \u0026amp;str) -\u0026gt; String  接受的对象是一个\u0026amp;str,所以在使用的时候可以是\nlet a = String::from(\u0026quot;test\u0026quot;); let b = a + \u0026quot;zxc\u0026quot;;  也可以是\nlet a = String::from(\u0026quot;test\u0026quot;); let b = String::from(\u0026quot;hello\u0026quot;); let c = a + \u0026amp;b  这里的\u0026amp;b是一个\u0026amp;String会被强转为一个 \u0026amp;str类型。\nString类型也不支持下标访问，（对Java程序员来说很OK）\n最后官方说了一句让人无语的话\n To summarize, strings are complicated. Different programming languages make different choices about how to present this complexity to the programmer. Rust has chosen to make the correct handling of String data the default behavior for all Rust programs, which means programmers have to put more thought into handling UTF-8 data upfront. This trade-off exposes more of the complexity of strings than is apparent in other programming languages, but it prevents you from having to handle errors involving non-ASCII characters later in your development life cycle.\n 好吧，下一个是HashMap\nfn main() { use std::collections::HashMap; let mut scores = HashMap::new(); scores.insert(String::from(\u0026quot;Blue\u0026quot;), 10); scores.insert(String::from(\u0026quot;Yellow\u0026quot;), 50); }  对于非拷贝的值例如String类型，如果把值insert到map中就是对这个值所有权的转移到map中了；\nfn main() { use std::collections::HashMap; let field_name = String::from(\u0026quot;Favorite color\u0026quot;); let field_value = String::from(\u0026quot;Blue\u0026quot;); let mut map = HashMap::new(); map.insert(field_name, field_value); // field_name and field_value are invalid at this point, try using them and // see what compiler error you get! }  如何迭代，很好理解\nfn main() { use std::collections::HashMap; let mut scores = HashMap::new(); scores.insert(String::from(\u0026quot;Blue\u0026quot;), 10); scores.insert(String::from(\u0026quot;Yellow\u0026quot;), 50); for (key, value) in \u0026amp;scores { println!(\u0026quot;{}: {}\u0026quot;, key, value); } }  一些api介绍\nfn main() { use std::collections::HashMap; let mut scores = HashMap::new(); scores.insert(String::from(\u0026quot;Blue\u0026quot;), 10); scores.entry(String::from(\u0026quot;Yellow\u0026quot;)).or_insert(50); scores.entry(String::from(\u0026quot;Blue\u0026quot;)).or_insert(50); println!(\u0026quot;{:?}\u0026quot;, scores); }  相当于Java中的map.putIfAbsent\n其他的就不赘述了，就是了解一下Rust中的集合\n完！\n","id":7,"section":"posts","summary":"Rust中的集合类型 Rust的标准库中提供了常用的集合类型：Vect(相当于Java中的List)，Map(相当于Java中的Map)，在使","tags":["programing","rust"],"title":"Rust Collections","uri":"https://holicc.github.io/2020/07/rust-collections/","year":"2020"},{"content":"RocketMQ服务部署情况介绍 由于项目对消息的可靠性要求比较高所以采用的是SYNC_MASTER+SLAVE的部署方式, 并且使用了ASYNC_FLUSH（同步刷新）机制，虽然Master节点宕机的时候会丢失一部分的消息数据，但是性能上是很大的提升；\n根据官方说明的优缺点：\n 优点：数据与服务都无单点故障，Master宕机情况下，消息无延迟，服务可用性与数据可用性都非常高； 缺点：性能比异步复制模式略低（大约低10%左右），发送单个消息的RT会略高，且目前版本在主节点宕机后，备机不能自动切换为主机（针对4.5以前的版本）。  由于我们使用的是4.7.0版本已经使用了raft 协议解决了这个问题。如果要使集群能够自动容灾切换，需要至少三台机器\n我们一共有4台机器，每台机器的配置：\n32g内存，2T的硬盘，8核CPU  一台机器作为nameserver，其余都是broker，broker之间可以进行自动选举master节点\n部署情况：\n\n配置文件编写情况：\n#所属集群名字 brokerClusterName=RaftCluster brokerName=RaftNode00 ## 启用DLeger enableDLegerCommitLog=true dLegerGroup=RaftNode00 dLegerPeers=n0-127.0.0.1:40911;n1-127.0.0.1:40912;n2-127.0.0.1:40913 dLegerSelfId=n0 #0 表示 Master，\u0026gt;0 表示 Slave brokerId=0 #nameServer地址，分号分割 namesrvAddr=rocketmq-nameserver-0:9876 autoCreateTopicEnable=false autoCreateSubscriptionGroup=false #Broker 对外服务的监听端口，10911为默认值 listenPort=10911 #表示Master监听Slave请求的端口,默认为服务端口+1 haListenPort=10912 #- SLAVE brokerRole=ASYNC_MASTER #刷盘方式 flushDiskType=ASYNC_FLUSH  RocketMQ消费端设置情况 Consumer使用的是公司封装的所以能够配置的参数有限，通过阅读封装的代码发现，\nconsumeMessageBatchMaxSize=10一批次可以处理10条数据 setConsumeThreadMin=3后面修改为了CPU核心数 setConsumeThreadMax=3后面修改为了CPU核心数 setMessageModel=MessageModel.CLUSTERING 集群模式 setConsumeFromWhere=ConsumeFromWhere.CONSUME_FROM_LAST_OFFSET 接着上次消费的进度开始消费\n其余的参数都没有进行改动\nRocketMQ消息堆积了如何解决 原因：消费服务太慢导致消息堆积；\n这里的堆积指的是Consumer拉取的消息消费不过来了导致的堆积\n我们的系统中使用的是PUSH的消费模式，本质上是使用PULL不断的向Broker拉取消息机制的封装。\n解决办法：\n 先修复 consumer 的问题，确保其恢复消费速度，然后将现有 consumer 都停掉。（因为历史数据积压太多，短时间内无法消费完） 建立新的topic，临时建立好原先 10 倍的 queue 数量。 然后写一个临时的分发数据的 consumer 程序，这个程序部署上去消费积压的数据，消费之后不做耗时的处理，直接均匀轮询写入临时建立好的 10 倍数量的 queue 接着临时征扩容机器机器来部署 consumer，每一批 consumer 消费一个临时 queue 的数据。 等快速消费完积压数据之后，得恢复原先部署的架构，重新用原先的 consumer 机器来消费消息。  ","id":8,"section":"posts","summary":"RocketMQ服务部署情况介绍 由于项目对消息的可靠性要求比较高所以采用的是SYNC_MASTER+SLAVE的部署方式, 并且使用了ASYN","tags":["programing","rocketMQ"],"title":"Rust Function","uri":"https://holicc.github.io/2020/07/rocketmq-overstock/","year":"2020"},{"content":"Rust Packages Crates and Modules 每个新出的编程语言都有一套对应的包管理工具，Rust也不列外，Rust使用的是cargo作为其包管理工具；\ncrate是一个单一的库的意思;\n A crate is a binary or library. The crate root is a source file that the Rust compiler starts from and makes up the root module of your crate\n package是一个包的意思，一个包可以包含有多个crate; 其中包含一个 Cargo.toml文件，这个文件相当于maven项目中的pom.xml文件一样的功能；\n A package is one or more crates that provide a set of functionality. A package contains a Cargo.toml file that describes how to build those crates.\n 模块管理，通过使用module来管理函数，是函数能够分到对应的模块中，并再其他地方能够使用他们；有点类似Java的包空间；\nmod front_of_house { mod hosting { fn add_to_waitlist() {} fn seat_at_table() {} } mod serving { fn take_order() {} fn serve_order() {} fn take_payment() {} } }  看了上面的例子我发现，Rust中的关键字定义都使用是三个字母....\n在Rust中crate分为binary和library,binary文件就是对应的main.rs而library对应的是lib.rs 他们都是crate roots\n引入并使用模块中的函数，使用的是paths来定义,可以使用绝对路径和相对路径；\nmod front_of_house { mod hosting { fn add_to_waitlist() {} } } pub fn eat_at_restaurant() { // Absolute path crate::front_of_house::hosting::add_to_waitlist(); // Relative path front_of_house::hosting::add_to_waitlist(); }  pub关键字用来提供函数的访问权限，相当与Java中的public\\private\\proctect\nsuper关键字类似与相对路径的功能,有啥区别呢？不知道。。。\nfn serve_order() {} mod back_of_house { fn fix_incorrect_order() { cook_order(); super::serve_order(); } fn cook_order() {} }  好了下面介绍一下import关键字，呸，是use\nmod front_of_house { pub mod hosting { pub fn add_to_waitlist() {} } } use crate::front_of_house::hosting::add_to_waitlist; pub fn eat_at_restaurant() { add_to_waitlist(); add_to_waitlist(); add_to_waitlist(); }  21世纪的编程语言都带有引包别名的功能 as\n#![allow(unused_variables)] fn main() { use std::fmt::Result; use std::io::Result as IoResult; fn function1() -\u0026gt; Result { // --snip-- Ok(()) } fn function2() -\u0026gt; IoResult\u0026lt;()\u0026gt; { // --snip-- Ok(()) } }  还可以Re-exporting 通过使用 pub use\nmod front_of_house { pub mod hosting { pub fn add_to_waitlist() {} } } pub use crate::front_of_house::hosting; pub fn eat_at_restaurant() { hosting::add_to_waitlist(); hosting::add_to_waitlist(); hosting::add_to_waitlist(); }  不是很明白设计了这么多，搞得有点复杂，是不是因为本身问题很多需要引入这么多技术来解决呢？\n完！\n","id":9,"section":"posts","summary":"Rust Packages Crates and Modules 每个新出的编程语言都有一套对应的包管理工具，Rust也不列外，Rust使用的是cargo作为其包管理工具； crate是一个单一的库","tags":["programing","rust"],"title":"Rust Packages Management","uri":"https://holicc.github.io/2020/07/rust-packages-management/","year":"2020"},{"content":"Rust中的枚举 enum枚举类型，一种熟悉的数据结构，在Java中也有对应的类型，就不赘述了.\nfn main() { enum IpAddrKind { V4, V6, } struct IpAddr { kind: IpAddrKind, address: String, } let home = IpAddr { kind: IpAddrKind::V4, address: String::from(\u0026quot;127.0.0.1\u0026quot;), }; let loopback = IpAddr { kind: IpAddrKind::V6, address: String::from(\u0026quot;::1\u0026quot;), }; }  枚举类中也可以有成员变量\nfn main() { enum IpAddr { V4(String), V6(String), } let home = IpAddr::V4(String::from(\u0026quot;127.0.0.1\u0026quot;)); let loopback = IpAddr::V6(String::from(\u0026quot;::1\u0026quot;)); }  不仅如此，枚举类中的成员还可以拥有不同的类型；\nfn main() { enum IpAddr { V4(u8, u8, u8, u8), V6(String), } let home = IpAddr::V4(127, 0, 0, 1); let loopback = IpAddr::V6(String::from(\u0026quot;::1\u0026quot;)); }  甚至还可以放置匿名结构体\nenum Message { Quit, Move { x: i32, y: i32 }, Write(String), ChangeColor(i32, i32, i32), }  其中的Move就是定义的匿名结构体.\n后面就讲了一下Option,这个Java1.8以后也有的东西，所以还是很熟悉的，只是在Rust中它使用一个枚举类型；\n用法和Java都类似的.\nrust版本\nfn main() { let a: Option\u0026lt;i32\u0026gt; = None; let c = a.expect(\u0026quot;error message \u0026quot;); println!(\u0026quot;hello world {}\u0026quot;, c) }  java版本\nclass Scratch { public static void main(String[] args) throws Exception { String a=\u0026quot;asd\u0026quot;; Optional.ofNullable(a).orElseThrow(()-\u0026gt;new Exception(\u0026quot;zxc\u0026quot;)); } }  神奇的match模式匹配？可惜在Scala中就已经见过了，感觉没啥好学习的。\n#[derive(Debug)] enum UsState { Alabama, Alaska, // --snip-- } enum Coin { Penny, Nickel, Dime, Quarter(UsState), } fn value_in_cents(coin: Coin) -\u0026gt; u8 { match coin { Coin::Penny =\u0026gt; 1, Coin::Nickel =\u0026gt; 5, Coin::Dime =\u0026gt; 10, Coin::Quarter(state) =\u0026gt; { println!(\u0026quot;State quarter from {:?}!\u0026quot;, state); 25 } } } fn main() { value_in_cents(Coin::Quarter(UsState::Alaska)); }  最后这个if let表达式让我有点懵逼，咋一看感觉没啥用啊。\nfn main() { let some_u8_value = Some(0u8); match some_u8_value { Some(3) =\u0026gt; println!(\u0026quot;three\u0026quot;), _ =\u0026gt; (), } }  加个let有啥用呢？还不如直接写成if-else的形式就行了嘛？\nfn main() { let some_u8_value = Some(0u8); if let Some(3) = some_u8_value { println!(\u0026quot;three\u0026quot;); } }  可能为了能够将变量绑定到一个类型里面把，形如：\n#[derive(Debug)] enum UsState { Alabama, Alaska, // --snip-- } enum Coin { Penny, Nickel, Dime, Quarter(UsState), } fn main() { let coin = Coin::Penny; let mut count = 0; if let Coin::Quarter(state) = coin { println!(\u0026quot;State quarter from {:?}!\u0026quot;, state); } else { count += 1; } }  是为了简化match操作而创建的语法糖.\n完!\n","id":10,"section":"posts","summary":"Rust中的枚举 enum枚举类型，一种熟悉的数据结构，在Java中也有对应的类型，就不赘述了. fn main() { enum IpAddrKind { V4, V6, } struct IpAddr { kind: IpAddrKind, address: String, } let home = IpAddr { kind:","tags":["programing","rust"],"title":"Rust Enums And Patter Match","uri":"https://holicc.github.io/2020/07/rust-enums-and-patter-match/","year":"2020"},{"content":"通过使用关键struct可以定义一个类，呸，是定义一个结构体。\nstruct User { username: String, email: String, sign_in_count: u64, active: bool, } fn main() { let user1 = User { email: String::from(\u0026quot;someone@example.com\u0026quot;), username: String::from(\u0026quot;someusername123\u0026quot;), active: true, sign_in_count: 1, }; }  struct与Java中的类是不同的两种数据结构，具体的使用方式也有所不同。\nfn build_user(email: String, username: String) -\u0026gt; User { User { email: email, username: username, active: true, sign_in_count: 1, } }  有一个算是语法糖的功能就是,结构体复用;使用..符号能够复用一个已经创建好的结构中的字段;\nstruct User { username: String, email: String, sign_in_count: u64, active: bool, } fn main() { let user1 = User { email: String::from(\u0026quot;someone@example.com\u0026quot;), username: String::from(\u0026quot;someusername123\u0026quot;), active: true, sign_in_count: 1, }; let user2 = User { email: String::from(\u0026quot;another@example.com\u0026quot;), username: String::from(\u0026quot;anotherusername567\u0026quot;), ..user1 }; }  也可以定义一种类似Java中Record的数据结构\nfn main() { struct Color(i32, i32, i32); struct Point(i32, i32, i32); let black = Color(0, 0, 0); let origin = Point(0, 0, 0); }  看起来虽然跟Golang没什么太大的区别,但是加上了所有权之后就有了一些限制;\nstruct User { username: \u0026amp;str, email: \u0026amp;str, sign_in_count: u64, active: bool, } fn main() { let user1 = User { email: \u0026quot;someone@example.com\u0026quot;, username: \u0026quot;someusername123\u0026quot;, active: true, sign_in_count: 1, }; }  这是Rust团队深思熟虑过后的设计,为了能够让struct的实例能够拥有成员变量的所有权\n In the User struct definition in Listing 5-1, we used the owned String type rather than the \u0026amp;str string slice type. This is a deliberate choice because we want instances of this struct to own all of its data and for that data to be valid for as long as the entire struct is valid.\n 不懂的是为什么这里username使用了\u0026amp;str就没有了username成员变量的所有权?\n难道是因为\u0026amp;str是一个slice类型? slice就是一中没有所有权的数据类型.\n Another data type that does not have ownership is the slice\n 好像是这样的,可以的,Rust强(吹)!\n想要像在Java中一样自由的打印对象,需要在struct上进行一些特殊处理,相当于需要实现一个toString()方法一样.\n#[derive(Debug)] struct Rectangle { width: u32, height: u32, } fn main() { let rect1 = Rectangle { width: 30, height: 50, }; println!(\u0026quot;rect1 is {:?}\u0026quot;, rect1); }  由于Rust是一门拥有面向对象和函数编程的语言，所以在Rust中可以对struct对象定义所属的方法 其中使用了impl和self关键字，语义上还是能够理解的。\n#[derive(Debug)] struct Rectangle { width: u32, height: u32, } impl Rectangle { fn area(\u0026amp;self) -\u0026gt; u32 { self.width * self.height } } fn main() { let rect1 = Rectangle { width: 30, height: 50, }; println!( \u0026quot;The area of the rectangle is {} square pixels.\u0026quot;, rect1.area() ); }  本来以为挺简单的，但是结合上了所有权系统一切都变得复杂了；\n We’ve chosen \u0026amp;self here for the same reason we used \u0026amp;Rectangle in the function version: we don’t want to take ownership, and we just want to read the data in the struct, not write to it. If we wanted to change the instance that we’ve called the method on as part of what the method does, we’d use \u0026amp;mut self as the first parameter. Having a method that takes ownership of the instance by using just self as the first parameter is rare; this technique is usually used when the method transforms self into something else and you want to prevent the caller from using the original instance after the transformation.\n fn area(\u0026amp;self) -\u0026gt; u32 { self.width * self.height }  这个方法始终保持了类型函数的意思,这里的self其实就是函数中的Rectangle相当于move ，加上\u0026amp;后就是Borrowing。当方法需要修改struct实例的中的属性的时候就需要使用\u0026amp;mut self,当需要所有权移交的时候就使用self;\n原来如此，也没有想象的那么复杂（可能吧）。\n把函数放到Impl块中叫做关联函数associated functions相当于Java中的静态方法,通过struct直接调用,就像String::from()\nRust也允许定义对同一个struct多个Impl块\n#[derive(Debug)] struct Rectangle { width: u32, height: u32, } impl Rectangle { fn area(\u0026amp;self) -\u0026gt; u32 { self.width * self.height } } impl Rectangle { fn can_hold(\u0026amp;self, other: \u0026amp;Rectangle) -\u0026gt; bool { self.width \u0026gt; other.width \u0026amp;\u0026amp; self.height \u0026gt; other.height } } fn main() { let rect1 = Rectangle { width: 30, height: 50, }; let rect2 = Rectangle { width: 10, height: 40, }; let rect3 = Rectangle { width: 60, height: 45, }; println!(\u0026quot;Can rect1 hold rect2? {}\u0026quot;, rect1.can_hold(\u0026amp;rect2)); println!(\u0026quot;Can rect1 hold rect3? {}\u0026quot;, rect1.can_hold(\u0026amp;rect3)); }  完!\n","id":11,"section":"posts","summary":"通过使用关键struct可以定义一个类，呸，是定义一个结构体。 struct User { username: String, email: String, sign_in_count: u64, active: bool, } fn main() { let user1 = User { email: String::from(\u0026quot;someone@example.com\u0026quot;), username: String::from(\u0026quot;someusername123\u0026quot;), active: true, sign_in_count: 1, }; } struct与Ja","tags":["programing","rust"],"title":"Rust Struct","uri":"https://holicc.github.io/2020/07/rust-struct/","year":"2020"},{"content":"Rust中的引用(Reference)与借用(Borrowing) 在上一节的所有权系统的最后，官方抛出了一个问题，就是在函数使用的时候，如果把参数传进去就把所有权移交到了函数中，那么后续又如何使用这个移交所有权后的变量呢？\nfn main() { let s1 = String::from(\u0026quot;hello\u0026quot;); let (s2, len) = calculate_length(s1); println!(\u0026quot;The length of '{}' is {}.\u0026quot;, s2, len); } fn calculate_length(s: String) -\u0026gt; (String, usize) { let length = s.len(); // len() returns the length of a String (s, length) }  官方给出的代码如上，但是这样写就太繁琐了。\n本节就是讲如何使用Reference和Borrorwing来解决这个问题。\n先来一段代码起手\nfn main() { let s1 = String::from(\u0026quot;hello\u0026quot;); let len = calculate_length(\u0026amp;s1); println!(\u0026quot;The length of '{}' is {}.\u0026quot;, s1, len); } fn calculate_length(s: \u0026amp;String) -\u0026gt; usize { s.len() }  上面这段代码，我理解的是传递的是s1变量的指针，所有s1变量的所有权没有移交出去。\n\u0026amp;这个符号，记得在C语言中是取地址的意思。\n The \u0026amp;s1 syntax lets us create a reference that refers to the value of s1 but does not own it. Because it does not own it, the value it points to will not be dropped when the reference goes out of scope.\n 在Rust中这样使用引用的方式叫做Borrowing借用,这种方式允许获取一个值的引用而不用移交所有权,因为你始终是东西的主人，别人只是借用了你的东西。\n We call having references as function parameters borrowing. As in real life, if a person owns something, you can borrow it from them. When you’re done, you have to give it back.\n 那么就有个问题，别人借的东西‘弄坏了怎么办？’\n一下代码不能编译通过是因为我们不能修改别人的东西。\nfn main() { let s = String::from(\u0026quot;hello\u0026quot;); change(\u0026amp;s); } fn change(some_string: \u0026amp;String) { some_string.push_str(\u0026quot;, world\u0026quot;); }  如果强行修改别人的东西那么就需要这样写（相当于在修改别人的东西时，先问一句：“我可以修改你的数据吗？”）\nfn main() { let mut s = String::from(\u0026quot;hello\u0026quot;); change(\u0026amp;mut s); } fn change(some_string: \u0026amp;mut String) { some_string.push_str(\u0026quot;, world\u0026quot;); }  但是呢，这样又有很多的限制，你不能把东西借给多个想要修改的人。\nfn main() { let mut s = String::from(\u0026quot;hello\u0026quot;); let r1 = \u0026amp;mut s; let r2 = \u0026amp;mut s; println!(\u0026quot;{}, {}\u0026quot;, r1, r2); }   Data races cause undefined behavior and can be difficult to diagnose and fix when you’re trying to track them down at runtime; Rust prevents this problem from happening because it won’t even compile code with data races!\n 为什么不许允许同一引用的多出修改，是为了避免数据竞争带来的各种不安全的行为。\n一种折中的写法是：\nfn main() { let mut s = String::from(\u0026quot;hello\u0026quot;); { let r1 = \u0026amp;mut s; } // r1 goes out of scope here, so we can make a new reference with no problems. let r2 = \u0026amp;mut s; }  但是不能通是把不可变引用和可变引用都借出去：\nfn main() { let mut s = String::from(\u0026quot;hello\u0026quot;); let r1 = \u0026amp;s; // no problem let r2 = \u0026amp;s; // no problem let r3 = \u0026amp;mut s; // BIG PROBLEM println!(\u0026quot;{}, {}, and {}\u0026quot;, r1, r2, r3); }  WTF?! 打脸\nfn main() { let mut s = String::from(\u0026quot;hello\u0026quot;); let r1 = \u0026amp;s; // no problem let r2 = \u0026amp;s; // no problem println!(\u0026quot;{} and {}\u0026quot;, r1, r2); // r1 and r2 are no longer used after this point let r3 = \u0026amp;mut s; // no problem println!(\u0026quot;{}\u0026quot;, r3); }   Note that a reference’s scope starts from where it is introduced and continues through the last time that reference is used. For instance, this code will compile because the last usage of the immutable references occurs before the mutable reference is introduced:\n 官方文档告诉我，只要不可变的引用被使用了，那么就会被释放，从而后续定义的可变引用r3定义就是能够编译通过的。\n这个“奇怪”的设计，官方也给出了安慰\n Even though borrowing errors may be frustrating at times, remember that it’s the Rust compiler pointing out a potential bug early (at compile time rather than at runtime) and showing you exactly where the problem is. Then you don’t have to track down why your data isn’t what you thought it was.\n 编译时期发能发现的问题，总比运行时的异常好吧 😂。\n之前说到会把”借来的东西玩坏“，就是一下这种情况，专业术语dangle 悬垂指针:\nfn main() { let reference_to_nothing = dangle(); } fn dangle() -\u0026gt; \u0026amp;String { // dangle returns a reference to a String let s = String::from(\u0026quot;hello\u0026quot;); // s is a new String \u0026amp;s // we return a reference to the String, s } // Here, s goes out of scope, and is dropped. Its memory goes away. // Danger!  因为是借用来的东西，在使用完后就会被释放掉，然而这里把他作为返回值返回就会造成悬垂指针的出现。\n解决这个问题也很简单，只要返回一个新的东西就行了。\nfn main() { let string = no_dangle(); } fn no_dangle() -\u0026gt; String { let s = String::from(\u0026quot;hello\u0026quot;); s }  学习到现在，这些东西都还是能够理解的，都是为了解决垃圾回收内存安全相关而发明的特性。\n完!\n","id":12,"section":"posts","summary":"Rust中的引用(Reference)与借用(Borrowing) 在上一节的所有权系统的最后，官方抛出了一个问题，就是在函数使用的时候，如果","tags":["programing","rust"],"title":"Rust Reference And Borrowing","uri":"https://holicc.github.io/2020/07/rust-references-and-borrowing/","year":"2020"},{"content":"Rust中的所有权系统(Ownership) 目前大部分的编程语言管理内存都是使用的：1.自动管理(垃圾回收机制，像Java) 2.手动编码控制内存的分配(像C或C++) 然而Rust不一样，另辟蹊径，靠的是编译器来保证内存的分配和回收。也叫做Ownership,这一概念是在Rust中独有的，是Rust独有的特性之一。如何看待这一特性，就是仁者见仁智者见智了，对于一个Java程序员来说，这一特性彷佛没有那么好，反而有点让人接受不了(可能是因为Rust是一门系统级别的编程语言，比较注重性能和安全性)\n memory is managed through a system of ownership with a set of rules that the compiler checks at compile time. None of the ownership features slow down your program while it’s running.\n 要明白所有权系统，要先对堆栈有基本的认识。\n All data stored on the stack must have a known, fixed size. Data with an unknown size at compile time or a size that might change must be stored on the heap instead\n 编译期间能够知道大小的变量是分配到栈上，无法确定大小的就是分配到堆上。（也不是绝对的）\n这个点不知道，记录一下\n When your code calls a function, the values passed into the function (including, potentially, pointers to data on the heap) and the function’s local variables get pushed onto the stack. When the function is over, those values get popped off the stack.\n 函数中的局部变量是分配在栈上的，每当函数调用完成，变量也已经被弹出栈顶了。\n官方文档也总结的很到位\n Keeping track of what parts of code are using what data on the heap, minimizing the amount of duplicate data on the heap, and cleaning up unused data on the heap so you don’t run out of space are all problems that ownership addresses. Once you understand ownership, you won’t need to think about the stack and the heap very often, but knowing that managing heap data is why ownership exists can help explain why it works the way it does.\n 所有权系统主要是为了帮助你更好的管理变量在堆栈上的分配。系统级别的编程语言比较在变量是分配到堆还是栈上，对于使用Java的我来说，对与这个概念是相当模糊的，只是大概知道Java中的对象大部分都是分配到堆上的，而且GC也是针对堆上的对象进行的回收。 为此顺便学习一下Java方面的知识吧。\nJVM规范让每个Java线程拥有自己的独立的JVM栈，也就是Java方法的调用栈。\nJVM里的“堆”（heap）特指用于存放Java对象的内存区域。所以根据这个定义，Java对象全部都在堆上\n要注意，这个“堆”并不是数据结构意义上的堆（Heap (data structure)，一种有序的树），而是动态内存分配意义上的堆——用于管理动态生命周期的内存区域。\nJVM的堆被同一个JVM实例中的所有Java线程共享。它通常由某种自动内存管理机制所管理，这种机制通常叫做“垃圾回收”（garbage collection，GC）。JVM规范并不强制要求JVM实现采用哪种GC算法。\n好了，回到Rust中的所有权系统。\n所有权系统需要熟知一下三条规则：\n Each value in Rust has a variable that’s called its owner(每一变量都有其拥有者//不知道这样翻译对不对 - -). There can only be one owner at a time.(同一时刻一个变量只能有一个拥有者) When the owner goes out of scope, the value will be dropped.(当拥有者不在作用域中了，那么这个值就会被释放掉)  规则比我想象的要简单明了许多，看上去很简洁，实际上却饱含了很多信息量。。。\n其中提到了scope(作用域)这个概念，有点类似于Spring中的scope的样子或者http中的session作用域和request作用域。\n官方给的例子还是很容易理解的\nfn main() { { // s is not valid here, it’s not yet declared let s = \u0026quot;hello\u0026quot;; // s is valid from this point forward // do stuff with s } // this scope is now over, and s is no longer valid }  有一点特殊的是String和literal\n在IDEA的提示下发现这是两种不同的类型，然儿在Java中都是统一的String\n\n原因是因为literal是固定长度的不可变的，分配在栈上的数据结构。而String是跟Java中的String类型一样是可变的。\n同为String类型但是有点不同的是。\nJava中的String可以这样写\nclass Scratch { public static void main(String[] args) { String a = \u0026quot;a\u0026quot;; String b = a; a += \u0026quot;zxc\u0026quot;; System.out.println(a + \u0026quot; \u0026quot; + b); } }  然而在Rust中这却不能这样\nfn main() { let s1 = String::from(\u0026quot;hello\u0026quot;); // let s2 = s1; 编译不通过 println!(\u0026quot;{}, world!\u0026quot;, s1); }  原因是因为Rust中是s2并没有对s1进行值拷贝，传递的是s1的指针。根据官方的解释，这里涉及到了 浅拷贝和深拷贝\n If you’ve heard the terms shallow copy and deep copy while working with other languages, the concept of copying the pointer, length, and capacity without copying the data probably sounds like making a shallow copy. But because Rust also invalidates the first variable, instead of being called a shallow copy, it’s known as a move. In this example, we would say that s1 was moved into s2.\n Rust并没有隐式的进行浅拷贝操作。而是让s1失效，这样的操作叫做 moved,相当于把s1上的值的指针移动到了s2上这样 s1就失效了。 为什么要这样做可能是为了能够更好的追踪内存并回收吧。\n如果要使用深拷贝,就要使用clone方法。该方法会对堆和栈上的所有内容进行拷贝。\nfn main() { let s1 = String::from(\u0026quot;hello\u0026quot;); let s2 = s1.clone(); println!(\u0026quot;s1 = {}, s2 = {}\u0026quot;, s1, s2); }  在有些地方，跟Java类似，对于基本的数据类型，都不需要使用显示的使用clone方法\nfn main() { let x = 5; let y = x; println!(\u0026quot;x = {}, y = {}\u0026quot;, x, y); }  在Rust中所有都遵循所有权系统的规则\n在函数中，传递进去的参数也是所有权移交的一种方式\nfn main() { let s = String::from(\u0026quot;hello\u0026quot;); // s comes into scope takes_ownership(s); // s's value moves into the function... // ... and so is no longer valid here let x = 5; // x comes into scope makes_copy(x); // x would move into the function, // but i32 is Copy, so it’s okay to still // use x afterward } // Here, x goes out of scope, then s. But because s's value was moved, nothing // special happens. fn takes_ownership(some_string: String) { // some_string comes into scope println!(\u0026quot;{}\u0026quot;, some_string); } // Here, some_string goes out of scope and `drop` is called. The backing // memory is freed. fn makes_copy(some_integer: i32) { // some_integer comes into scope println!(\u0026quot;{}\u0026quot;, some_integer); } // Here, some_integer goes out of scope. Nothing special happens.  返回值中就更好理解了\nfn main() { let s1 = gives_ownership(); // gives_ownership moves its return // value into s1 let s2 = String::from(\u0026quot;hello\u0026quot;); // s2 comes into scope let s3 = takes_and_gives_back(s2); // s2 is moved into // takes_and_gives_back, which also // moves its return value into s3 } // Here, s3 goes out of scope and is dropped. s2 goes out of scope but was // moved, so nothing happens. s1 goes out of scope and is dropped. fn gives_ownership() -\u0026gt; String { // gives_ownership will move its // return value into the function // that calls it let some_string = String::from(\u0026quot;hello\u0026quot;); // some_string comes into scope some_string // some_string is returned and // moves out to the calling // function } // takes_and_gives_back will take a String and return one fn takes_and_gives_back(a_string: String) -\u0026gt; String { // a_string comes into // scope a_string // a_string is returned and moves out to the calling function }  所有权系统就像是给每一个变量进行了一个轨迹追踪一样。这样的话写代码感觉会更加清晰明了，但是阅读起来可能有点难受吧？\n总体来说还是不错的设计。\n完！\n参考 Java虚拟机的堆、栈、堆栈如何去理解？ RednaxelaFX大佬解答\n","id":13,"section":"posts","summary":"Rust中的所有权系统(Ownership) 目前大部分的编程语言管理内存都是使用的：1.自动管理(垃圾回收机制，像Java) 2.手动编码控制","tags":["programing","rust"],"title":"Rust Function","uri":"https://holicc.github.io/2020/07/rust-ownership/","year":"2020"},{"content":"Rust中的数据类型 Rust是一门静态类型的语言(跟Java一样)，每一个值都有其对应的数据类型(Every value in Rust is of a certain data type)\nNumber Types Rust作为一门面向底层的编程语言，在数据类型上拥有了更多的类型，例如int类型在Java中只有一种表象形式，及表达32位的整形；然而在Rust中分的就特别细了。 在Rust中整型分为 Signed和Unsigned分别对应8，16，32，64，128位; 那么什么是 Signed有符号和 Unsigned 无符号呢？\n 有符号：0111 1111 = 26+25+24+23+22+21+2^0=127;范围是 -128 ~ 127\n无符号：1111 1111 = 27+26+25+24+23+22+21+20=255；范围是 0 ~ 255\n 除了这些，基本的运算符都是相同的，还有包括 float 也是有32位和84位的,char类型是是4字节子的,通用的 bool 类型。\n相比Java而言Rust多了一些复合类型的数据结构，例如： Tuple元组类型，元组是固定大小的，一旦定义完成就不能改变大小。 可以定义不同类型的元组\nfn main() { let tup: (i32, f64, u8) = (500, 6.4, 1); }  其中还包含相应的解包、模式匹配操作。\nfn main() { let tup = (500, 6.4, 1); let (x, y, z) = tup; println!(\u0026quot;The value of y is: {}\u0026quot;, y); }  获取Tuple中的元素直接使用下标就行了\nfn main() { let x: (i32, f64, u8) = (500, 6.4, 1); let five_hundred = x.0; let six_point_four = x.1; let one = x.2; }  接下来是 Array 也和大部分编程语言相同，只是定义的时候有点奇怪,类型和大小使用分号隔开的\nlet a: [i32; 5] = [1, 2, 3, 4, 5];  或者使用一个语法糖的方式定义\nlet a = [3; 5]; // [3, 3, 3, 3, 3]  也是一些基本的数据类型，没啥太特别的东西。\n完！\n","id":14,"section":"posts","summary":"Rust中的数据类型 Rust是一门静态类型的语言(跟Java一样)，每一个值都有其对应的数据类型(Every value in Rust is of a certain data type) Number Types Rust作","tags":["programing","rust"],"title":"Rust Data Types","uri":"https://holicc.github.io/2020/07/rust-data-types/","year":"2020"},{"content":"Rust中的函数 Rust是支持函数编程的，不像Java完全是使用面向对象的编程语言，虽然可以使用Function等，但是还是有些差距的。\nRust中定义函数的关键真是的超级简短，并且提倡使用蛇形命名法（这个挺好的）\nfn main() { another_function(5); } fn another_function(x: i32) { println!(\u0026quot;The value of x is: {}\u0026quot;, x); }  神奇的是你还可以这样写\nfn main() { let x = (let y = 6); }  但是这样写不能编译通过，官方是这样解释的\n Statements do not return values. Therefore, you can’t assign a let statement to another variable, as the following code tries to do; you’ll get an error\n 既然let语句是一个不会有返回值的语句那么如果在表达式中明确了返回值的话就可以了吧\nfn main() { let x = 5; let y = { let x = 3; x + 1 }; println!(\u0026quot;The value of y is: {}\u0026quot;, y); }  这样看来就有点函数式编程的味道了\n在返回值的地方可能有点奇怪,;是被省略掉了。可能对于Java程序员的我来说有点不习惯这样的操作。\n官方文档举出了一个列子来说明;的作用\nfn main() { let x = plus_one(5); println!(\u0026quot;The value of x is: {}\u0026quot;, x); } fn plus_one(x: i32) -\u0026gt; i32 { x + 1 } // 这样写会便宜不通过的 // fn plus_one(x: i32) -\u0026gt; i32 { // x + 1; // }  官方给出的解释如下：\n The main error message, “mismatched types,” reveals the core issue with this code. The definition of the function plus_one says that it will return an i32, but statements don’t evaluate to a value, which is expressed by (), an empty tuple. Therefore, nothing is returned, which contradicts the function definition and results in an error. In this output, Rust provides a message to possibly help rectify this issue: it suggests removing the semicolon, which would fix the error.\n 上了分号表示这是一个 statements ，返回值为一个空的元组及为空，所以和函数定义的返回i32类型不符合，所以编译不通过。\n嗯…… 奇怪\n完！\n","id":15,"section":"posts","summary":"Rust中的函数 Rust是支持函数编程的，不像Java完全是使用面向对象的编程语言，虽然可以使用Function等，但是还是有些差距的。 Ru","tags":["programing","rust"],"title":"Rust Function","uri":"https://holicc.github.io/2020/07/rust-function/","year":"2020"},{"content":"Rust中的变量与常量的定义 Rust中定义变量使用的关键字是 let 关键字，该关键字定义的变量是不可变的;想要定义一个可变的变量需要再使用一个关键 let mut对变量进行定义;\nfn main() { let mut x = 5; println!(\u0026quot;The value of x is: {}\u0026quot;, x); x = 6; println!(\u0026quot;The value of x is: {}\u0026quot;, x); }  为什么这样设计官方给出了解释:\n There are multiple trade-offs to consider in addition to the prevention of bugs. For example, in cases where you’re using large data structures, mutating an instance in place may be faster than copying and returning newly allocated instances. With smaller data structures, creating new instances and writing in a more functional programming style may be easier to think through, so lower performance might be a worthwhile penalty for gaining that clarity.\n 大致是说这是一种折中的设计，为了能够在操纵大的数据结构（类型Java中的对象）时，避免使用拷贝创建一个新的实例，而是直接操作其引用对其进行修改；相反在操作小的对象时拷贝创建一个新的对象更加符合函数式编程的风格更容易理解，当然也会消耗一点性能；\n*这样说是不是意味着 let的使用是进行值的拷贝，let mut只是传递的引用？*\n不过这样设计对于Java程序员来说也是能够理解的。\n定义常量使用的是关键字 const，可以在任何地方定义常量,但是需要注意的是定义常量的时候要把类型补充上去;\nconst A :u8 = 1; fn main() { const C:u16=33; let x = 5; println!(\u0026quot;x has the value {}\u0026quot;, x); }  Rust变量遮蔽(Shadowing) 这是算是一个有意思的特性吧。通过定义同名的变量来进行变量的遮蔽;\nfn main() { let x = 5; let x = x + 1; let x = x * 2; println!(\u0026quot;The value of x is: {}\u0026quot;, x); }  咋一看这不就是定义一个变量然后可以修改它的值嘛。Java中都有这样的,换个名字就变成 Shadowing 了。 - -| 高级。。\npublic static void main(String[] args) { int x = 5; x = x + 1; x = x * 2; System.out.println(x); }  或者相当于\nfn main() { let mut x = 5; x = x + 1; x = x * 2; println!(\u0026quot;The value of x is: {}\u0026quot;, x); }  对于以上的两种方式，官方给出了两个解释:\n Shadowing is different from marking a variable as mut, because we’ll get a compile-time error if we accidentally try to reassign to this variable without using the let keyword. By using let, we can perform a few transformations on a value but have the variable be immutable after those transformations have been completed.\n 第一个解释可以理解为：如果我们不使用let关键来进行遮蔽，那么意味着let定义的变量是可变的。这会导致编译出错，也会给let关键字带来歧义（本身代表的是不可变的意思），这个解释勉强可以理解吧。\n The other difference between mut and shadowing is that because we’re effectively creating a new variable when we use the let keyword again, we can change the type of the value but reuse the same name. For example, say our program asks a user to show how many spaces they want between some text by inputting space characters, but we really want to store that input as a number:\n 第二个解释就很好理解了，只用看一下官方的列子就能明白了。\nfn main() { let spaces = \u0026quot; \u0026quot;; let spaces = spaces.len(); }  完！\n","id":16,"section":"posts","summary":"Rust中的变量与常量的定义 Rust中定义变量使用的关键字是 let 关键字，该关键字定义的变量是不可变的;想要定义一个可变的变量需要再使用一个关键","tags":["programing","rust"],"title":"Rust Variables","uri":"https://holicc.github.io/2020/07/rust-variable/","year":"2020"},{"content":"安装Rust 直接到Rust官方网站 找到适合自己系统的安装包exe文件下载进行安装就行了\n\n官方提供win32位和64位的安装版本，不过一般都是64位的。还提供了WSL的安装版本。\n如果安装rust很慢，使用镜像：\n $ENV:RUSTUP_DIST_SERVER=‘https://mirrors.ustc.edu.cn/rust-static‘\n$ENV:RUSTUP_UPDATE_ROOT=‘https://mirrors.ustc.edu.cn/rust-static/rustup‘\n 然后到微软的官网下载 找到Visual Studio 2019 工具 下载好之后就可以进行安装了。\n勾选基本的C++构建环境\n\n再选择语言包\n\n最后配置IDE插件，本人使用的是IDEA(也可以用Clion)作为IDE。直接到官网找到Rust对应的插件RUST-FOR-IDEA\n(移动网真是太垃圾了，慢的要死) \n安装完之后重启IDEA，创建项目的时候就能看到Rust项目的选项了。\n然后配置一下源(类似Maven的阿里源一样) 清华源\n完！\n","id":17,"section":"posts","summary":"安装Rust 直接到Rust官方网站 找到适合自己系统的安装包exe文件下载进行安装就行了 官方提供win32位和64位的安装版本，不过一般都是6","tags":["programing","rust"],"title":"Install Rust On Win10","uri":"https://holicc.github.io/2020/07/install-rust-win10/","year":"2020"},{"content":"索引是什么 索引（在MySQL中也称为“键（key）”），用于存储引擎快速找到记录的一种数据结构。这是索引的基础功能。 索引可以包含一个列或多个列，当索引包含多个列的时候，那么列的顺序也十分重要，因为MySQL只能使用最左前缀列。\n索引的目的  索引大大减少了服务器扫描的数据量 帮助服务器避免排序和临时表 索引可以将随机I/O变为顺序I/O  索引的种类 在MySQL中，索引是由存储引擎实现的而不是由服务层实现的，所以并没有同一的标准：不同存储引擎的索引工作方式并不一样，也不是所有的存储引擎都支持所有类型的索引。即时多个存储引擎支持同种索引，其底层实现也可能不同。\nB-Tree索引 B-Tree是为磁盘等外存储设备设计的一种平衡查找树。因此在讲B-Tree之前先了解下磁盘的相关知识。\n系统从磁盘读取数据到内存时是以磁盘块（block）为基本单位的，位于同一个磁盘块中的数据会被一次性读取出来，而不是需要什么取什么。\nInnoDB存储引擎中有 页（Page） 的概念，页是其磁盘管理的最小单位。InnoDB存储引擎中默认每个页的大小为16KB，可通过参数innodb_page_size将页的大小设置为4K、8K、16K，在MySQL中可通过如下命令查看页的大小：\n show variables like 'innodb_page_size';\n 而系统一个磁盘块的存储空间往往没有这么大，因此InnoDB每次申请磁盘空间时都会是若干地址连续磁盘块来达到页的大小16KB。InnoDB在把磁盘数据读入到磁盘时会以页为基本单位，在查询数据时如果一个页中的每条数据都能有助于定位数据记录的位置，这将会减少磁盘I/O次数，提高查询效率。\nB-Tree结构的数据可以让系统高效的找到数据所在的磁盘块。为了描述B-Tree，首先定义一条记录为一个二元组[key, data] ，key为记录的键值，对应表中的主键值，data为一行记录中除主键外的数据。对于不同的记录，key值互不相同。\n\n每个节点占用一个盘块的磁盘空间，一个节点上有两个升序排序的关键字和三个指向子树根节点的指针，指针存储的是子节点所在磁盘块的地址。两个关键词划分成的三个范围域对应三个指针指向的子树的数据的范围域。以根节点为例，关键字为17和35，P1指针指向的子树的数据范围为小于17，P2指针指向的子树的数据范围为17~35，P3指针指向的子树的数据范围为大于35。\nB+Tree索引 从B-Tree结构图中可以看到每个节点中不仅包含数据的key值，还有data值。而每一个页的存储空间是有限的，如果data数据较大时将会导致每个节点（即一个页）能存储的key的数量很小，当存储的数据量很大时同样会导致B-Tree的深度较大，增大查询时的磁盘I/O次数，进而影响查询效率。在B+Tree中，所有数据记录节点都是按照键值大小顺序存放在同一层的叶子节点上，而非叶子节点上只存储key值信息，这样可以大大加大每个节点存储的key值数量，降低B+Tree的高度。\n由于B+Tree的非叶子节点只存储键值信息，假设每个磁盘块能存储4个键值及指针信息，则变成B+Tree后其结构如下图所示：\n\n适用条件：\n 全值匹配 匹配最左前缀 匹配范围值 精确匹配某一列并范围匹配另一列 值访问索引的查询  限制：\n 如果不是按照索引的最左列开始查找，则无法使用索引 不能跳过索引中的列 如果查询中有某个列的范围查询，则其右边所有列都无法使用索引优化查找  Hash索引 哈希索引（hash index）基于哈希表实现，只有精确匹配索引所有列的查询才有效，对于每一行数据，存储引擎都会对所有的索引列计算一个哈希值，哈希值是一个较小的值，并不同的键值的行计算的哈希值也不一样。哈希索引将所有的哈希值存储在索引中，同时在哈希表中保存指向每个数据行的指针。\n限制：\n 哈希索引只包含哈希值和行指针，不存储字段值，所以不能使用索引中的字段避免读取行 哈希索引数据无法用于排序 不支持索引列匹配查找，例如，在数据列（A，B）上建立的索引，如果查询只用到列A列则无法使用该索引 哈希索引只支持等值比较查询 哈希冲突太多会导致性能很低  InnoDB中有一个特殊的功能叫做“自适应索引”InnoDB会注意到使用非常频繁的索引值，会在内存中基于B-Tree索引之上再创建一个哈希索引。\n如何正确的使用索引 独立的列 “独立的列”是指索引列不能是表达式的一部分，也不能是函数的参数。\n例如：\n mysql\u0026gt; SELECT actor_id from actors where actor_id +1 =5 ;\n 这个例子就无法使用索引列 actor_id 。所以在使用WHERE条件的时候，始终将索引列单独放在比较符号的一侧，也不能对索引列使用函数。\n前缀索引和索引选择性 由于需要索引列是一个很长的字符串，这样会导致索引边的慢且大。这时可以通过使用前缀索引来解决，这样可以大大节约索引空间，从而提高索引效率。但是这样会降低索引的选择性。\n 选择性=补充度的索引值(基数)/数据表的记录时总数\n 索引的选择性越高则查询效率越高，唯一索引的选择性是1，这时最好的索引选择性，性能也是最好的。\n多列索引 在多个列上建立独立的单列索引大部分情况下并不能提高MySQL的查询性能。新版本的MySQL中引入了一种叫“索引合并”的策略\n聚簇索引 聚族索引并不是一种单独的索引类型，而是一种数据存储方式。InnoDB聚族索引实际上在同一个结构中保存了B-Tree索引和数据行\n聚簇索引就是按照每张表的主键构造一颗B+树，同时叶子节点中存放的就是整张表的行记录数据，也将聚集索引的叶子节点称为数据页。这个特性决定了索引组织表中数据也是索引的一部分，每张表只能拥有一个聚簇索引。\n聚簇索引的每一个叶节点都包含了主键值、 事务ID、 用于事务和MVCC的回滚指针、以及剩余的列\n\nInnodb通过主键聚集数据，如果没有定义主键，innodb会选择非空的唯一索引代替。如果没有这样的索引，innodb会隐式的定义一个主键来作为聚簇索引。\n聚簇索引的优缺点\n 优点：  数据访问更快，因为聚簇索引将索引和数据保存在同一个B+树中，因此从聚簇索引中获取数据比非聚簇索引更快 聚簇索引对于主键的排序查找和范围查找速度非常快 使用 覆盖索引 扫描的查询可以直接使用页节点中的主键值  缺点：  插入速度严重依赖于插入顺序，按照主键的顺序插入是最快的方式，否则将会出现页分裂，严重影响性能(例如：使用UUID作为索引，它会使插入边的完全随机就会造成页分裂和产生随机碎片)。因此，对于InnoDB表，我们一般都会定义一个自增的ID列为主键 更新主键的代价很高，因为将会导致被更新的行移动。因此，对于InnoDB表，我们一般定义主键为不可更新。 二级索引访问需要两次索引查找，第一次找到主键值，第二次根据主键值找到行数据。 聚簇索引可能导致全表扫描变慢，尤其是行比较稀疏，或者由于 页分裂 导致数据存储不连续的时候   辅助索引（非聚簇索引） 在聚簇索引之上创建的索引称之为辅助索引，辅助索引访问数据总是需要二次查找。辅助索引叶子节点存储的不再是行的物理位置，而是主键值。通过辅助索引首先找到的是主键值，再通过主键值找到数据行的数据页，再通过数据页中的Page Directory找到数据行。\nInnodb辅助索引的叶子节点并不包含行记录的全部数据，叶子节点除了包含键值外，还包含了相应行数据的聚簇索引键。这样的策略减少了当出现行移动或者数据页分裂时二级索引的维护工作。使用主键当作指针会让二级索引占用更多的空间，换来的好处是，InnoDB在移动行时无须更新二级索引中的这个“指针”\n辅助索引的存在不影响数据在聚簇索引中的组织，所以一张表可以有多个辅助索引。在innodb中有时也称辅助索引为二级索引。\n\n与MyISAM引擎中索引的区别如下图：\n\n覆盖索引 如果一个索引包含（或者说是覆盖）所有需要查询的字段的值，我们就称之为“覆盖索引”，覆盖索引的优点本质上就一条：覆盖索引能够避免 *回表*；\n不是所有类型的索引都可以称为覆盖所有。覆盖所有必须要存储索引列的值，而哈希索引、空间索引和全文索引等都不存储索引列的值，所以MySQL只能使用B-Tree索引做覆盖索引。\n当发起一个被索引覆盖的查询（也叫做索引覆盖查询）时，在EXPLAIN的Extra列可以看到“Using index”的信息\nMySQL查询优化器会在执行查询前判断是否有一个索引能够进行覆盖\n参考  聚簇索引和非聚簇索引(通俗易懂 言简意赅) Mysql 索引  ","id":18,"section":"posts","summary":"索引是什么 索引（在MySQL中也称为“键（key）”），用于存储引擎快速找到记录的一种数据结构。这是索引的基础功能。 索引可以包含一个列或多个","tags":["index","mysql"],"title":"MySQL 索引","uri":"https://holicc.github.io/2020/03/about-mysql-index/","year":"2020"},{"content":"TCP是什么 ? 传输控制协议（TCP）是互联网协议组中重要的组成部分之一。TCP的实现之初是为了补充互联网协议（IP）。因此，这一对组合经常被称为TCP/IP。TCP协议的特点：可靠性、顺序性、错误检查、数据流传输。大部分常见的应用都是使用的是TCP协议，例如：World Wide Web、Email、文件传输.TCP是面向连接的，这就需要客户端主动与服务端建立起连接之后才能开始传输数据。如果应用不需要可靠的数据流传输服务可能UPD协议是个更好的选择。\n为什么需要TCP ? TCP是个重要的协议是因为它在互联网的基础上建立了一套规则与标准化的信息数据传输机制。TCP让互联网之间的数据传输能够无视各种条件的限制（不管是地区限制、软件或硬件的限制），并且它是灵活的可拓展的（比如TCP/IP、增加SSL等），并且它是开源的不是私人所有。\n如何保证传输的可靠性? TCP segment structure TCP报文段分为两段：报头、数据段。报头包含10个字段和一个可选的拓展字段。数据段紧跟在 报头后面，里面装的都是应用传输的数据。数据的大小（length）不包括在 报头中；但是可以通过IP数据报的报头中指定的长度减去TCP报头的长度就得到了数据段的大小了。\n\n源端口(16 bits) \u0026amp; 目的端口(16 bits) 本机端口和目的地端口\n序列号(32 bits) 序列号就是用来标记每一个请求的，相当于请求的ID。\n 如果含有同步标识（SYN），则此为最初的序列号；第一个数据比特的序列码为本序列号加一 如果没有同步标识（SYN），则此为第一个数据比特的序列码  确认号 (32 bits) ACK如果被启用了，那么表示收到信息，并且ACK=（发送者的序列号+1）用于验证。\n连接建立 TCP连接的建立需要进行三次握手。在客户端尝试连接服务端之前，服务端需要绑定一个端口并监听它（passive open），之后客户端会主动向服务端发送建立连接请求，并进行 三次握手 建立连接。\n1.客户端向服务端发起一个 SYN请求，并将生成一个随机的序列号A。\n2.作为响应，服务端回复带有SYN-ACK标示的应答。其中ACK=A+1，并同时生成一个随机序列号B。\n3.最后，客户端收到服务端的ACK应答之后。客户端又会给服务端一个ACK应答并且序列号也会加一也A+1，然后ACK的序列号也加一B+1\n到这时候，客户端和服务端都收到了确认连接的消息。步骤1、2建立一个方向的连接参数(序列号)并确认。步骤2、3建立另一个方向的连接参数(序列号)并确认。有了这些，就可以建立全双工通信。\n\nTCP 连接使用三次握手的首要原因：为了 阻止历史的重复连接初始化造成的混乱问题。如果通信双方的通信次数只有两次，那么发送方一旦发出建立连接的请求之后它就没有办法撤回这一次请求，如果在网络状况复杂或者较差的网络中，发送方连续发送多次建立连接的请求，如果 TCP 建立连接只能通信两次，那么接收方只能选择接受或者拒绝发送方发起的请求，它并不清楚这一次请求是不是由于网络拥堵而早早过期的连接。\n所以，TCP 选择使用三次握手来建立连接并在连接引入了 RST 这一控制消息，接收方当收到请求时会将发送方发来的 SEQ+1 发送给对方，这时由发送方来判断当前连接是否是历史连接：\n如果当前连接是历史连接，即 SEQ 过期或者超时，那么发送方就会直接发送 RST 控制消息中止这一次连接； 如果当前连接不是历史连接，那么发送方就会发送 ACK 控制消息，通信双方就会成功建立连接； 使用三次握手和 RST 控制消息将是否建立连接的最终控制权交给了发送方，因为只有发送方有足够的上下文来判断当前连接是否是错误的或者过期的，这也是 TCP 使用三次握手建立连接的最主要原因。\n连接终止 TCP连接的关闭需要进行 四次挥手，两边都需要关闭连接，整个TCP连接才算完整的关闭。希望关闭连接，就会传送 FIN 包并包含之前的ACK包。所以关闭连接需要 一组 FIN 和 ACK。当一边的发送了第一个 FIN和最后的 ACK，会进入一个等待超时状态 TIME_WATI 之道整个连接关闭，在整个连接关闭之前TCP占用的端口不能被其他新连接所使用；这防止了由于延迟发包带来的混乱问题。\n\n对于复杂的网络状态，TCP 的实现提出了多种应对措施， TIME_WAIT 状态的提出就是为了应对其中一种异常状况。在 TIME_WAIT 阶段，主动端等待 2*MSL（最大分段寿命：表示一个 TCP 分段可以存在于互联网系统中的最大时间，由 TCP 的实现，超出这个寿命的分片都会被丢弃） 时间， MSL 建议为 2 分钟。\n如果没有 TIME_WAIT 状态，Client 不再保存这个连接的信息，收到一个不存在的连接的包，Client 会响应 RST 包，导致 Server 端异常响应。此时， TIME_WAIT 是为了 保证全双工的 TCP 连接正常终止。\n如果双方挥手之后，一个 网络四元组（src/dst ip/port）被回收，而此时网络中还有一个迟到的数据包没有被 Server 接收，Client 应用程序又立刻使用了同样的四元组再创建了一个新的连接后，这个迟到的数据包才到达 Server，那么这个数据包就会让 Server 以为是 Client 刚发过来的。此时， TIME_WAIT 的存在是为了 保证网络中迷失的数据包正常过期。\n连接可以处于半开状态，意思就是TCP的有一方连接已经关闭了，另一方还没有关闭。\n\n数据传输 可靠性传输 TCP使用 序列号标记每一份数据，通过使用序号和确认号，TCP 层可以把收到的报文段中的字节按正确的顺序交付给应用层，TCP 协议使用序号标识每端发出的字节的顺序，从而另一端接收数据时可以重建顺序，无惧传输时的包的乱序交付或丢包。在发送第一个包时（SYN包），选择一个 随机数 作为序号的初值，以克制 TCP 序号预测攻击。\n发送确认包（Acks），携带了接收到的对方发来的字节流的编号，称为确认号，以告诉对方 已经成功接收的数据流的字节位置。Ack并不意味着数据已经交付了上层应用程序。可\n靠性通过发送方检测到丢失的传输数据并重传这些数据。包括 超时重传（Retransmission timeout，RTO）与 重复累计确认 （duplicate cumulative acknowledgements，DupAcks）。\n重复累计确认重传 如果一个包（不妨设它的序号是 100 ，即该包始于第 100 字节）丢失，接收方就不能确认这个包及其以后的包，因为采用了 累计ACK 。接收方在收到 100 以后的包时，发出对包含第 99 字节的包的确认。这种重复确认是包丢失的信号。发送方如果收到 3 次对同一个包的确认，就重传最后一个未被确认的包。阈值设为 3 被证实可以减少乱序包导致的无作用的重传（spurious retransmission）现象。选择性确认（SACK）的使用能明确反馈哪个包收到了，极大改善了TCP重传必要的包的能力。\n超时重传 发送方使用一个保守估计的时间作为收到数据包的确认的超时上限。如果超过这个上限仍未收到确认包，发送方将重传这个数据包。每当发送方收到确认包后，会重置这个重传定时器。典型地，定时器的值设定为 \\({\\displaystyle {\\text{smoothed RTT}}+\\max(G,4\\times {\\text{RTT variation}})}\\) 是时钟粒度。进一步，如果重传定时器被触发，仍然没有收到确认包，定时器的值将被设为前次值的二倍（直到特定阈值）。这可对抗 中间人攻击方式的拒绝服务攻击，这种攻击愚弄发送者重传很多次导致接受者被压垮。\n流量控制 流量控制用来避免主机分组发送得过快而使接收方来不及完全收下，一般由接收方通告给发送方进行调控，这里的窗口被称为 接收通知窗口（Receiver's Advertised Window）。\n流量控制通过 滑动窗口机制 来实现： 报文发送方 在 WIN 域指出还可接收的字节数量（rwnd）。报文接收方在没有新的确认包的情况下至多发送 WIN 允许的字节数量。在数据传输过程中，报文发送方可修改 WIN 的值。\n拥塞控制 TCP 拥塞控制算法是互联网上主要的拥塞控制措施，它使用一套基于 线増积减（Additive increase/multiplicative decrease，AIMD）的网络拥塞控制方法来控制拥塞，防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载。\n除了 拥塞窗口大小（cwnd） 之外，TCP 连接的双方都有 接收窗口大小（rwnd）。客户端能够同时传输的最大数据段的数量是接收窗口大小和拥塞窗口大小的最小值，即 min(rwnd, cwnd)min(rwnd,cwnd) 。\nTCP 协议使用慢启动阈值（Slow start threshold, ssthresh）来决定使用慢启动或者拥塞避免算法：\n当拥塞窗口大小小于慢启动阈值时，使用慢启动； 当拥塞窗口大小大于慢启动阈值时，使用拥塞避免算法； 当拥塞窗口大小等于慢启动阈值时，使用慢启动或者拥塞避免算法；\n慢开始和拥塞避免 客户端维持一个 拥塞窗口 cwnd 的状态变量，初始值一般为 2\\times MSS2×MSS 。\n 慢开始：由小到大的指数增大拥塞窗口。首先将 cwnd 设置为一个最大报文段 MMS ，在收到一个对新的报文段的确认后，把拥塞窗口增加一个 MMS 。\n 拥塞避免：当慢开始到阈值（ssthresh）后，使用拥塞避免算法（ cwnd 每次加1 ）。当发送方发送的数据包丢包时，将 ssthresh 置为 cwnd 的一半，将 cwnd 置为1，再次执行慢开始。\n  快重传和快恢复 快速重传和恢复（fast retransmit and recovery，FRR） 是一种拥塞控制算法，它能快速恢复丢失的数据包。没有 FRR，如果数据包丢失了，TCP 将会使用定时器来要求传输暂停。在暂停的这段时间内，没有新的或复制的数据包被发送。有了FRR，如果接收机接收到一个不按顺序的数据段，它会立即给客户端发送一个重复确认。如果客户端接收到三个重复确认，它会认定数据段丢失，并立即重传这些丢失的数据段。\n有了 FRR，就不会因为重传时要求的暂停被耽误。当有单独的数据包丢失时，快速重传和恢复（FRR）能最有效地工作。当有多个数据信息包在某一段很短的时间内丢失时，它则不能很有效地工作。\nBBR BBR（Bottleneck Bandwidth and Round-trip propagation time）是 Google 研发的新的拥塞控制算法。自从 20 世纪 80年代后， TCP 中的拥塞控制算法都使用的是 基于丢包的拥塞控制（拥塞避免），在之前的网络带宽、路由器 Buffer 的情况下，该算法效果良好。\n但是在当前的网络条件下，基于丢包的拥塞控制算法则会导致 TCP 性能问题：\n在小 Buffer 路由器环境下，丢包发生在拥塞之前。在高速，长途链路中，基于丢包的拥塞控制会导致吞吐量过低，因为它反应过度，即使丢包是由瞬时流量突发引起的，也会因丢包而将发送速率减半（即使链路大部分处于空闲状态，这种丢包也可能非常频繁） 在大 Buffer 路由器环境下，拥塞发生在丢包之前。在互联网的边缘，基于丢包的拥塞控制通过反复填充大量的缓存，从而导致了臭名昭著的 bufferbloat 问题。 bufferbloat 问题：由于路由器的大缓存，减少链路丢包。再加上网络中 TCP 大量使用基于丢包的拥塞控制算法（丢包才触发速度下调，但是要丢包，缓存就得先被填满，缓存都填满，延迟更高）\nBBR 算法使用最大带宽和往返时间来建立网络的显式模型。每次对包传递进行累积或选择性确认，都会生成一个速率样本，该速率采样记录在数据包传输与该包确认之间的时间间隔内传递的数据量，从而使拥塞控制算法能够提供更高的吞吐量和更低的延迟。\n最大分段大小 最大分段大小 (MSS) 是在单个分段中 TCP 愿意接受的数据的字节数最大值。MSS应当足够小以避免IP分片，它会导致丢包或过多的重传。\n在 TCP 连接创建时，双端在 SYN 报文中用 MSS 选项宣布各自的 MSS ，这是从双端各自直接相连的数据链路层的最大传输单元(MTU)的尺寸减去固定的 IP 首部和 TCP 首部长度。以太网MTU为 1500 字节， MSS值可达 1460 字节。使用 IEEE 802.3 的 MTU 为 1492 字节，MSS 可达 1452 字节。\n如果目的IP地址为“非本地的”，MSS通常的默认值为 536（这个默认值允许 20 字节的 IP 首部和 20 字节的 TCP 首部以适合 576字节 IP 数据报）。此外，发送方可用传输路径 MTU 发现（RFC 1191）推导出从发送方到接收方的网络路径上的最小 MTU，以此动态调整 MSS 以避免网络 IP 分片。\nMSS 发布也被称作“MSS协商”（MSS negotiation）。严格讲，这并非是协商出来一个统一的MSS值，TCP 允许连接两端使用各自不同的MSS值。例如，这会发生在参与 TCP 连接的一台设备使用非常少的内存处理到来的 TCP 分组。\n选择确认 最初采取累计确认的 TCP 协议在丢包时效率很低。例如，假设通过10个分组发出了1万个字节的数据。如果第一个分组丢失，在纯粹的累计确认协议下，接收方不能说它成功收到了 1,000 到 9,999 字节，但未收到包含 0 到 999 字节的第一个分组。因而，发送方可能必须重传所有1万个字节。\n为此，TCP采取了 选择确认（selective acknowledgment，SACK） 选项。RFC 2018 对此定义为 允许接收方确认它成功收到的分组的不连续的块，以及基础 TCP 确认的成功收到最后连续字节序号。这种确认可以指出 SACK block，包含了已经成功收到的连续范围的开始与结束字节序号。在上述例子中，接收方可以发出 SACK 指出序号 1000 到 9999 ，发送方因此知道只需重发第一个分组(字节 0 到 999)。\nTCP 发送方会把乱序收包当作丢包，因此会重传乱序收到的包，导致连接的性能下降。重复SACK选项（duplicate-SACK option）是定义在RFC 2883中的SACK的一项扩展，可解决这一问题。接收方发出 D-SACK 指出没有丢包，接收方恢复到高传输率。 D-SACK 使用了 SACK 的第一个段来做标志：\n  如果 SACK 的第一个段的范围被 ACK 所覆盖，那么就是 D-SACK; 如果 SACK 的第一个段的范围被 SACK 的第二个段覆盖，那么就是 D-SACK D-SACK旨在告诉发送端：收到了重复的数据，数据包没有丢，丢的是ACK包；   SACK 选项并不是强制的。仅当双端都支持时才会被使用。 TCP 连接创建时会在 TCP 头中协商 SACK 细节。在 Linux下，可以通过 tcp_sack 参数打开 SACK 功能（Linux 2.4后默认打开）。Linux下的 tcp_dsack 参数用于开启D-SACK功能（Linux 2.4后默认打开）。选择确认也用于流控制传输协议 (SCTP)。\n参考  TCP TCP Protocol From Wikipedia Why TCP is important 《TCP IP 详解 第四版》  ","id":19,"section":"posts","summary":"TCP是什么 ? 传输控制协议（TCP）是互联网协议组中重要的组成部分之一。TCP的实现之初是为了补充互联网协议（IP）。因此，这一对组合经常被","tags":["networking","tcp"],"title":"About TCP Protocol","uri":"https://holicc.github.io/2020/03/about-tcp-protocol/","year":"2020"}],"tags":[{"title":"index","uri":"https://holicc.github.io/tags/index/"},{"title":"mysql","uri":"https://holicc.github.io/tags/mysql/"},{"title":"networking","uri":"https://holicc.github.io/tags/networking/"},{"title":"powershell","uri":"https://holicc.github.io/tags/powershell/"},{"title":"programing","uri":"https://holicc.github.io/tags/programing/"},{"title":"rocketMQ","uri":"https://holicc.github.io/tags/rocketmq/"},{"title":"rust","uri":"https://holicc.github.io/tags/rust/"},{"title":"tcp","uri":"https://holicc.github.io/tags/tcp/"}]}